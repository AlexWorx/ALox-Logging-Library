<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALox: 05 - Scopes in ALox</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1712 R. 0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--ALox Main Menu-->
<div style="background: #2f3a48; " >
<table  class="aworx-menutable"  >
 <tbody>
 <tr style="height: 36px;">
  <td> <a class="aworx-menu_hl" href="index.html"                                      >Home</a>                        </td>
  <td> <a class="aworx-menu"    href="cpp_ref/alox_cpp_mainpage.html"                   >ALox for C++</a>                </td>
  <td> <a class="aworx-menu"    href="cs_ref/alox_cs_mainpage.html"                     >ALox for C#</a>                 </td>
  <td> <a class="aworx-menu"    href="java_ref/alox_java_mainpage.html"                 >ALox for Java</a>               </td>
  <td> <a class="aworx-menu"    href="https://github.com/AlexWorx/ALox-Logging-Library">Download</a></td>
 </tr>
 </tbody>
</table>
</div>
<!--end ALox Main Menu-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">05 - Scopes in ALox </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#alox_man_scopes_intro">1. Introduction</a></li>
<li class="level1"><a href="#alox_man_scopes_language">2. Language-Related Scopes</a><ul><li class="level2"><a href="#alox_man_scopes_language_global">2.1 Scope.Global</a></li>
<li class="level2"><a href="#alox_man_scopes_language_path">2.2 Scope.Path (In Java Scope.PACKAGE)</a></li>
<li class="level2"><a href="#alox_man_scopes_language_filename">2.3 Scope.Filename (In Java Scope.CLASS)</a></li>
<li class="level2"><a href="#alox_man_scopes_language_method">2.4 Scope.Method</a></li>
<li class="level2"><a href="#alox_man_scopes_language_anonymous">2.5 Anonymous Scopes</a></li>
<li class="level2"><a href="#alox_man_scopes_language_setting">2.6 How To Set Scope Domains for Language-Related Scopes</a></li>
</ul>
</li>
<li class="level1"><a href="#alox_man_scopes_thread">3. Thread-Related Scopes</a><ul><li class="level2"><a href="#alox_man_scopes_thread_outer">3.1 Use Cases for Scope.ThreadOuter</a></li>
<li class="level2"><a href="#alox_man_scopes_thread_inner">3.2 Use Cases for Scope.ThreadInner</a></li>
<li class="level2"><a href="#alox_man_scopes_thread_multiple">3.3 Multiple Use of Thread-Related Scopes</a></li>
<li class="level2"><a href="#alox_man_scopes_thread_setting">3.4 How To Set Scope Domains for Thread-Related Scopes</a></li>
</ul>
</li>
<li class="level1"><a href="#alox_man_scopes_wrapup">4. Wrap up</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="alox_man_scopes_intro"></a>
1. Introduction</h1>
<p>ALox uses the concept of <em>Scopes</em> in different ways. The most important and prominent use is to set so called <em>Scope Domains</em>. Those can be registered and then are used as a 'default' domain path with each <em>Log Statement</em> placed within the according <em>Scope</em>. The concept of <em>Scope Domains</em> has been explained already in the previous chapter (see <a class="el" href="alox_man_logdomains.html">04 - Log Domains</a>). But to keep it simple, the full variety of ALox <em>Scopes</em> was not yet, explained there. This is what this chapter aims to do.</p>
<p>So, be sure, that you have read and understood chapter <a class="el" href="alox_man_logdomains.html">04 - Log Domains</a>, before working yourself through this chapter. Using the more complex possibilities of scopes is optional when using ALox, so you can consider this chapter as an advanced topic.</p>
<p>Furthermore, there are other features in ALox that use <em>Scopes</em>. Those are elaborated in chapters</p><ul>
<li><a class="el" href="alox_man_log_once.html">06 - Lox.Once()</a>,</li>
<li><a class="el" href="alox_man_prefix_logables.html">07 - Prefix Logables</a> and</li>
<li><a class="el" href="alox_man_log_data.html">08 - Log Data (Debug Variables)</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>When talking about <em>Scopes</em>, it is not easy to use a precise wording. (Therefore, we do not even try in this manual and other documentation of ALox!) The reason for this is that the <em>Scope</em> is not one value but is defined as a nested list of values. For example, when we say that two <em>Log Statements</em> that reside in the same file (Java: CLASS) have the same <em>Scope</em>, then this is true for <em>Scope.Filename</em>, but maybe not for <em>Scope.Method</em>. Also, it is not easy in English language to denote exactly what the difference of the <em>Scope</em> of a <em>Scope Domain</em> is in contrast to the <em>Scope</em> of a <em>Log Statement</em>. So, please excuse the imprecise use of that word, we are still sure you will understand what we talk about.</dd></dl>
<p>ALox <em>Scopes</em> are enumerated in enum-class <b>Scope</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/namespacecs_1_1aworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/enumcom_1_1aworx_1_1lox_1_1Scope.html">Java</a>). The <em>Scopes</em> found here are separated in two sets:</p>
<ul>
<li><b>Scopes related to the programming language:</b><br />
 These scopes are identified 'automatically' at compile time with each invocation to a method of class <b>Lox</b> (as well as of class <b>Log</b> in ALox for C# and Java). In Java, for technical reasons, they are identified at runtime, but this does not affect their behavior.</li>
<li><b>Scopes related to the execution thread:</b><br />
 These scopes are identified at runtime, by examining the thread that is executing a method of class <b>Lox</b>.</li>
</ul>
<h1><a class="anchor" id="alox_man_scopes_language"></a>
2. Language-Related Scopes</h1>
<p>ALox adopts the concept of <em>Scopes</em> from each programming language of its implementation (currently C++, C# and Java). A variable declared in one of these languages belongs to a certain scope, e.g. to the <em>class</em> when it is a <em>member variable</em>.</p>
<p><em>Scopes</em> are <b>nested</b> into each other. We talk about 'outer' and 'inner' scopes. For example the <em>Scope</em> of a method is nested into the <em>Scope</em> of the class that the method belongs to.</p>
<p>The language-related <em>Scopes</em> that ALox supports are (from outer to inner):</p>
<ul>
<li><b>Scope.Global</b>,</li>
<li><b>Scope.Path</b> (in Java: <b>Scope.PACKAGE</b>),</li>
<li><b>Scope.Filename</b> (in Java: <b>Scope.CLASS</b>) and</li>
<li><b>Scope.Method</b>.</li>
</ul>
<p>Apart from <em>Scope.Global</em>, to evaluate the actual <em>Scope</em> of an invocation to class <b>Lox</b>, ALox needs to 'automatically' collect information of the calling entity. The techniques are different in each implementation:</p><ul>
<li>In ALox for C++ is this is achieved using preprocessor macros for all <em>Log Statements</em>.</li>
<li>In ALox for C# the method annotations '[CallerFilePath]', [CallerLineNumber] and [CallerMemberName] are leveraged.</li>
<li>In ALox for Java, the detection is performed at runtime by examining the 'stack trace' of an object of type Exception which is solely created for this purpose. (This implies a quite huge performance overhead, which roughly triples the execution time of a <em>Log Statement</em> in Java. However, as soon as such runtime information is not used, e.g. in typical release-logging, the overhead is avoided. And: ALox is fast still!).</li>
</ul>
<p>As explained in detail in chapter <a class="el" href="alox_man_debug_and_release_logging.html">10 - Differences of Debug- and Release-Logging</a>, for release-logging, such automatic collection is not wanted. Without repeating the reasons for this here, let us emphasize the consequence:</p>
<dl class="section attention"><dt>Attention</dt><dd>The <em>Scopes.Path</em> (in Java Scope.PACKAGE), <em>Scope.Filename</em> (in Java Scope.CLASS) and <em>Scope.Method</em> can be used for debug-logging only! While it is possible to set <em>Scope Domains</em> and use other features of ALox which rely on <em>Scopes</em>, in release-logging, scope information values will be empty and hence not distinguishable from each other.<br />
 In ALox for Java, if a release application is obfuscated, such missing scope information is not detected and the result of its use is undefined.</dd></dl>
<p>The good news is: This is absolutely OK! The rational for claiming this is:</p><ul>
<li>In respect to <em>Scope Domains</em>:<br />
 Release-logging statements are quite rare compared to those of debug logging. Furthermore, they should be very well thought, clear and meaningful. It is advisable to not use <em>Scope Domains</em> in release logging anyhow (apart from thread-related and <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6a4cc6684df7b4a92b1dec6fce3264fac8">Scope.Global</a> as explained below). Instead, <em>Log Statements</em> that comprise release-logging should specify the <em>Log Domains</em> they refer to <b>explicitly</b>.</li>
<li>In respect to <em>Log Data</em>:<br />
 Well, the whole concept of <em>Log Data</em> provided by ALox is merely a tool to support the process of debugging, e.g. to explore the location of an exception in the log output. It is not deemed to be used to implement any functionality of an application, for example to store thread-local information.</li>
<li>In respect to method <b>Lox.Once</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a79bebcd15b9f6a526c4e5d9d3c79c46f">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a29a0ad7eabed8e8b8f2a698d30250975">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#a7347b1bdc9a7abe966bd812190f54db8">Java</a>):<br />
 For release logging, the optional parameter <code>group</code> certainly does the job. It should be used because, this makes release logging statements to be more explicit and readable.</li>
<li>In respect to <em>Prefix Logables</em>:<br />
 The most important use case for them are to make the output better readable, e.g. by adding recursive indentation. Again, something that should not be too important for release logging. If it still is, a thread-related <em>Scope</em> can be used.</li>
</ul>
<p>The following sections describe each of the language-related <em>Scopes</em> in detail.</p>
<h2><a class="anchor" id="alox_man_scopes_language_global"></a>
2.1 Scope.Global</h2>
<p>As the name of this <em>Scope</em> indicates, this is the 'most outer' <em>Scope</em> of ALox. It is always there and only one single 'instance' of it exists per Lox. In other words, all <em>Log Statements</em> or other invocations of ALox are executed 'within' this singleton scope.</p>
<dl class="section note"><dt>Note</dt><dd>Because scopes are managed by class <b>Lox</b>, each instance of this class provides its own <em>Global</em> scope, the same as a <em>Lox</em> has different <em>Loggers</em>, <em>Log Domains</em>, <em>Scope Domains</em>, <em>Log Data</em>, etc. Well, and this makes perfect sense!</dd></dl>
<p>When setting <em>Scope Domains</em> for the <em>Global</em> <em>Scope</em>, all <em>Log Statements</em> have such domain as their root-domain. (Of-course, unless one inner <em>Scope Domain</em> or the statement itself is using an absolute domain path!).</p>
<p>One use case of setting a <em>Scope Domain</em> for <em>Scope.Global</em> could be described as follows: A <b>Lox</b> used for release-logging of special and sparse <em>Log Statements</em> (e.g. logging into the operating systems' journal, aka event log). Now, in debug versions of the executable a debug-<em>Logger</em> is attached to the release lox (in addition to attaching it to the debug-lox), within this debug log output, all of these special <em>Log Statements</em> would be nicely sorted into the <em>Scope Domain</em> of <em>Scope.Global</em>, while non of the <em>Log Statements</em> to this release lox need to specify that domain path.</p>
<p>Another use case are special debug situations. Imagine a dubious behavior of a software is observed rather seldom. A programmer could register a debug <em>Logger</em> with <em>Verbosity</em> <em>All</em> for domain '/DEBUG'. Now, when a certain first indication for the start of the dubious behavior occurs, a setting of the <em>Scope Domain</em> '/DEBUG' for <em>Scope.Global</em> can be activated. From this point in time, all <em>Log Statements</em> would be activated, because all <em>Log Statements</em> of all code would be gathered beyond that temporary <em>Log Domains</em> '/DEBUG' and all sub-domains inherit its <em>Verbosity</em>.</p>
<h2><a class="anchor" id="alox_man_scopes_language_path"></a>
2.2 Scope.Path (In Java Scope.PACKAGE)</h2>
<p>This <em>Scope</em> has a different name and meaning in ALox for C++/C# and ALox for Java. Let's start with the Java side of things - well, but, even as a C++ or C# programmer, please continue reading here!</p>
<p>The scope information collected by ALox for each <em>Log Statement</em> incorporates the 'package' name of the class and method that is executing it. Therefore, using method <b>Lox.SetDomain</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a230b89005c93ffdbfe0dd689d7eb0f11">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a61e2df18f576ca8184ea5d4e21148bc4">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#afd6a91bb2c6eaee017b0ccbd4cccd447">Java</a>) with <em>Scope</em> PACKAGE in Java instructs ALox to use the given <em>Scope Domain</em> for all <em>Log Statements</em> residing in any class of the package. Now, method <b>Lox.SetDomain</b> optionally offers a parameter <code>packageLevel</code> which defaults to <code>0</code>. This parameter is ignored with other <em>Scopes</em>. For <em>Scope.PACKAGE</em>, however it allows to refer to an 'outer package'. If this parameter is set to <code>1</code>, ALox searches the last '.' in the package name and cuts this and the rest of the name off. This way, <em>Scope.PACKAGE</em> can be considered to not denoting just a single <em>Scope</em>, but rather <b>a set of nested scopes</b> itself! Consequently, when executing a <em>Log Statement</em> within a method of a class residing in a nested package for which a <em>Scope Domain</em> is set, then, if any of the 'parent' packages of this package has also set a <em>Scope Domain</em>, each of them is applied!</p>
<p>The corresponding concept of Java 'packages', in C++ and C# are 'namespaces'. Unfortunately, ALox is not able to automatically gather information about the namespace that a <em>Log Statement</em> resides in. To achieve a similar functionality in these languages, the way out, is using the path in the file system of the source file that embeds a <em>Log Statement</em>. The prerequisite for this is that all source files are <b>sorted properly into sub-directories</b> according to the namespace they they belong to. For example, a directory tree could look like this: </p><pre class="fragment">    /home/user/myproject/src/main.cpp
    /home/user/myproject/src/ui/menu/menu.cpp
    /home/user/myproject/src/ui/dialogs/about.cpp
    /home/user/myproject/src/io/sockets/http.cpp
    /home/user/myproject/src/io/database/mysql.cpp
</pre><p>With a directory structure similar to the one given above, <b>Scope.Path</b> available in ALox for C++/C# works exactly the same as <em>Scope.PACKAGE</em> in Java. A <em>Log Statement</em> which resides in file </p><pre class="fragment">    /home/user/myproject/src/ui/dialogs/about.cpp
</pre><p>would have path </p><pre class="fragment">    /home/user/myproject/src/ui/dialogs
</pre><p>as associated <em>Scope.Path</em>. Instead of optional paramter \ packageLevel of method <b>Lox.SetDomain</b>, in C++ and and C# the outer directories can simply be reached by adding an integer value specifying the number of directories to cut, to the enumeration element <b>Scope::Path</b>.</p>
<dl class="section note"><dt>Note</dt><dd>This differences in the interface is caused by the fact that Java does not allow to do arithmetics with elements of enumerations. C# allows this and in C++ we use the concept of <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx.html#a4ef0c1ae06e0ec4aaf4fa06db3764aaf">ALib arithmetical enums</a>.).</dd></dl>
<p>If this is used, for values greater than <code>0</code>, the corresponding amount of directories are cut from the end of the source files' path to determine the parent directory that a <em>Scope Domain</em> should be set for. As with Java packages, <em>Scope.Path</em> can be considered being not just a single <em>Scope</em>, but rather a set of nested scopes itself. All <em>Scope Domains</em> set for a path of a file as well as those set for parent directories within this path, are applied - from the inner path to the outer path.</p>
<dl class="section note"><dt>Note</dt><dd>In general, the organization of the source code in a well structured tree of directories corresponding to the tree of nested namespaces, is a good idea.<br />
 If a project using ALox is <em>not</em> organized this way, and there is no possibility to restructure the source tree for this purpose, then the <em>Scope.Path</em> still can be used. It just will not match and reflect the namespace but (quite as its name indicates) the structure of the source tree.<br />
 However, if all sources of a project simply reside just in one single directory, then the use of <em>Scope.Path</em> is not advisable. Its effect would be similar to <a class="el" href="alox_man_scopes.html#alox_man_scopes_language_global">Scope.Global</a>, with the only difference that a thread-related <em>Scope</em> is applied after <em>Scope.Path</em> but before <em>Scope.Global</em>. (Thread-related <em>Scopes</em> are discussed later in this chapter).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Because ALox is designed to tolerate errors as much as possible, the use of values for parameter <code>packageLevel</code> (in Java, respectively in C++/C# the use of adding interger values to enum element <b>Scope::Path</b>) that are higher than the number of sub-packages (respectively directories) that can be cut, does <em>not</em> result in an error. Instead, an empty package/path name is registered and consequently, a registration with, lets say level <code>42</code> would simply be overwritten by a subsequent registration with level <code>43</code> and the effect would be nearly similar to using <em>Scope.Global</em>.<br />
 In C++/C# on Windows OS, still the drive letter would remain and such setting would apply to all source files residing on the corresponding drive.</dd></dl>
<h2><a class="anchor" id="alox_man_scopes_language_filename"></a>
2.3 Scope.Filename (In Java Scope.CLASS)</h2>
<p>Like <em>Scopes</em> <em>Path/PACKAGE</em>, this <em>Scope.Filename/CLASS</em> has a different name and meaning in ALox for C++/C# and ALox for Java. But here it is quite simple.</p>
<p>In Java, <em>Scope.CLASS</em> simply refers to all statements used within a class.</p>
<p>Again, in C++/C# ALox is unable to automatically identify a class name that a <em>Log Statement</em> resides in. Furthermore, in C++ a <em>Log Statement</em> may not even reside within a class. Therefore, the corresponding <em>Scope.Filename</em> in those languages refer to the name of the source file that a <em>Log Statement</em> resides in. In the usual case when each classes' code resides within a dedicated source file, the effect of both <em>Scopes</em> are the same.</p>
<p>Files with the same name, but residing in different directories are treated as different files.</p>
<p>In C++, if the file name has an extension (like .cpp, .hpp, .h, .hxx, etc.), such extension is ignored. This way, by setting a <em>Scope Domain</em> of <em>Scope.Filename</em> e.g. from within a '.cpp' file, such setting also applies to <em>Log Statements</em> occurring in the corresponding '.hpp' file. Again, this is only true if both files reside in the same directory!</p>
<h2><a class="anchor" id="alox_man_scopes_language_method"></a>
2.4 Scope.Method</h2>
<p><em>Scope.Method</em> (in Java Scope.METHOD) comprises all <em>Log Statements</em> which are residing in a certain method. This is the 'most inner' of the language-related set of <em>Scopes</em> supported by ALox. But it is not the most inner of all ALox <em>Scopes</em>, as we will learn later in this chapter.</p>
<p>As <em>Scope.Method</em> is 'language-related', its behavior is like in the programming language in respect to nested method calls: Same as a method variable is not 'visible' within other methods that are invoked from this method, a <em>Scope Domain</em> set in a method is not 'active' within nested, invoked methods. This of-course makes a lot of sense, otherwise <em>Scope Domains</em> of methods would be overwritten or at least redirected by <em>Scope Domains</em> of a calling method.</p>
<dl class="section note"><dt>Note</dt><dd>ALox also provides a feature of adding a <em>Scope Domain</em> for a method and all methods it invokes! The way how to achieve this is described later in this chapter.</dd></dl>
<h2><a class="anchor" id="alox_man_scopes_language_anonymous"></a>
2.5 Anonymous Scopes</h2>
<p>The programming languages C++, C# and Java, allow to open and close 'anonymous scopes' using curly braces '{' and '}'. For example, a variable declared in such anonymous scope is not visible to the rest of the method. Unfortunately, these anonymous scopes can not be 'detected' by ALox automatically. In C++, with the help of its concept of strict 'stack-unwinding', it would be possible to extend ALox to support inner <em>Scopes</em> for nested blocks that automatically get unset as soon as program execution leaves an anonymous scope. In favor of keeping the different language versions compatible (and also in favor to not overcomplicate things!), this is not offered by ALox.</p>
<p>But there is an obvious way to reach the goal of setting sub-domains for <em>Log Statements</em> within a block of code: Simply equip each <em>Log Statement</em> of an anonymous source scope with a relative path using parameter <code>domain</code>. Such relative domain paths provided with a <em>Log Statement</em> are placed by ALox within the evaluated, resulting domain path, as if they resulted from a <em>Scope Domain</em> setting of an inner <em>Scope</em> of <em>Scope.Method</em>.</p>
<h2><a class="anchor" id="alox_man_scopes_language_setting"></a>
2.6 How To Set Scope Domains for Language-Related Scopes</h2>
<p>When reading earlier chapter <a class="el" href="alox_man_logdomains.html">04 - Log Domains</a> and the later chapters (<a class="el" href="alox_man_log_once.html">06 - Lox.Once()</a>, <a class="el" href="alox_man_prefix_logables.html">07 - Prefix Logables</a> and <a class="el" href="alox_man_log_data.html">08 - Log Data (Debug Variables)</a>), you might be surprised, that the only way to use a specific <em>Scope</em> is to do this with an invocation of a corresponding method of class <b>Lox</b> <b>from within</b> that <em>Scope</em> itself.</p>
<p>Why does ALox not provide alternative interfaces that makes it possible to explicitly address a <em>Scope</em> with an invocation from 'outside' of this scope? E.g. why is it not possible to set the scope for a method by naming the class and method, e.g. in the bootstrap section of an application?</p>
<p>The reason is to avoid ambiguities and misconfigurations. If such possibility existed, even if a method class names were given, the same class and method name, might exist in a library, probably using a different namespace. This makes it obvious that the full 'outer' scope has to be provided. Still, adding the namespace in Java would be easily possible, however in C++/C# we are working with the source files' paths and these are quite volatile things. When working in a team, or already when one person is working in parallel on two different machines (at work and at home) the paths may vary. Furthermore any sort of code refactoring in any respect would enforce a 'manual' change of scope specifications.<br />
 The errors and hassle that would quickly occur when the explicit naming of <em>Scopes</em> was supported by ALox would not justify the benefits.</p>
<p>But we do not consider this as a restriction. The responsibility for <em>Log Domains</em> names is deemed to rely in 'the hands' of the code that is defining the <em>Log Statements</em> using these <em>Log Domains</em>. The maintainer of a certain subset of a code within a project should know best which domains and sub-domains are to be used. As an exclamation, the use of rather 'global' domains that collect certain information, e.g. "/CONFIG_ERRORS", should be aligned across the team. Usually those domains are addressed using an absolute path within a <em>Log Statement</em> - and hence are not impacted by the <em>Scope</em> and potentially associated <em>Scope Domains</em> anyhow.</p>
<dl class="section note"><dt>Note</dt><dd>There is one obvious use case, that might let you think about changing <em>Scope Domains</em> set in scopes not reachable by your code: This is when for some reason you want to change the domains that a library (or part of the project you do not have access to) uses. To do this, ALox provides a concept called <em>Domain Substitution</em>, described in <a class="el" href="alox_man_domain_substitution.html">15 - Log Domain Substitution</a>. The huge advantage of this approach is, that this feature substitutes <b>all</b> <em>Log Domains</em>, regardless whether they are evaluated by ALox from <em>Scope Domains</em> or if they are given as parameters of the <em>Log Statement</em>.</dd></dl>
<p>Having said this, it is agreed and and understood that the definition of <em>Scope Domains</em> of language-related <em>Scopes</em> has to appear in source code within the <em>Scope</em> itself - optionally within an 'inner' <em>Scope</em> of the <em>Scope</em>. For example, within a method of a class, both <em>Scope.Method</em> and <em>Scope.Filename</em> (in Java <em>Scope.CLASS</em>) can be set.</p>
<p>What should be avoided are <b>Contrary settings</b>. If the same <em>Scope</em> is set with different values, the second invocation just replaces the first one. Therefore, some random behavior might appear when the settings of <em>Scope Domains</em> are contrary. For example, a <em>Scope Domain</em> for a package name (Java) or source folder (C++/C#) could be set from different classes belonging to this package, respectively source folder. As a rule of thumb (to avoid double definitions), it is advised to put the registration code to the most central (important) class of such package.</p>
<p>A snapshot of all current settings can be logged using <b>Lox.State</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a8396987d83aaa22cb36dad2d9d2254dd">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a801d9784fa14e309a1889fd0afb09a36">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#ad0811a76c83beede4960c95ab5ca6630">Java</a>) to investigate which settings have been performed. Alternatively, if the snapshot is not enough to understand what is set, overwritten and used where, a live log of ALox' internal messages can be activated to identify exactly what the code is doing in respect to <em>Scope Domains</em>. See <a class="el" href="alox_man_internal_domains.html">11 - Internal Logging</a> for more information about how to enable internal log messages.</p>
<h1><a class="anchor" id="alox_man_scopes_thread"></a>
3. Thread-Related Scopes</h1>
<p>This section adds two new <em>Scope</em> 'levels', named:</p>
<ul>
<li><b>Scope.ThreadOuter</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6a1ee3f312b05c55202500569aadfc8d9b">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/namespacecs_1_1aworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6a1ee3f312b05c55202500569aadfc8d9b">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/enumcom_1_1aworx_1_1lox_1_1Scope.html#aabf288453df4cb2f2a6eac9c4084df0e">Java</a>) and</li>
<li><b>Scope.ThreadInner</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6ae46b159c990fae9e712309bdb4d7b7c4">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/namespacecs_1_1aworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6ae46b159c990fae9e712309bdb4d7b7c4">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/enumcom_1_1aworx_1_1lox_1_1Scope.html#abd145edf116fded9bc67b69922f52ca0">Java</a>)</li>
</ul>
<p>to the ALox <em>Scope</em> feature. As the name indicates, these <em>Scopes</em> create a reference to the thread that is executing a statement that is using values associated with such <em>Scope</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Even if your application is single-threaded, you should continue reading!</dd></dl>
<p>Looking at <em>Scope Domains</em>, of-course, they are used to add an additional component to the overall evaluated <em>Log Domains</em> path of a <em>Log Statement</em>. For <em>Scope.ThreadOuter</em>, such addition is performed at the beginning of the evaluated <em>Log Domains</em> path, directly after <em>Scope.Global</em>. For <em>Scope.ThreadInner</em>, the <em>Scope Domain</em> set is appended at the very end of the evaluated <em>Log Domains</em> path. The term 'very end' is important: This is not only the most 'inner' of all <em>Scopes</em>, it is appended to the assembled <em>Log Domains</em> path even after the optional parameter <code>domain</code> of a <em>Log Statement</em>. In other words, it could be said, that <em>Scope.ThreadInner</em> is even more 'inner' than the local, optional parameter <code>domain</code> of a <em>Log Statement</em>.</p>
<p>The whole list of <em>Scope Domains</em>, together with the parameter <code>domain</code>, which are all concatenated (as long as none of them is an absolute path) results to:</p>
<ol type="1">
<li>[L] <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6a4cc6684df7b4a92b1dec6fce3264fac8">Scope.Global</a></li>
<li>[T] <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6a1ee3f312b05c55202500569aadfc8d9b">Scope.ThreadOuter</a></li>
<li>[L] <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6aac70412e939d72a9234cdebb1af5867b">Scope.Path</a> (PACKAGE)</li>
<li>[L] <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6a1351017ac6423911223bc19a8cb7c653">Scope.Filename</a> (CLASS)</li>
<li>[L] <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6a4c3880bb027f159e801041b1021e88e8">Scope.Method</a></li>
<li>Parameter <code>domain</code> of a <em>Log Statement</em></li>
<li>[T] <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6ae46b159c990fae9e712309bdb4d7b7c4">Scope.ThreadInner</a></li>
</ol>
<p><em>Remark: [L] and [T] here indicate language-related and thread-related <em>Scopes</em>.</em></p>
<h2><a class="anchor" id="alox_man_scopes_thread_outer"></a>
3.1 Use Cases for Scope.ThreadOuter</h2>
<p>An important use case for <em>Scope Domains</em> of <em>Scope.ThreadOuter</em> is useful in single-threaded applications, the same as in multi-threaded. If a <em>Scope Domain</em> is set for <em>Scope.ThreadOuter</em> prior to invoking a method (and removed right after the invocation), all subsequent <em>Log Statements</em> are 'redirected' to the domain path specified, covering the whole call stack of nested method calls. This way, a portion of the program execution can be controlled in respect to the <em>Verbosity</em> of <em>Log Statements</em> easily. You can consider this use as being similar to <em>Scope.Method</em> but lasting not only for the method itself but for all statements of recursively invoked methods as well.</p>
<p>In multi-threaded applications, <em>Scope.ThreadOuter</em> is typically used in situations where the log output of different threads should be separately controlled in respect to the <em>Verbosity</em> of their log output. Imagine a background thread that causes trouble but uses the same code and libraries that the rest of the application does. If you now would increase the <em>Verbosity</em> of such <em>Log Domains</em> where the problems occurred, the log output would be 'cluttered' with a lot of <em>Log Statements</em> caused by any thread of the process. Setting <em>Scope.ThreadOuter</em> allows to 'redirect' all such log-output of the thread in question to a dedicated root domain. Now, controlling the <em>Verbosity</em> of the sub-domains of this thread-specific root domain allows to investigate directly what is happening there. This sample addresses debugging and probably a temporary 'redirect' of domains that is removed when a problem is fixed.</p>
<p>But there are also samples where a permanent setting of a <em>Scope.ThreadOuter</em> makes sense. Most operating systems/programming environments are using a dedicated thread implementing the user interface. Handlers of UI-events like mouse clicks are installed and executed on a per event basis. If now, with the very first UI event firing into the user code, (e.g. signaling that the application is now running, or the main window was created), a <em>Scope Domain</em> like 'UI' is registered with <em>Scope.ThreadOuter</em>, all UI related code magically logs into this domain path. As a consequence, no UI-related code like classes for dialog boxes, menu handlers, etc, need to set such domain themselves (e.g. using <em>Scope.Path</em> in a static constructor). <br />
 Furthermore, it becomes very obvious from just looking at the sub-domains that get created, when the UI thread is tasked with things that rather should be moved to a different thread to avoid blocking the application for too long.</p>
<dl class="section note"><dt>Note</dt><dd>This last sample nicely shows, how the use of ALox for all debug-logging tasks, leads to new insights of a software, that simple "debug log statements" do not provide!</dd></dl>
<h2><a class="anchor" id="alox_man_scopes_thread_inner"></a>
3.2 Use Cases for Scope.ThreadInner</h2>
<p>While technically <em>Scope.ThreadInner</em> is very similar to <em>Scope.ThreadOuter</em>, the effect and use cases still differs slightly. Instead of 'redirecting' just all log output of a thread into a new sub-tree of <em>Log Domains</em>, <em>Scope.ThreadInner</em> splits all 'leafs' of the overall Log Domain tree by adding a thread-dependent <em>Log Domain</em> to those leafs.</p>
<p>When we think about this for a minute, the obvious use case is to filter the log output of specific Sub-<em>Log Domains</em> by thread. First, when a <em>Scope Domain</em> of <em>Scope.ThreadInner</em> is set, the <em>Verbosity</em> of the new sub-domains will not change. This is true, because all new domains that are created by this thread are sub-domains of those <em>Log Domains</em> used before. And such sub-domains just inherit the setting as long as they are not controlled explicitly (as explained in <a class="el" href="alox_man_logdomains.html#alox_man_logdomains_recursive">6.2 Why Does Verbosity Setting Always Work Recursively?</a>). From here, specifically for this thread, the <em>Verbosity</em> of certain domains can now be tweaked until the right set of <em>Log Statements</em> appear.</p>
<p>Imagine a very general class providing a very general feature, hence frequently used by different parts of a software. Increasing the <em>Verbosity</em> of a <em>Log Domains</em> of such class might increase the overall log output too much. Now, by splitting such <em>Log Domains</em> using a <em>Scope Domain</em> for <em>Scope.ThreadInner</em> it becomes possible to either decrease the <em>Verbosity</em> for threads that are not of current interest or by only increasing the <em>Verbosity</em> of the thread of interest.</p>
<p>Finally it is noteworthy to mention the impact of <em>Scope.ThreadInner</em> being the most inner <em>Scope Domain</em> that is evaluated:</p><ol type="1">
<li>A <em>Log Statement</em> that provides an absolute domain path directly in its statement using optional parameter <code>domain</code>, can still be split by <em>Scope Domains</em> of <em>Scope.ThreadInner</em>.</li>
<li>If an absolute domain path is provided for a <em>Scope Domain</em> of <em>Scope.ThreadInner</em>, then this 'flattens' all log output into exactly this single domain. (Even parameter <code>domain</code> of a <em>Log Statement</em> will not be used!)</li>
</ol>
<h2><a class="anchor" id="alox_man_scopes_thread_multiple"></a>
3.3 Multiple Use of Thread-Related Scopes</h2>
<p>We learned in section <a class="el" href="alox_man_scopes.html#alox_man_scopes_language_path">2.2 Scope.Path (In Java Scope.PACKAGE)</a>, that this <em>Scope</em> through the use of optional parameter <code>pathLevel</code> of method <b>Lox.SetDomain</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a230b89005c93ffdbfe0dd689d7eb0f11">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a61e2df18f576ca8184ea5d4e21148bc4">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#afd6a91bb2c6eaee017b0ccbd4cccd447">Java</a>) may be seen as whole set of nested <em>Scopes</em> itself.</p>
<p>The same is true for <em>Scope.ThreadOuter</em> and <em>Scope.ThreadInner!</em> If multiple <em>Scope Domains</em> are set for one of both <em>Scopes</em>, instead of overwriting the previous setting (as done with language-related scopes), such <em>Scope Domains</em> are added to the ones that were previously set.<br />
 This is important for almost all use cases described in the previous sections.</p>
<p>Hereby, subsequent settings are 'inner' <em>Scopes</em> of the previous ones. This means, that during program execution the first <em>Scope Domain</em> that is set, results in a higher level within the domain tree. Subsequent <em>Scope Domains</em> set result in direct sub-domains of the former ones.<br />
 ALox, when passing a nulled string with parameter <code>scopeDomain</code> of method <b>Lox.SetDomain</b> removes the most recently set <em>Scope Domain</em> first. But also an out-of-order removal of thread-related <em>Scopes</em> is possible. More details on setting and removing <em>Scope Domains</em> for thread-related <em>Scopes</em> is given in the next section.</p>
<h2><a class="anchor" id="alox_man_scopes_thread_setting"></a>
3.4 How To Set Scope Domains for Thread-Related Scopes</h2>
<p>The same method, <b>Lox.SetDomain</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a230b89005c93ffdbfe0dd689d7eb0f11">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a61e2df18f576ca8184ea5d4e21148bc4">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#afd6a91bb2c6eaee017b0ccbd4cccd447">Java</a>) which is used for language-related <em>Scopes</em> is used to set and remove thread-related <em>Scopes</em>.</p>
<p>If a domain path is given with parameter <code>scopeDomain</code> and either <em>Scope.ThreadOuter</em> or <em>Scope.ThreadInner</em> for parameter <code>scope</code>, then this domain path is added to the list of corresponding domains set. The list reflects a set of nested <em>Scopes</em> for itself.</p>
<p>To remove the most recently added <em>Scope Domain</em>, it is sufficient to do the same call, with an empty or nulled parameter <code>scopeDomain</code>. Again, this is the same as with removing or 'un-setting' <em>Scope Domains</em> of other <em>Scope</em> types.</p>
<p>For the case that the reverse order of adding and removing thread-related <em>Scope Domains</em> can not be guaranteed, class <b>Lox</b> offers method <b>Lox.RemoveThreadDomain</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#adb89a8f794afb0b6551fe45499dea973">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a3df59d5b962fac68a8c0c93c9796c933">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#a0986c7bfe43e066b677489830a6c9af0">Java</a>) which accepts the domain path to be removed explicitly as a parameter.</p>
<p>It was discussed in <a class="el" href="alox_man_scopes.html#alox_man_scopes_language_setting">2.6 How To Set Scope Domains for Language-Related Scopes</a>, that those types of <em>Scopes</em> can only be set from 'within' the <em>Scope</em> to be set (the same or an inner <em>Scope</em>). This is different with thread-related <em>Scopes</em>. Method <b>Lox.SetDomain</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a230b89005c93ffdbfe0dd689d7eb0f11">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a61e2df18f576ca8184ea5d4e21148bc4">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#afd6a91bb2c6eaee017b0ccbd4cccd447">Java</a>) as well as <b>Lox.RemoveThreadDomain</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#adb89a8f794afb0b6551fe45499dea973">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a3df59d5b962fac68a8c0c93c9796c933">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#a0986c7bfe43e066b677489830a6c9af0">Java</a>) accept an optional parameter <code>thread</code> which allows to explicitly provide the thread object to associate a thread-related <em>Scope Domain</em> to. Of-course, if this parameter is omitted, the 'actual <em>Scope'</em>, hence the current thread, is used.</p>
<dl class="section note"><dt>Note</dt><dd>In C++, ALib (the <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lib.html">utility library</a> that ALox is based on) provides class <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lib_1_1threads_1_1Thread.html">aworx::Thread</a>, which is mimicking the basic interface of corresponding classes found in the standard class libraries of C# and Java. Usually, a software using ALox would use a different library to create threads. As long as such library is creating 'native' threads of the underlying operating system, this is no issue. To refer to a thread created with a different library, the approach is as follows:<ul>
<li>from within the thread that is created, ALib method <b>Threads::CurrentThread</b> <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lib_1_1threads_1_1Threads.html#afbdb4b0df9aaf36f3ab6c4965178f0d6">(C++)</a> has to be invoked on library singleton <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lib.html#a2e2672eedb93d516b1696f3e692e40a2">aworx::lib::THREADS</a>.</li>
<li>The pointer to the <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lib_1_1threads_1_1Thread.html">aworx::Thread</a> object received has to be passed to the scope of the method that is supposed to set a thread-related <em>Scope</em> value for referencing the thread in question.</li>
</ul>
</dd></dl>
<p>When things get more complicated, same as with language related scopes, a snapshot of all current settings can be logged using <b>Lox.State</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a8396987d83aaa22cb36dad2d9d2254dd">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a801d9784fa14e309a1889fd0afb09a36">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#ad0811a76c83beede4960c95ab5ca6630">Java</a>) to investigate which settings have been performed.</p>
<p>Alternatively, if the snapshot is not enough to understand what is set, removed and used where, a live log of ALox' internal messages can be activated to identify exactly what the code is doing in respect to <em>Scope Domains</em>. See <a class="el" href="alox_man_internal_domains.html">11 - Internal Logging</a> for more information about how to enable internal log messages.</p>
<h1><a class="anchor" id="alox_man_scopes_wrapup"></a>
4. Wrap up</h1>
<p>We want to summarize the takeaways of this chapter:</p>
<ul>
<li><em>Scopes</em> are used for different features of ALox, as documented in <a class="el" href="alox_man_logdomains.html">04 - Log Domains</a>, <a class="el" href="alox_man_log_once.html">06 - Lox.Once()</a>, <a class="el" href="alox_man_prefix_logables.html">07 - Prefix Logables</a> and <a class="el" href="alox_man_log_data.html">08 - Log Data (Debug Variables)</a>.</li>
<li>Most of the samples and explanations in this chapter are related to <em>Scope Domains</em>.</li>
<li><em>Scopes</em> are nested, we have inner and outer <em>Scopes</em>.</li>
<li>Four (programming-)language-related <em>Scopes</em> were introduced. They work similar to scopes of the programming languages.</li>
<li>Two thread-related <em>Scopes</em> were introduced. They are runtime <em>Scopes</em> and associated with the thread executing a <em>Log Statement</em>.</li>
<li>The two thread-related <em>Scopes</em> differ only in the 'position' within the hierarchy of <em>Scopes</em>.</li>
<li>It was explained, that language-related <em>Scopes</em> are set exclusively by statements that are placed within the according <em>Scope</em> itself...</li>
<li>...while thread-related <em>Scopes</em> can also be set from within other threads, by providing the associated object of type Thread explicitly.</li>
<li>Repetitive settings of language-related <em>Scopes</em> are overwriting previous settings.</li>
<li>Repetitive settings of <em>thread-related</em> <em>Scopes</em> are each acting as a nested, inner scope of the previous setting.</li>
<li>Removing <em>Scope Domains</em> is performed by passing a nulled or empty domain path to method <b><a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a230b89005c93ffdbfe0dd689d7eb0f11">Lox.SetDomain</a></b>. In the case of thread-related <em>Scopes</em> this removes the most recently added <em>Scope Domains</em>. Therefore, if out-of-order removals are needed, method <b><a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#adb89a8f794afb0b6551fe45499dea973">Lox.RemoveThreadDomain</a></b> is to be used for removal.</li>
<li>To investigate into settings of a <b>Lox</b>, two options exist. Either by creating a snapshot of the current setting (using method <b><a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a8396987d83aaa22cb36dad2d9d2254dd">Lox.State</a></b>) or by activating internal log messages and observing which setting is made at which position in the source code and which point in time when running a process.</li>
</ul>
<p>Finally we want to express an important thought: The three concepts of ALox, namely</p><ol type="1">
<li>Hierarchically organized <em>Log Domains</em>,</li>
<li>Nested <em>Scopes</em> and</li>
<li><em>Scope Domains</em>,</li>
</ol>
<p>align very nicely. Clever use of them may lead to true "emergence": Suddenly, log output provides more information than the single <em>Log Statements</em>' messages itself. (Similar to water, which has different "emerged" properties than the pure sum of the properties of each of its molecules.)</p>
<p>But, it should not be forgotten what the main purpose of <em>Log Domains</em> is: It is the control of the <em>Verbosity</em> of subsets of <em>Log Statements</em>. In other words, the main purpose of <em>Log Domains</em> is not to understand and analyze the calling hierarchy (call stack) of a piece of code. While ALox may be used to help here quite nicely, there are other software tools and techniques available for accomplishing this.<br />
 Therefore our recommendation is: <b>Do not overuse the concept of <em>Scope Domains</em></b>. With too many <em>Scope Domains</em> set, the original purpose of <em>Log Domains</em> may become harder to achieve. Already the maintenance of <em>Verbosities</em> may start causing some unwanted effort.</p>
<hr/>
 <center>Next chapter: <a class="el" href="alox_man_log_once.html">06 - Lox.Once()</a> </center> <center> <a class="el" href="manual.html">Back to index</a> </center> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 22 2017 22:23:19 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<!-- Start of StatCounter Code e -->
<script type="text/javascript">
var sc_project=11242602;
var sc_invisible=1;
var sc_security="5ac13373";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web statistics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11242602/0/5ac13373/1/" alt="web
statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
