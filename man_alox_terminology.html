<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALox: 03 - Terminology and Key Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1702 R. 1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--ALox Main Menu-->
<div style="background: #2f3a48; " >
<table  class="aworx-menutable"  >
 <tbody>
 <tr style="height: 36px;">
  <td> <a class="aworx-menu_hl" href="index.html"                  >Home</a>                        </td>
  <td> <a class="aworx-menu"    href="cpp_ref/cppmainpage.html"    >ALox for C++</a>                </td>
  <td> <a class="aworx-menu"    href="cs_ref/csmainpage.html"      >ALox for C#</a>                 </td>
  <td> <a class="aworx-menu"    href="java_ref/javamainpage.html"  >ALox for Java</a>               </td>
  <td> <a class="aworx-menu"    href="https://github.com/AlexWorx/ALox-Logging-Library">Download</a></td>
 </tr>
 </tbody>
</table>
</div>
<!--end ALox Main Menu-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">03 - Terminology and Key Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#man_alox_tak_terminology">1. Terminology</a><ul><li class="level2"><a href="#man_alox_tak_terminology_logger">1.1 Loggers</a></li>
<li class="level2"><a href="#man_alox_tak_terminology_logables">1.2. Logables</a></li>
<li class="level2"><a href="#man_alox_tak_terminology_statements">1.3. Log Statements</a></li>
<li class="level2"><a href="#man_alox_tak_terminology_domains">1.4. Log Domains</a></li>
<li class="level2"><a href="#man_alox_terminology_verbosity">1.5. Verbosity</a></li>
<li class="level2"><a href="#man_alox_terminology_scopes">1.6. Scopes</a></li>
<li class="level2"><a href="#man_alox_terminology_scopedomains">1.7. Scope Domains</a></li>
<li class="level2"><a href="#man_alox_terminology_logdomaintree">1.8. Tree of Log Domains and Domain Path</a></li>
</ul>
</li>
<li class="level1"><a href="#man_alox_tak_lox">2. Class Lox - Managing it all</a><ul><li class="level2"><a href="#man_alox_tak_lox_prefixlogables">2.1 Prefix Logables</a></li>
<li class="level2"><a href="#man_alox_tak_lox_logonce">2.2 Log Once</a></li>
<li class="level2"><a href="#man_alox_tak_lox_logdata">2.2 Log Data</a></li>
</ul>
</li>
<li class="level1"><a href="#man_alox_tak_multiple_loxes">3. Using Multiple Lox Instances</a><ul><li class="level2"><a href="#man_alox_tak_multiple_loxes_dbg_rel_log">3.1 A Dedicated Lox Singleton for Debug Logging</a></li>
<li class="level2"><a href="#man_alox_tak_multiple_loxes_missioncritical">3.2 Separating Mission Critical Log statements</a></li>
<li class="level2"><a href="#man_alox_tak_multiple_logger_registration">3.3 Multiple Registration of a Logger</a></li>
</ul>
</li>
<li class="level1"><a href="#man_alox_tak_lox_registration">4. Class ALox and Registration of Lox Instances</a></li>
</ul>
</div>
<div class="textblock"><p>This chapter introduces to the major concepts of <b>ALox</b>.</p>
<p>Before we explain those, we want to start with defining terms used by this manual and by the <b>reference documentation</b> (<a href="cpp_ref/cppmainpage.html">C++</a>, <a href="cs_ref/csmainpage.html">C#</a>, <a href="java_ref/javamainpage.html">Java</a>).</p>
<h1><a class="anchor" id="man_alox_tak_terminology"></a>
1. Terminology</h1>
<h2><a class="anchor" id="man_alox_tak_terminology_logger"></a>
1.1 Loggers</h2>
<p>ALox is designed to support different log streams. A log stream is a destination of log messages and can be the IDE console, the terminal console, a file, a web service or anything that accepts data streams. Abstract class <b>Logger</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1core_1_1Logger.html">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1core_1_1Logger.html">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1core_1_1Logger.html">Java</a>) represents such a log stream. While some implementations of class <b>Logger</b> are provided with the <b>ALox</b> package, the system allows custom implementations of <em>Loggers</em> that log information to any 'data drain' in any format you like.</p>
<p>When using <b>ALox</b>, there is not much interaction with classes of type <em>Logger</em>, though. The reason for this is, that the data that is logged, should optionally be directed into multiple <em>Loggers</em> at once. Therefore, the API interface for executing the logging itself, is residing somewhere else and internally, <b>ALox</b> dispatches the log data to the list of <em>Loggers</em> in question.</p>
<p>The interaction with a class <b>Logger</b> (and its derived types) is therefore limited to the following:</p><ul>
<li>Creation of a <em>Logger</em> </li>
<li>Optional configuration of a <em>Logger</em> (e.g. details on the output format, etc.)</li>
<li>Registration of the <em>Logger</em> with <b>ALox</b>.</li>
</ul>
<h2><a class="anchor" id="man_alox_tak_terminology_logables"></a>
1.2. Logables</h2>
<p>What can be described as "the data that is logged", is called a <b>'Logable'</b> or, as it may be more than one, <em>the Logables</em> in <b>ALox</b>. While most logging APIs are restricted to logging text messages, <b>ALox</b> is not. Still, the usual case is logging text messages, but the architecture of <b>ALox</b> allows to log an arbitrary amount of objects of arbitrary type.</p>
<p>For technical reasons, the interfaces to pass the <em>Logables</em> to <b>ALox</b> are slightly different in the different language versions:</p>
<ul>
<li><b>ALox for Java</b>:<br />
 Here, parameters of <em>Logables</em> are of type <code>Object</code>. <em>Loggers</em> that process such object are using runtime-type information capabilities of Java (e.g keyword <code>instanceof</code>) to interpret what was dispatched to them as a <em>Logable</em>.<br />
 Many methods use variadic arguments (ellipsis syntax, <code>'</code>...') to be able to accept an arbitrary amount of <em>Logables</em>. In some cases this is not possible (e.g. due to overloaded methods and ambiguities with those), only one <em>Logable</em> of type <code>Object</code> is accepted. In this case, the object passed may be of type <code>Object</code>[] which is then internally "flattened" into a list of <em>Logables</em> as if each object of the list was passed.</li>
<li><b>ALox for C#</b>:<br />
 Similar to Java, in C#, parameters accepting <em>Logables</em> are of type <code>Object</code>. However, in C# it is not possible to use variadic arguments (ellipsis syntax, <code>'</code>...') to allow an arbitrary amount of logables. The reason is that most interface methods have "hidden" parameters that are filled automatically by the compiler with caller information (the actual source code, method name and line number). Therefore, the number of parameters that denote the <b>Logables</b> is limited to four.<br />
 The good news is, that any of these four parameters may be of type <code>Object</code>[]. Arrays are "flattened" internally and added to the list of <em>Logables</em>. With this "trick", <b>ALox for C#</b> manages to provide a simple interface, where only in the case that more than four logables are to be passed those have to be placed in an array. Such placement is usually done "inline", right within the invocation parameter list.</li>
<li><p class="startli"><b>ALox for C++</b>:<br />
 For C++, the situation is slightly different due to the fact that this language (for good reasons) does not support "runtime type information" and no unique parent class <code>Object</code> exists that is the natural origin of all classes. Nevertheless, the logging interface provides the same seamless and natural way of passing any type of argument as provided in the other language implementations!</p>
<p class="startli">This is reached by using <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a>. This (underlying) library uses <a href="https://en.wikipedia.org/wiki/Template_metaprogramming">template meta programming</a> to automatically wrap whatever a user passes as an argument into an object of type <b>Box</b> (e.g. <code>char</code>, <code>int</code>, <code>double</code> or pointers, values, references to and even arrays of objects of any type). Once a parameter is boxed, it can be passed further (in our case to the <em>Loggers</em>) and then processed in a type-safe way. Besides the ability of getting type information from the "boxes" and to "unbox" their values, <b>ALib Boxing</b> allows to define and invoke some sort of "virtual interface methods" on boxed values. And all this can be done on arbitrary types, without modifying (preparing) the types for that.</p>
<p class="startli">In short, <b>ALib Boxing</b> allows a user of <b>ALox</b> to pass just any type of objects to the logging system without prior conversion. Also it is irrelevant if pointers or references are passed, just anything may be "thrown in"! An <b>ALox</b> user does not need to know how this works, it is all hidden behind the scenes. Only for very advanced use, the knowledge of the <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lib_1_1boxing.html">details of ALib Boxing</a> may become relevant.</p>
</li>
</ul>
<p>In the case of textual logging (the standard case, including 'simple' debug logging), all <em>Logables</em> are processed by instances of derived types of class <b>Formatter</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx.html#a8a886b94242bc07b7074667aa0a8f0dd">C++</a>, <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx.html#a8a886b94242bc07b7074667aa0a8f0dd">C#</a>, <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx.html#a8a886b94242bc07b7074667aa0a8f0dd">Java</a>). This abstract class is defined in underlying library <b>ALib</b>. This is why <b>ALox</b> logging optionally allows to pass format strings which include placeholders and formatting options, like field width, alignment, tabulators, quotes, and much more. If no format string is detected, string representations of the <em>Logables</em> will be just concatenated and logged. This way, formatting the output is just an option.</p>
<p>And the flexibility goes even beyond that: By default, <b>two</b> built-in incarnations of this class are used: <b>FormatterPythonStyle</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx.html#aaa224c25fc78d8c161dda09c9500a3d1">C++</a>, <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx.html#aaa224c25fc78d8c161dda09c9500a3d1">C#</a>, <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx.html#aaa224c25fc78d8c161dda09c9500a3d1">Java</a>) and <b>FormatterJavaStyle</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx.html#af92291820cffb4092194bf724723f943">C++</a>, <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx.html#af92291820cffb4092194bf724723f943">C#</a>, <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx.html#af92291820cffb4092194bf724723f943">Java</a>). The two types are used in parallel! This means, that the already optional and auto-detected format strings may follow either the <a href="https://docs.python.org/3.5/library/string.html#format-string-syntax">Python String Fromat Syntax</a>, which is also similar to what C# offers, or the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html">formatting standards of the Java language</a>, which in turn are a little like good old <code>printf</code>, but of-course much more powerful and also type-safe.</p>
<p>It can be concluded that <b>ALox</b> logs just anything a user passes to it as <em>Logables:</em> Textual or binary data and if textual, optionally accepting auto-detected formatting strings of different syntactical type!</p>
<h2><a class="anchor" id="man_alox_tak_terminology_statements"></a>
1.3. Log Statements</h2>
<p>When this manual and the reference documentation of <b>ALox</b> are referring to a <b>'Log Statement'</b>, this means a piece of (user) code that invokes an ALox interface method that potentially performs log output.</p>
<p>Of-course, each <em>Log Statement</em> incorporates the provision of one or more <em>Logables</em> to <b>ALox</b>. Hence, those interface methods of the <b>ALox</b> API that carry a parameter named <code>'logable'</code> (or a list of those, named <code>'logables'</code>) can easily be identified as methods that comprise <em>Log Statement</em>.</p>
<h2><a class="anchor" id="man_alox_tak_terminology_domains"></a>
1.4. Log Domains</h2>
<p>The term <b>'Log Domain'</b> in <b>ALox</b> denotes a sort of 'key' that is used to group <em>Log Statements</em> into different sets. Each <em>Log Statement</em> belongs to exactly one specific set of <em>Log Statements</em> by having a <em>Log Domain</em> associated.</p>
<p>Such association can be made by using an <b>optional</b> parameter named <code>'domain'</code> which is available in each interface method of the ALox API which comprises a <em>Log Statement</em>.</p>
<dl class="section note"><dt>Note</dt><dd>To be precise: There are no such things as 'optional parameters' in Java and also in C# and C++ parameters that are followed by non-optional parameters can not have a default value in a methods declaration and therefore can not be 'optional' in the sense of the language definition. Therefore, when we talk about 'optional parameters', this means that an alternative, overloaded method with the same name exists, but excluding this parameter from the list.</dd>
<dd>
Furthermore, important <em>Log Statements</em> do not have an explicit <code>domain</code> parameter. Instead <b>ALox</b> uses a mechanism to auto-detect <em>Log Domains</em> at the first position in the the list of parameters that otherwise are the <em>Logables</em> of the statement. This is done to further ease the use of log statements.</dd></dl>
<p>A typical sample for a <em>Log Domain</em> might using name <code>"UI"</code> with all <em>Log Statements</em> that concern the user interface of an application. A developer may switch <em>Log Statements</em> of <em>Log Domain</em> <code>"UI"</code> completely off in the moment he/she is not interested in UI development. Alternatively, warning and error messages might get allowed. Later, when working on UI related code again, that <em>Log Domain</em> may be re-enabled. If a team of developers is working on a project, each team member may configure ALox to enable those <em>Log Domains</em> that he/she is currently working on.</p>
<p>Although parameter <code>domain</code> is optional, still each <em>Log Statement</em> is associated with a <em>Log Domain</em>. The way how <b>ALox</b> 'magically' associates <em>Log Statements</em> with 'the right' <em>Log Domain</em>, without the need for the user to be explicit about it, is one of the features that makes <b>ALox</b> quite unique. More about this will be explained in later chapters of this manual.</p>
<h2><a class="anchor" id="man_alox_terminology_verbosity"></a>
1.5. Verbosity</h2>
<p>It is very common for logging eco-systems, to implement the concept of 'verbosity levels', and <b>ALox</b> is no exclamation to this. First of all, the term <b>Verbosity</b> denotes an attribute of <em>Log Statements</em>. The values of this attribute are defined in enum class <b>Verbosity</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#abf3be10d03894afb391f3a2935e3b313">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/namespacecs_1_1aworx_1_1lox.html#abf3be10d03894afb391f3a2935e3b313">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/enumcom_1_1aworx_1_1lox_1_1Verbosity.html">Java</a>)</p>
<p>Some of the interface methods that comprise <em>Log Statements</em> carry the <em>Verbosity</em> in their method name, e.g. <code>warning</code>() or <code>verbose</code>(). Other, specialized methods offer a parameter named <code>verbosity</code> of type <b>Verbosity</b>.</p>
<p>Besides <em>Log Statements</em>, <em>Verbosity</em> is also an attribute of <em>Log Domains</em>. As every <em>Log Statement</em> has a <em>Log Domain</em> and a <em>Verbosity</em> associated with it, <b>ALox</b> is able to match both values against each other to decide whether a <em>Log Statement</em> is executed or not.</p>
<p>When you think about this for a second, what is gained by this concept becomes obvious: The overall verbosity of the log output is not controlled globally but on a 'per <em>Log Domain</em> basis'. This allows to just switch the topic that an application is logging about. When interested in user interface things, a <em>Log Domain</em> called <code>"UI"</code> might be set to a 'more verbose' level, while other <em>Log Domains</em> are switched off or are reduced to real error messages.</p>
<p>As described later in this manual, the possibilities of <b>ALox</b> to filter the log output are even more granular and flexible.</p>
<h2><a class="anchor" id="man_alox_terminology_scopes"></a>
1.6. Scopes</h2>
<p>The <b>'Scope'</b> is a next attribute any <em>Log Statement</em> possesses. The different types of scopes are nested into each other and some of the possible values are similar to what the programming languages that ALox is written in provide. For example <em>Scope.Method</em> is similar to what a variable that is defined in a method has as a scope from a language perspective: it is visible only in exactly this method. But still, in <b>ALox</b>, <em>Scopes</em> are different and the main reason is that <b>ALox</b> is not able to detect scopes in the same way as a compiler of a programming language is. Therefore, we are talking about <b>language related scopes</b>. In C++ and C# those are:</p>
<ul>
<li><em>Scope.Path</em> <br />
 The file path that a source file which contains the <em>Log Statement</em> in question is located in. As this can be also parent directories, this <em>Scope</em> type represents in fact on its own already a nested set of scopes!</li>
<li><em>Scope.Filename</em> <br />
 The name of the source file in which a <em>Log Statement</em> is located in</li>
<li><em>Scope.Method</em> <br />
 The name of a class method (in C++ also 'global' function names are detected) that a <em>Log Statement</em> is located in.</li>
</ul>
<p>In Java, they are slightly different and named 'Package', 'Class' and 'Method'.</p>
<p>Besides these <em>language-related Scopes</em>, <b>ALox</b> in addition defines <em>thread-related Scopes</em>. Those are relating to the thread that is executing a <em>Log Statement</em>. There are two of them, one defined as an 'outer' <em>Scope</em> of the language-related set of <em>Scopes</em>, the other is an 'inner' <em>Scope</em> of those.</p>
<p>All information about this topic is found in chapter <a class="el" href="man_scopes.html">05 - Scopes in ALox</a>. The corresponding enum type in the reference documentation is <b>Scope</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/namespacecs_1_1aworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/enumcom_1_1aworx_1_1lox_1_1Scope.html">Java</a>).</p>
<h2><a class="anchor" id="man_alox_terminology_scopedomains"></a>
1.7. Scope Domains</h2>
<p>Attention: now it becomes tricky! Each <em>Log Statement</em> belongs to a <em>Scope</em>, precisely, even to a set of nested <em>Scope</em> values. The grouping of the statements into <em>Scopes</em> is done automatically by <b>ALox</b>. The <em>Scope</em> is detected from the position of the <em>Log Statement</em> within the source code and from the thread that is executing it. Now, a <b>Scope Domain</b> is a default domain set by the user of ALox for a specific <em>Scope</em>. Once such default value is set, ALox uses this domain for each <em>Log Statement</em> located within that <em>Scope</em>. This way, <em>Log Statements</em> get their <em>Log Domain</em> associated 'automatically'.</p>
<p>As a sample, a <em>Scope Domain</em> <code>"DB"</code> could be set as the default <em>Log Domain</em> for <em>Scope.Filename</em> (In ALox for Java: <em>Scope.CLASS</em>) that contains code that stores and retrieves data from a database management system. Now, all <em>Log Statement</em> within this source file (class) get this <em>Log Domain</em> automatically associated, without explicitly specifying <code>"DB"</code> with every <em>Log Statement</em>. Therefore - although each <em>Log Statement</em> needs to refer to a <em>Log Domain</em> - such domain is not needed to be added to each statement into the source code. This has several advantages: less typing, less code clutter by <em>Log Statements</em>, copied <em>Log Statements</em> magically switch their domain when 'pasted' into a different scope, and so forth.</p>
<p>As you see, there are two ways to assign a <em>Scope Domain</em> to a <em>Log Statement</em>: Either by providing optional parameter <code>domain</code> with a <em>Log Statement</em>, or by setting a <em>Scope Domain</em> and omitting the parameter.</p>
<h2><a class="anchor" id="man_alox_terminology_logdomaintree"></a>
1.8. Tree of Log Domains and Domain Path</h2>
<p>By having <em>Scope Domains</em> which associate a 'default domain' with a <em>Log Statement</em> that resides in a certain <em>Scope</em> and knowing that the <em>Scopes</em> are nested into each other, the question is what happens if multiple <em>Scope Domains</em> apply to the same <em>Log Statement</em>? Or, a similar question: what happens if a <em>Scope Domain</em> is set for a <em>Scope</em> that a <em>Log Statement</em> resides in and in addition, the <em>Log Statement</em> uses optional parameter <code>domain</code> to explicitly specify a <em>Log Domain</em>?</p>
<p>The answer is: ALox concatenates all <em>Scope Domain</em> to a <b>Domain Path</b>, separated by character <code> '/'</code>. This means that ALox organizes <em>Log Domains</em> hierarchically, hence this can be seen as a <b>tree of Log Domains</b>. The concatenation starts from the most 'outer' <em>Scope</em> and ends at the most 'inner'. The value of optional parameter <code>domain</code> is appended close to the end - but not completely at the end.</p>
<p>Besides 'mixing' <em>Scope Domains</em> and parameter <code>domain</code>, <b>ALox</b> also allows to 'overwrite' <em>Scope Domains</em> with parameter <code>domain</code>.</p>
<p>Using the techniques in the right manner, is one of the keys to efficiently use <b>ALox</b>. The details of how this is done is explained in a dedicated chapter: <a class="el" href="man_logdomains.html">04 - Log Domains</a>.</p>
<h1><a class="anchor" id="man_alox_tak_lox"></a>
2. Class Lox - Managing it all</h1>
<p>The definitions and terminology that were introduced in this chapter so far should be quickly summarized. We have:</p>
<ul>
<li><b>Loggers and Logables:</b><br />
 <em>Loggers</em> are responsible for writing the contents of <em>Logables</em> to dedicated output 'drains' like the console, a text file or a remote server. Multiple <em>Loggers</em> might exist even in quite simple applications.</li>
<li><b>Log Statements and associated attributes:</b><br />
 A <em>Log Statement</em> is the user code that invokes the interface API of ALox and pass a <em>Logable</em>, e.g. a text message to ALox. Each <em>Log Statement</em> has three attributes besides the <em>Logable:</em> <ol type="1">
<li>A <em>Verbosity</em>, defining the 'importance' or 'severeness' of the statement.</li>
<li>A <em>Log Domain</em> that makes the <em>Log Statement</em> belong to a certain set of <em>Log Statements</em>. <em>Log Domains</em> can be considered to specify the 'topic' that a <em>Log Statement</em> is 'talking' about.</li>
<li>A <em>Scope</em>, which gives a different, automatic way of grouping <em>Log Statements</em>.</li>
</ol>
</li>
<li><b>Scope Domains:</b> Those are acting as 'default domains' and are collected and concatenated by ALox to form, together with parameter <code>domain</code> of a <em>Log Statement</em>, a 'domain path' identifying the resulting, final <em>Log Domain</em> of a <em>Log Statement</em>.</li>
</ul>
<p>Now, the most prominent class of ALox which acts almost like a "single point of contact" comes into the game: Class <b>Lox</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html">Java</a>).</p>
<p>This class keeps it all together! This is what class <b>Lox</b> does:</p>
<ul>
<li>It provides the most important parts of the ALox API, especially those interface methods that comprise <em>Log Statements</em>.</li>
<li>It manages a set of <em>Loggers</em> which write the <em>Logables</em> of <em>Log Statements</em>.</li>
<li>It maintains a tree of hierarchically organized <em>Log Domains</em>.</li>
<li>It stores a <em>Verbosity</em> value for <em>Log Domains</em>, which is the counter-value of a <em>Log Statements</em>' <em>Verbosity</em> and determines if a <em>Log Statement</em> is executed or not. This is done on a per-<em>Logger</em> basis.</li>
<li>It automatically determines the <em>Scope</em> of a <em>Log Statement</em> and manages the associated nested <em>Scope Domains</em>.</li>
<li>It provides other nice features related to <em>Scopes</em>, like <a class="el" href="man_log_once.html">06 - Lox.Once()</a>, <a class="el" href="man_prefix_logables.html">07 - Prefix Logables</a> or <a class="el" href="man_log_data.html">08 - Log Data (Debug Variables)</a></li>
<li>It collects some meta information like timestamps or counters.</li>
<li>It provides a dictionary to translate thread IDs in human readable (logable) thread names.</li>
</ul>
<p>It becomes clear that this class is an <b>ALox</b> users' main interface into logging. After <b>ALox</b> was set-up once (probably in the bootstrap section of a software), and <em>Loggers</em> are created, configured and attached to a <b>Lox</b>, this class is almost all that is needed across all other parts of a software. All main <b>ALox</b> functionality, especially the interface for the logging statements themselves is comprised in this class.</p>
<p>One important detail of the internal management of class <b>Lox</b> is the fact that it associates a separated <em>Verbosity</em> value for each combination of <em>Log Domain</em> and <em>Logger</em>.<br />
 The rational behind that is easy to understand: An application that supports different <em>Loggers</em> at once (which happens quite quickly when using <b>ALox</b>), might want to log different subsets of the log messages with a different <em>Verbosity</em> to each of theses <em>Loggers</em>. For example, a <em>Logger</em> dedicated for debug-logging that streams into an output window of an IDE, would be desired to be generally more verbose and also switch <em>Verbosity</em> more frequently, than a <em>Logger</em> that in parallel logs into a file which is storing also logs of earlier debug sessions.</p>
<h2><a class="anchor" id="man_alox_tak_lox_prefixlogables"></a>
2.1 Prefix Logables</h2>
<p>While those interface methods in class <b>Lox</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html">Java</a>) which comprise a <em>Log Statement</em> already accept an arbitrary amount of <em>Logables</em> as parameters, this list can even be extended by further objects which are then all together passed to method <b>Logger.Log</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1core_1_1Logger.html#aad1169d160da5e3443144dca9a2c2e05">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1core_1_1Logger.html#a190bb68f9aa44fb53725398e6663549e">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1core_1_1Logger.html#afb6fb454e24c653a10c6966754960298">Java</a>) of each <em>Logger</em> attached.</p>
<p>Such additional objects are called <b>Prefix Logables</b>. In short, <b>ALox</b> allows to associate <em>Logables</em> to <em>Scopes</em>. This way, all <em>Log Statements</em> 'collect' such <em>Prefix Logables</em> which were defined to any of the nested <em>Scopes</em> in a list and passes them to the <em>Logger</em>. We could have named them <em>Scope Logables</em> or <em>Context Logables</em>, however, the word 'prefix' makes perfect sense with the most important type of <em>Logables</em>, namely strings! With logging text messages, <em>Prefix Logables</em> act like a prefix to a log message. All about this topic is found in chapter <a class="el" href="man_prefix_logables.html">07 - Prefix Logables</a>.</p>
<h2><a class="anchor" id="man_alox_tak_lox_logonce"></a>
2.2 Log Once</h2>
<p>Another feature of <b>ALox</b> which leverages the concept of <em>Scopes</em>, is found with overloaded methods <b>Lox.Once</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a6461dec7c62cad4cb618ac730bac95a9">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#adf12d740a5c327f144757d7893af1374">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#a7347b1bdc9a7abe966bd812190f54db8">Java</a>).</p>
<p>They are really 'heavily' overloaded, therefore the most simple version just accepts a <em>Logable</em>. With this version <b>ALox</b> hides the use of <em>Scopes</em> and offers what you would expect from the methods' name: logging a statement only the first time it is executed. The different parameters allow to cover more complex uses cases than this. All about this <em>Log Statement</em> is found in chapter <a class="el" href="man_log_once.html">06 - Lox.Once()</a>.</p>
<h2><a class="anchor" id="man_alox_tak_lox_logdata"></a>
2.2 Log Data</h2>
<p>As being able to 'prune' <b>ALox</b> debug-<em>Log Statements</em> from release code, a low hanging fruit for the <b>ALox</b> feature list is to offer a concept for storing and using data, that otherwise would be temporary debug variables during the development process. Again, <b>ALox</b> <em>Scopes</em> are leveraged which makes the otherwise simple methods <b>Lox.Store</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#ae426500da56a1be2efa28dc5917234fd">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#ad9d88319a84c07a458aa29eccef29cfb">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#a5c0889cc7e10b5436d6988e9c7e1b4b7">Java</a>) and <b>Lox.Retrieve</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a363a3a48f4296a1adff0a8dc4fbda2d3">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a2737ae699602775284933402741e9df3">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#aa2f923dc4dceadbd9f1eac792694a5c6">Java</a>) quite powerful.</p>
<p>All about <em>Log Data</em> is found in chapter <a class="el" href="man_log_data.html">08 - Log Data (Debug Variables)</a>.</p>
<h1><a class="anchor" id="man_alox_tak_multiple_loxes"></a>
3. Using Multiple Lox Instances</h1>
<p>While <b>ALox</b> claims to be lean, easy and <a class="el" href="faq.html#faq_bauhaus">Bauhaus code style</a>, besides these concepts explained in this chapter, it was decided that a next level of complexity is supported. The good news is: for simple use case scenarios, you do not need to know about that.</p>
<p>So, this new 'level of complexity' is simply introduced by the fact that it is possible, and sometimes very attractive, to create and use more than one instance of class <b>Lox</b> in a software. Each class is populated with <em>Loggers</em> and of-course uses an own dedicated tree of domains.</p>
<p>The following paragraphs gives use cases and further background on using multiple <em>Loggers</em>.</p>
<h2><a class="anchor" id="man_alox_tak_multiple_loxes_dbg_rel_log"></a>
3.1 A Dedicated Lox Singleton for Debug Logging</h2>
<p>There are two fundamental logging scenarios that we call <b>debug logging</b> and <b>release logging</b>. (For information, see <a class="el" href="faq.html#faq_debug_vs_release_logging">What do the terms "debug logging" and "release logging" mean?</a>.)</p>
<p>For various reasons (performance, code size, security, etc), debug <em>Log Statements</em> should be disabled and removed (pruned) from the release version of a software.</p>
<p>To achieve all goals and provide a very simple interface into debug logging, the <b>ALox</b> ecosystem provides class <b>Log</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Log.html">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Log.html">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Log.html">Java</a>) This class is a 100% static interface into class Lox. In other words, class Log creates and holds exactly one static instance of class Lox and mimics the complete interface of that instance into corresponding static methods.</p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_1.svg" width="486" height="292"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>The assumption (restriction) that is taken here, is that debug logging is implemented by using one dedicated Lox. This should be sufficient for most scenarios, because, as described above, within that Lox instance various <em>Loggers</em> with own <em>Log Domain</em> settings will provide a lot of flexibility to log different types of messages into different streams and manipulate the verbosity for each stream accordingly.</p>
<dl class="section note"><dt>Note</dt><dd>Differences of language implementations:<ul>
<li>In C# and Java, the only reason to introduce class <b>Log</b> and to mimic the interface of <b>Lox</b> with it, was that this opend the possibility for efficient pruning of debug <em>Log Statements</em>.</li>
<li>In C++, pruning is realized by reprocessor macros. Hence, class <b>Log</b> there does not mimic any interface method of <b>Lox</b> as said above. Still class <b>Log</b> exists and provides the remaining methods specific to debug-logging. </li>
</ul>
</dd>
<dd>
For more details on pruning and the use of class <em>Log</em>, consult the language specific documentation: <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/cppprepro.html#cppprepro_macros">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/cspruning.html">C#</a> and <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/javasetup.html#javasetup_pruning">Java</a>.<br />
 For a more details on debug and release logging see chapter <a class="el" href="man_debug_and_release_logging.html">10 - Differences of Debug- and Release-Logging</a>.</dd></dl>
<h2><a class="anchor" id="man_alox_tak_multiple_loxes_missioncritical"></a>
3.2 Separating Mission Critical Log statements</h2>
<p>Another motivation for using separated instances of class <b>Lox</b> may be understood when thinking about use cases where things start getting critical from different point of views. For example:</p>
<ul>
<li>A Lox is supposed to collect runtime data from <em>the field</em>, hence metrics, which are transferred using a tailored <em>Logger</em> that contacts a metrics server at runtime. The team that implements such metrics collection, may, for good reason, not want to share 'their' <b>Lox</b> with other parts of a software maintained by another team. Accidental mis-configuration of the Lox and its domain may lead to uncontrolled server communication.</li>
<li>A Lox is supposed to collect critical runtime errors from deployed software. Such log information should be separated from other log streams, e.g. much more 'verbose' standard release-logging that goes to a rolling log file</li>
<li>A local software want to support writing messages to the <em>Linux</em> or <em> Windows OS</em> specific system journal. Also in this case, a mis-configured Lox might 'spam' into such system journals in an inappropriate manner, and it would be advised to use a separated Lox that is not touched outside its scope of activity.</li>
</ul>
<h2><a class="anchor" id="man_alox_tak_multiple_logger_registration"></a>
3.3 Multiple Registration of a Logger</h2>
<p>It is explicitly allowed to attach a <em>Logger</em> to more than one <b>Lox</b> object. class <b>Logger</b> implements a mechanism to protect against race conditions in multi-threaded environments as soon as such double-registration occurs. The obvious use case is again the mission-critical, separated <b>Lox</b> described in the previous paragraphs. A <em>Logger</em> that is responsible for 'standard' release logging, e.g. logging into a rolling release log file, can be attached to the 'mission-critical' <b>Lox</b> which holds the corresponding 'mission-critical' <em>Logger</em>. Now, the standard release log automatically receives a copy of the 'mission-critical' <em>Log Statements</em>.</p>
<h1><a class="anchor" id="man_alox_tak_lox_registration"></a>
4. Class ALox and Registration of Lox Instances</h1>
<p>Pure static class <b>ALox</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1ALox.html">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1ALox.html">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1ALox.html">Java</a>) keeps a list of all instances of class <b>Lox</b> that were registered with it. Registration is done by default when constructing a Lox. The advantage of that registration is that a <b>Lox</b> can be retrieved statically using <b>ALox.Get</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1ALox.html#a91162815924f9c2460b34836c39e1a50">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1ALox.html#a43ea367a64b98d76d0f18955bf0e5a04">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1ALox.html#a3991620cb06ad677d52b1d463a73b2c8">Java</a>). This is convenient because this way, references of a <b>Lox</b> do not be passed around or otherwise made public.</p>
<p>But there might be situations, when the this <em>'public availability'</em> of a <b>Lox</b> instance is not wanted. For this case, optional parameter <code>doRegister</code> may be set to <code>false</code> when invoking constructor <b>Lox.Lox</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a1c1585d0800185380c13eb475249aa58">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#acc9b602f88cd6d950fdb225dfc1f6e41">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#af8f539ceb3118068eda172e9077d71bd">Java</a>).</p>
<dl class="section note"><dt>Note</dt><dd>Descriptions of other <em>'protection'</em> mechanisms against unwanted manipulation of class <b>Lox</b> are described in:<ul>
<li>Section <a class="el" href="man_domain_substitution.html#man_domain_substitution_config">3. Substitution Rules and External Configuration</a> and</li>
<li>Section <a class="el" href="man_external_verbosity_configuration.html">13 - External Verbosity Configuration</a></li>
</ul>
</dd></dl>
<hr/>
 <center>Next chapter: <a class="el" href="man_logdomains.html">04 - Log Domains</a> </center> <center> <a class="el" href="manual.html">Back to index</a> </center> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 9 2017 16:16:29 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<!-- Start of StatCounter Code e -->
<script type="text/javascript">
var sc_project=11242602;
var sc_invisible=1;
var sc_security="5ac13373";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web statistics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11242602/0/5ac13373/1/" alt="web
statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
