<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ALox: 07 - Prefix Logables</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!-- so strange, that doxgen does not highlight each menu item. Just some... -->
<script>
  $(document).ready(function() {     
    fnameStart= window.location.href.lastIndexOf('/')
    fnameEnd=   window.location.href.indexOf('_', fnameStart )
    if( fnameEnd < 0 ) {
        fnameEnd=   window.location.href.indexOf('.', fnameStart )
    }
    if( fnameEnd > -1 ) {
        subString= window.location.href.substring( fnameStart, fnameEnd )
        $('li').toArray().forEach(function(li){
            if(     typeof li.firstChild.href != 'undefined'
                &&  li.firstChild.href.indexOf(subString) > 0 
                ){
               li.classList.add('current');
            }
        });
    }
  });
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1604 R. 1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>ALox&#160;Home</span></a></li>
      <li><a href="faq.html"><span>FAQ</span></a></li>
      <li><a href="manual.html"><span>Manual</span></a></li>
      <li><a href="cpp_ref/cppmainpage.html"><span>ALox&#160;for&#160;C++</span></a></li>
      <li><a href="cs_ref/csmainpage.html"><span>ALox&#160;for&#160;C#</span></a></li>
      <li><a href="java_ref/javamainpage.html"><span>ALox&#160;for&#160;Java</span></a></li>
      <li><a href="tools.html"><span>Tools</span></a></li>
      <li><a href="https://github.com/AlexWorx/ALox-Logging-Library"><span>Download</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">07 - Prefix Logables </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#man_prefix_logables_intro">1. Introduction</a></li>
<li class="level1"><a href="#man_prefix_logables_processing">3. How ALox Processes Prefix Logables</a></li>
<li class="level1"><a href="#man_prefix_logables_wrapup">6. Wrap-Up</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="man_prefix_logables_intro"></a>
1. Introduction</h1>
<p>The feature of ALox called <b>Prefix Logables</b>, covered in this chapter, builds upon the ALox concept of <em>Scopes</em> in a similar way as feature <em>Scope Domains</em> does. Therefore it is advisable to have read and understood chapters</p><ul>
<li><a class="el" href="man_logdomains.html">04 - Log Domains</a> and</li>
<li><a class="el" href="man_scopes.html">05 - Scopes in ALox</a> prior to continuing reading here.</li>
</ul>
<p>This chapter will <em>not</em> repeat every detail covered already in the aforementioned chapters.</p>
<p><em>Logables</em> in ALox for Java/C# are of type <code>class </code> Object, in ALox for C++ of type <code>const void*</code>, accompanied by a type info parameter. Therefore, a user-defined derived type of class <code>Logger</code>, might expect (at least accept) any array-type, hence multiple objects to be logged out.<br />
 When looking at method <b><a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1core_1_1Logger.html#af6b022d80e4b67918067714afb8cab48">Logger.Log</a></b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1core_1_1Logger.html#af6b022d80e4b67918067714afb8cab48">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:cs_ref/" href="cs_ref/classcs_1_1aworx_1_1lox_1_1core_1_1Logger.html#a190bb68f9aa44fb53725398e6663549e">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:java_ref/" href="java_ref/classcom_1_1aworx_1_1lox_1_1core_1_1Logger.html#afb6fb454e24c653a10c6966754960298">Java</a>) we can see that a <em>Logger</em> by default receives an array of <em>Logables</em>. One part of the answer to this is, that if an array-type is passed as parameter <code>logable</code> to a <em>Log Statement</em>, this array will appear as one of the <em>Logables</em> of the list passed to the <em>Loggers</em>. In other words, ALox passes lists of objects the same as other 'objects' to the <em>Logger</em>.</p>
<p>So, where do the other <em>Logables</em> passed to the <em>Logger</em> now come from? The answer is: Those are <em>Prefix Logables</em>!</p>
<p>Before we explain the use cases for <em>Prefix Logables</em>, let us begin to elaborate how those are set by the user of ALox and how ALox processes them.</p>
<h1>2. Setting Prefix Logables</h1>
<h2>2.1 Setting Prefix Logables According to the Scope</h2>
<p>For the first way of setting and removing <em>Prefix Logables</em> method <b>Lox.SetPrefix</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Lox.html#a7c865720d8a1df7f2df6ee0b130abca9">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:cs_ref/" href="cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a3e47858f995e85610c154d5f17299615">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:java_ref/" href="java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#ac597801824c8795693fc149ad1f9243b">Java</a>) is used. The method and its overloaded versions is very similar to method <b>Lox.SetDomain</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Lox.html#a8a61a1c73d6a94b505c0baf9e6108bbb">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:cs_ref/" href="cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a7e3f6dee21600c53e79dd72a718f1c9e">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:java_ref/" href="java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#afd6a91bb2c6eaee017b0ccbd4cccd447">Java</a>) used for setting <em>Scope Domains</em>. Besides the difference in the name, the only difference is the first parameter, which is a <em>Logable</em> instead of a domain path string.</p>
<p>All that was said about setting <em>Scope Domains</em> in Chapter <a class="el" href="man_logdomains.html">04 - Log Domains</a> is true for setting <em>Prefix Logables</em> and this should not be repeated here. The same rules for <em>Scopes</em> apply, including the fact that with <em>Scope.ThreadInner</em> and <em>Scope.ThreadOuter</em>, a subsequent setting of a <em>Prefix Logable</em> is added to a list of <em>Prefix Logables</em> for these <em>Scopes</em>, while for other <em>Scopes</em>, the current <em>Prefix Logable</em> is replaced.</p>
<p>Passing <code>null</code> (C++: <code>nullptr</code>) as parameter <code>logable</code>, removes the <em>Prefix Logable</em> from the given <em>Scope</em>, respectively, in the case of thread-related <em>Scopes</em>, removes the <em>Prefix Logable</em> most recently set.</p>
<p>The only small difference to the interface for setting <em>Log Domains</em> is that there is no method available corresponding to <b>Lox.RemoveThreadDomain</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Lox.html#a097f3c186dbc0dc2d13188e1c3242230">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:cs_ref/" href="cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#af3f0ceda5a710c45879b4d25224aad49">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:java_ref/" href="java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#a0986c7bfe43e066b677489830a6c9af0">Java</a>), which provides a little extra flexibility of maintaining <em>Scope Domains</em> in contrast to maintaining <em>Prefix Logables</em>.</p>
<h2>2.2 Setting Prefix Logables According to the Log Domain</h2>
<p>Besides binding <em>Prefix Logables</em> to a <em>Scope</em>, ALox provides an alternative and this s binding <em>Prefix Logables</em> to a <em>Log Domain</em>. The method for doing this is <b>Lox.SetPrefix</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Lox.html#ac257a2345d3c5d4223b9861cd32309dd">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:cs_ref/" href="cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#ac69496baa95a957d48f1cec5c53296d0">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:java_ref/" href="java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#a9bda0b407a8e700abe7a3008c3cb8d5a">Java</a>).</p>
<p>The method accepts a <em>Log Domain</em> path which may be absolute (starting with <code>"/"</code> or relative). If relative the normal evaluation of a resulting domain path taking <em>Scope Domains</em> into account applies.<br />
 A third optional parameter allows to make the setting exclusive in respect to <em>Prefix Logables</em> which are set according to a <em>Scope</em>. By default, the exclusivity is not set.</p>
<h1><a class="anchor" id="man_prefix_logables_processing"></a>
3. How ALox Processes Prefix Logables</h1>
<p>With any sort of <em>Log Statement</em> in ALox, the <em>Prefix Logables</em> are collected according to the <em>Scope</em> and the <em>Log Domain</em> of that <em>Log Statement</em>. In the same fashion as <em>Scope Domains</em> are concatenated, ALox adds <em>Prefix Logables</em> to the list of <em>Logables</em> that are passed to each <em>Logger</em> instance. Consequently, the list that a <em>Logger</em> receives is filled as follows:</p>
<ol type="1">
<li><em>Prefix Logable</em> of <em>Scope.Global</em> </li>
<li><em>Prefix Logables</em> of <em>Scope.ThreadOuter</em> (can be more than one)</li>
<li><em>Prefix Logable</em> of <em>Scope.Path</em> (PACKAGE)</li>
<li><em>Prefix Logable</em> of <em>Scope.Filename</em> (CLASS)</li>
<li><em>Prefix Logable</em> of <em>Scope.Method</em> </li>
<li>The <em>Prefix Logables</em> of the parent <em>Log Domain</em> in the order of there setting (recursively prepended!)</li>
<li>The <em>Prefix Logables</em> of the <em>Log Domain</em> in the order of there setting</li>
<li><b>The <em>Logable</em> of the <em>Log Statement</em> itself</b></li>
<li><em>Prefix Logables</em> of <em>Scope.ThreadInner</em> (can be more than one)</li>
</ol>
<p>If in <b>6</b>. or <b>7</b>. a <em>Prefix Logable</em> was passed with optional parameter <code>otherPLs</code> valued <b>Inclusion.Exclude</b>, then after adding this <em>Logable</em>, the collection of further <em>Prefix Logables</em> is stopped. Because all objects are collected in reverse order, starting with objects of <em>Scope.ThreadInner</em>, this means that objects otherwise collected in <b>1</b>. to <b>5</b>. (respectively <b>6</b>.) are not added. This allows to have a setting of a <em>Prefix Logable</em> which is bound to a domain to 'overwrite' those bound to a <em>Scope</em>.</p>
<p>As with any 'normal' <em>Logable</em> that is passed to the <em>Logger</em>, it is completely up to the <em>Logger</em> what to do with this data.</p>
<p>Those <em>Logables</em> passed with <em>Scope.ThreadInner</em> are appended to the list <em>after</em> the <em>Log Statements</em>' <em>Logable</em> and therefore should be considered a 'suffix', not a prefix. You might wonder why this whole feature is named 'prefix', especially as this term is not applicable to objects in an ordered array. The answer to this is given in the next section.</p>
<h1>4. Use cases of Prefix Logables</h1>
<p>Talking about the use cases of feature <em>Prefix Logables</em>, we have to distinguish between logging arbitrary objects, what ALox supports and logging textual (string) messages, what is by far the most widely application for ALox.</p>
<h2>4.1 Textual Logging</h2>
<p>When logging textual messages (more precisely: when using <em>Loggers</em> derived from abstract class <b>TextLogger</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1core_1_1textlogger_1_1TextLogger.html">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:cs_ref/" href="cs_ref/classcs_1_1aworx_1_1lox_1_1core_1_1textlogger_1_1TextLogger.html">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:java_ref/" href="java_ref/classcom_1_1aworx_1_1lox_1_1core_1_1textlogger_1_1TextLogger.html">Java</a>) as just as all textual <em>Loggers</em> delivered with ALox are), the impact of <em>Prefix Logable</em> is simple. Class <b>TextLogger</b> just concatenates all (textual) objects found in the list of <em>Logables</em> in the output buffer which then is passed to the abstract logging method implemented by derived classes.</p>
<dl class="section note"><dt>Note</dt><dd>For more information on <em>Loggers</em> and <em>TextLogger</em>, see chapters <a class="el" href="man_colorful_loggers.html">15 - Colorful Loggers</a> and <a class="el" href="man_ext_loggers.html">B - Loggers and Implementing Custom Types</a>.</dd></dl>
<p>This explains the term <em>'prefix'</em>: Apart from <em>Prefix Logables</em> of <em>Scope.ThreadInner</em>, all <em>Prefix Logables</em> are prefixes to the 'log message'. Those of <em>Scope.ThreadInner</em> are suffixes. For the architects of the ALox API it was just too teasing to name the whole concept <em>Prefix Logables</em> and this way being able to have - for the most obvious use case - the user code look like this:</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.SetPrefix( <span class="stringliteral">&quot;Data File: &quot;</span>, <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">Scope</a>.Filename );</div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.Info( <span class="stringliteral">&quot;Opened.&quot;</span> );</div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.Info( <span class="stringliteral">&quot;Read.&quot;</span> );</div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.Info( <span class="stringliteral">&quot;Closed.&quot;</span> );</div></div><!-- fragment --><p> The output will look similar to this:</p>
<pre class="fragment">UT_dox_manual.cs(346):Log_SetPrefix()     [/]: Data File: Opened.
UT_dox_manual.cs(349):Log_SetPrefix()     [/]: Data File: Read.
UT_dox_manual.cs(352):Log_SetPrefix()     [/]: Data File: Closed.</pre><p>A next use case is recursively increasing 'indentation' of the log messages, as demonstrated here:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> RecursiveDataType Search( <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lib_1_1strings_1_1String.html">String</a> name )</div><div class="line">{</div><div class="line">    <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.SetPrefix( <span class="stringliteral">&quot;  &quot;</span>, <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">Scope</a>.ThreadOuter ); <span class="comment">// add indent</span></div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.Info( <span class="stringliteral">&quot;Inspecting object: &quot;</span> + Name );</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( Name.Equals ( name ) )</div><div class="line">    {</div><div class="line">        <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.SetPrefix( null, <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">Scope</a>.ThreadOuter ); <span class="comment">// remove indent</span></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// recursion</span></div><div class="line">    RecursiveDataType returnValue= null;</div><div class="line">    <span class="keywordflow">foreach</span>( RecursiveDataType child <span class="keywordflow">in</span> Children )</div><div class="line">        <span class="keywordflow">if</span>( (returnValue= child.Search( name )) != null )</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.SetPrefix( null, <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">Scope</a>.ThreadOuter ); <span class="comment">// remove indent</span></div><div class="line">    <span class="keywordflow">return</span> returnValue;</div><div class="line">}</div></div><!-- fragment --><p> Note that this sample is using <em><a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6a1ee3f312b05c55202500569aadfc8d9b">Scope.ThreadOuter</a></em>. If using <em>Scope.Method</em> it would fail, because only the thread-related <em>Scopes</em> allow to add multiple objects. With thread-related <em>Scopes</em>, this works like a 'push and pull' mechanism. Luckily, with using the thread-related <em>Scopes</em>, the whole indentation is automatically <em>thread-safe!</em> </p>
<p>Indentation can also be useful when adding prefixes for different language-related <em>Scopes</em>. For example classes of a nested namespace (in Java 'package'), might be considered core, helper tools that usually have a low <b>Verbosity</b> setting. It might be a good option to indent all their logging by setting a prefix for their namespace. If they need to be debugged, and their <em>Verbosity</em> is increased, <em>Log Statement</em> of those are due to the indentation still very easily distinguishable from the rest of the log output. Such structured log output can help to increase the readability of a debug-log tremendously.</p>
<p>As an alternative to 'indentation', think about using the escape codes found in class <b>ESC</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1ESC.html">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:cs_ref/" href="cs_ref/classcs_1_1aworx_1_1lox_1_1ESC.html">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:java_ref/" href="java_ref/classcom_1_1aworx_1_1lox_1_1ESC.html">Java</a>). Prefixing those instead of normal strings or spaces, leads to nicely colorized, bold and italic log output, at least with text-loggers supporting such styles (ALox provides such <em>Loggers</em> e.g. for ANSI consoles or Windows OS command windows).</p>
<p>Use cases are depending on the application and situation. Let us touch a last one here: Consider an application that causes errors in certain situations. Let's say, a phone app seems to start logging errors 'randomly' which means, you do not know when. You suspect it happens when the network connection drops. A first quick investigation could be to add a <em>Prefix Logable</em> <b>"Online:  "</b>, respectively <b>"Offline: "</b> as soon as the devices' OS signals a change. You simply set this using <em><a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6a4cc6684df7b4a92b1dec6fce3264fac8">Scope.Global</a></em>, or alternatively for the <em>Log Domain</em> where the error occurs. In the next debug-runs, you have all messages prefixed with the current state. You do not need to follow your log output <em>'backward'</em> to find the most recent log message giving you information about that status. Generally spoken: <em>Prefix Logables</em> allow to add status information to log lines providing information collected elsewhere.</p>
<h2>4.2 Arbitrary Object Logging</h2>
<p>The situation with <em>Loggers</em> designed to log arbitrary objects is different. (How to create such custom, application specific <em>Loggers</em> is described in <a class="el" href="man_ext_loggers.html">B - Loggers and Implementing Custom Types</a>).</p>
<p>If only arbitrary objects were supported in <em>ALox</em> and the standard textual logging would not exist, then the whole feature probably would have been named <b>Context Logables</b>. Instead of providing the 'context' with each <em>Log Statement</em> to a custom <em>Logger</em>, or setting it explicitly using a custom interface method of such custom <em>Logger</em>, arbitrary context data can be used leveraging the various <em>Scope</em> options.</p>
<p>Imagine for example a custom <em>Logger</em> that logs into a database. A 'context' in this case could be the database table to use. <em>Log Statements</em> of different <em>Scopes</em> would then 'automatically' direct their <em>Logables</em> to different tables in the database.</p>
<p>Another sample could be logging application metrics to an online metrics-server. The parameters and information passed to the server are probably encoded in a URL. Now, the bigger parts of such parameters do not change within a context (aka <em>Scope</em>). Those would be passed only once per <em>Scope</em> to ALox using the feature of <em>Prefix Logables</em>. The metrics-<em>Log Statements</em> themselves would only carry the rest of the detailed information specific to the metrics information that are supposed to be sent.</p>
<p>Use cases are endless and can not be named here, they depend the field of application that ALox is used to support.</p>
<h1>5 ALox for C++ specifics</h1>
<p>One of the design goals of the ALox Logging Library is to avoid code clutter when using it. In a perfect world, <em>Log Statements</em> would be as clear and easy to read as comment lines. C++ does not provide life-cycle management for allocated data (as Java and C# do) and this causes a potential problem when using <em>Prefix Logables</em>.</p>
<p>When logging <b>arbitrary objects</b>, the use cases touched in the previous section make it obvious that ALox can not be responsible for life-cycle management of <em>Prefix Logables</em>. Therefore, if data is used as <em>Prefix Logable</em> which is exclusively created for that purpose (and are no general long-living objects), there is no way to avoid some extra code that creates and deletes such objects, probably enclosed by </p><pre class="fragment">    #if defined(ALOX_DBG_LOG) // alternatively ALOX_REL_LOG, or both
    ...
    #endif
</pre><p>or embedded in macro </p><pre class="fragment">    Log_Prune( ... )    // alternatively Lox_Prune()
</pre><p>We think, as this is a matter of logging arbitrary objects, which is considered a 'heavy' use of ALox anyhow, extra code should not be anything to be concerned about.</p>
<p>With <b>textual logging</b>, especially in the case of debug logging, this is different. Here, the designers of ALox are concerned about extra code wich increases the 'intrusiveness' of ALox! Therefore, the following rule applies. For <em>Logables</em> of <code>type</code> <code>0</code>, hence especially when using the overloaded version of C++ method <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:cpp_ref/" href="cpp_ref/classaworx_1_1lox_1_1Lox.html#a3534f0ed8caa9504f58cf1a8fc7ae2d3">Lox.SetPrefix</a> which accepts a <code>const TString&amp;</code> as a <b>Logable</b>, then ALox internally creates a copy of the string provided. Of-course, when such <em>Prefix Logable</em> is removed, ALox deletes it. The benefit of this is huge: A user of ALox does not need to care about keeping string-type <em>Prefix Logables</em> 'alive' after setting them. This means, any locally assembled, short-living string can be passed to method <b>Lox.SetPrefix</b> and right afterwards, it can be deleted or removed by C++ from the stack if the (C++ -)scope is left.</p>
<p>It is important to understand the impact:</p><ul>
<li>With string-type <em>Prefix Logables</em>, you do not need to worry about the life cycle of the string passed</li>
<li>With <em>Prefix Logables</em> of arbitrary type however, it is the users' responsibility to keep objects intact as long as any <em>Log Statement</em> may be invoked that gets such <em>Prefix Logable</em> passed.</li>
<li>Unlike, with ALox for C#/Java, setting an <b>AString</b> as <em>Prefix Logable</em> with <code>type</code> <code>0</code> and changing the instance after it was set, does <em>not</em> change the prefix object.</li>
</ul>
<p>The latter is of-course a drawback of this convenience design. The way out is to set an external <b>AString</b> by using the overloaded version of the method which allows to explicitly set the type of the <em>Prefix Logable</em> and using <code>-1</code> for the parameter <code>type</code>. This type value explicitly specifies external objects of type <b>AString</b>.</p>
<h1><a class="anchor" id="man_prefix_logables_wrapup"></a>
6. Wrap-Up</h1>
<p>This is what this chapter has covered in respect to <em>Prefix Logables</em>:</p><ul>
<li><em>Prefix Logables</em> are <em>Logables</em> that can be set according to the <em>Scope</em> mechanisms featured by ALox, or according to a <em>Log Domain</em>.</li>
<li>With every <em>Log Statement</em> executed by ALox, all applicable <em>Prefix Logables</em> are collected in a list and passed to each <em>Logger</em>.</li>
<li>The most prominent use case for <em>Prefix Logables</em> is adding a prefix, a color or (optionally recursive) indentation to textual log messages.</li>
<li>With custom <em>Loggers</em> using arbitrary types of <em>Logables</em>, the use cases are different but not less powerful. Consider the feature to be named <em>Context Logables</em> rather than <em>Prefix Logables</em>.</li>
<li>In ALox for C++ a copy of any string-type <em>Prefix Logable</em> set is created. Therefore, a user must not worry about the life-cycle of such <em>Prefix Logables</em>. If arbitrary objects are used, the user of ALox has to ensure that <em>Prefix Logables</em> survive until the last corresponding <em>Log Statement</em> is executed.</li>
</ul>
<p>As with other features using ALox <em>Scopes</em>, on the first sight, this seems to be a little complicated. Especially when looking at the list given in <a class="el" href="man_prefix_logables.html#man_prefix_logables_processing">How ALox Processes Prefix Logables</a>. But when you look at the use cases, it becomes clear, that from the nine options of that list, mostly one is used in parallel, seldom two. Once the concept of <em>Scope Domains</em> is fully understood, the use of this feature and of others that leverage ALox' <em>Scopes</em>, should quickly become very intuitive.</p>
<hr/>
 <center>Next chapter: <a class="el" href="man_log_data.html">08 - Log Data (Debug Variables)</a> </center> <center> <a class="el" href="manual.html">Back to index</a> </center> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 26 2016 13:01:47 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
