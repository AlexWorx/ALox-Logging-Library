<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALox: 07 - Prefix Logables</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1702 R. 1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--ALox Main Menu-->
<div style="background: #2f3a48; " >
<table  class="aworx-menutable"  >
 <tbody>
 <tr style="height: 36px;">
  <td> <a class="aworx-menu_hl" href="index.html"                  >Home</a>                        </td>
  <td> <a class="aworx-menu"    href="cpp_ref/cppmainpage.html"    >ALox for C++</a>                </td>
  <td> <a class="aworx-menu"    href="cs_ref/csmainpage.html"      >ALox for C#</a>                 </td>
  <td> <a class="aworx-menu"    href="java_ref/javamainpage.html"  >ALox for Java</a>               </td>
  <td> <a class="aworx-menu"    href="https://github.com/AlexWorx/ALox-Logging-Library">Download</a></td>
 </tr>
 </tbody>
</table>
</div>
<!--end ALox Main Menu-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">07 - Prefix Logables </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#man_prefix_logables_intro">1. Introduction</a></li>
<li class="level1"><a href="#man_prefix_logables_setting">2. Setting Prefix Logables</a><ul><li class="level2"><a href="#man_prefix_logables_setting_1">2.1 Setting Prefix Logables According to the Scope</a></li>
<li class="level2"><a href="#man_prefix_logables_setting_2">2.2 Setting Prefix Logables According to the Log Domain</a></li>
<li class="level2"><a href="#man_prefix_logables_setting_3">2.3 Setting More than one Prefix Logable at a Time</a></li>
</ul>
</li>
<li class="level1"><a href="#man_prefix_logables_processing">3. How ALox Processes Prefix Logables</a></li>
<li class="level1"><a href="#man_prefix_logables_usecases">4. Use cases of Prefix Logables</a><ul><li class="level2"><a href="#man_prefix_logables_usecases_textual">4.1 Textual Logging</a></li>
<li class="level2"><a href="#man_prefix_logables_usecases_binary">4.2 Arbitrary Object Logging</a></li>
</ul>
</li>
<li class="level1"><a href="#man_prefix_logables_cppspecifics">5. ALox for C++ specifics</a></li>
<li class="level1"><a href="#man_prefix_logables_wrapup">6. Wrap-Up</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="man_prefix_logables_intro"></a>
1. Introduction</h1>
<p>The feature of <b>ALox</b> called <b>Prefix Logables</b>, covered in this chapter, builds upon the <b>ALox</b> concept of <em>Scopes</em> in a similar way as feature <em>Scope Domains</em> does. Therefore it is advisable to have read and understood chapters</p><ul>
<li><a class="el" href="man_logdomains.html">04 - Log Domains</a> and</li>
<li><a class="el" href="man_scopes.html">05 - Scopes in ALox</a> prior to continuing reading here.</li>
</ul>
<p>This chapter will <em>not</em> repeat every detail covered already in the aforementioned chapters.</p>
<p><em>Logables</em> in <b>ALox</b> for Java/C# are of type <code>class </code> Object, in <b>ALox for C++</b> of type <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>. An implementation of abstract class <b>Logger</b>, receives an arbitrary amount of objects of arbitrary types. This corresponds to the fact that the <em>Log Statements</em> also accept arbitrary amounts of arbitrary objects to be logged out. However, the lists may differ: a <em>Logger</em> might receive <b>more</b> objects than those that have been provided with a <em>Log Statement</em>! Those additional objects are <em>Prefix Logables</em>!</p>
<p>Before we explain the use cases for <em>Prefix Logables</em>, let us begin to elaborate how those are set by the user of <b>ALox</b> and how <b>ALox</b> processes them.</p>
<h1><a class="anchor" id="man_prefix_logables_setting"></a>
2. Setting Prefix Logables</h1>
<h2><a class="anchor" id="man_prefix_logables_setting_1"></a>
2.1 Setting Prefix Logables According to the Scope</h2>
<p>For the first way of setting and removing <em>Prefix Logables</em> method <b>Lox.SetPrefix</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a0af08eeaa33fd3c7897f1562933acff0">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#ad15fc3df5e793cdaaeff847df5eb579f">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#a82948e8e8eb71c04eccd905c3f97d1d0">Java</a>) is used. The method and its overloaded versions is very similar to method <b>Lox.SetDomain</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a1b78fb31f62ec7e9f862417c5936e8ea">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a280572b2c652d82ed88598586a267635">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#afd6a91bb2c6eaee017b0ccbd4cccd447">Java</a>) used for setting <em>Scope Domains</em>. Besides the difference in the name, the only difference is the first parameter, which is a <em>Logable</em> instead of a domain path string.</p>
<p>All that was said about setting <em>Scope Domains</em> in Chapter <a class="el" href="man_logdomains.html">04 - Log Domains</a> is true for setting <em>Prefix Logables</em> and this should not be repeated here. The same rules for <em>Scopes</em> apply, including the fact that with <em>Scope.ThreadInner</em> and <em>Scope.ThreadOuter</em>, a subsequent setting of a <em>Prefix Logable</em> is added to a list of <em>Prefix Logables</em> for these <em>Scopes</em>, while for other <em>Scopes</em>, the current <em>Prefix Logable</em> is replaced.</p>
<p>Passing <code>null</code> (C++: <code>nullptr</code>) as parameter <code>logable</code>, removes the <em>Prefix Logable</em> from the given <em>Scope</em>, respectively, in the case of thread-related <em>Scopes</em>, removes the <em>Prefix Logable</em> most recently set.</p>
<p>The only small difference to the interface for setting <em>Log Domains</em> is that there is no method available corresponding to <b>Lox.RemoveThreadDomain</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#adb89a8f794afb0b6551fe45499dea973">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#a3df59d5b962fac68a8c0c93c9796c933">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#a0986c7bfe43e066b677489830a6c9af0">Java</a>), which provides a little extra flexibility of maintaining <em>Scope Domains</em> in contrast to maintaining <em>Prefix Logables</em>.</p>
<h2><a class="anchor" id="man_prefix_logables_setting_2"></a>
2.2 Setting Prefix Logables According to the Log Domain</h2>
<p>Besides binding <em>Prefix Logables</em> to a <em>Scope</em>, <b>ALox</b> provides an alternative and this is binding <em>Prefix Logables</em> to a <em>Log Domain</em>. The method for doing this is <b>Lox.SetPrefix</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a73b0ea069f4b4e068e61acc88f8c65d3">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#aef3a12c0d3389414eb13d49216152e34">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#adb4750d2ea4a47803b78e23221bfdb9a">Java</a>).</p>
<p>The method accepts a <em>Log Domain</em> path which may be absolute (starting with <code>"/"</code> or relative). If relative the normal evaluation of a resulting domain path taking <em>Scope Domains</em> into account applies.<br />
 A third optional parameter allows to make the setting exclusive in respect to <em>Prefix Logables</em> which are set according to a <em>Scope</em>. By default, the exclusivity is not set.</p>
<dl class="section note"><dt>Note</dt><dd>Alternatively, <em>Prefix Logables</em> bound to a <em>Log Domain</em> can set using configuration variable <a href="group__GrpALoxConfigVars.html">ALOX_LOXNAME_PREFIXES</a>. Of-course, this allows only string-type-<em>Prefix Logables</em> to be set.<br />
 For general information on <b>ALox</b> configuration variables consult <a class="el" href="group__GrpALoxConfigVars.html">I - Configuration Variables</a>.<br />
 For information on how to pass configuration data from custom sources to <b>ALox</b>, refer to namespace documentation <b>aworx::lib::config</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lib_1_1config.html">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/namespacecs_1_1aworx_1_1lib_1_1config.html">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/namespacecom_1_1aworx_1_1lib_1_1config.html">Java</a>).</dd></dl>
<h2><a class="anchor" id="man_prefix_logables_setting_3"></a>
2.3 Setting More than one Prefix Logable at a Time</h2>
<p>While the <em>Log Statements</em> accept arbitrary amount of objects (in C++ "Boxes"), the methods to set <em>Prefix Logables</em> have only one parameter. Nevertheless, more than one object can be set! In Java and C# this is done by passing an an array of type <code>Object</code>[] with the "prefixes" to the corresponding method. In C++ the objects have to be wrapped in an object of class <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lib_1_1boxing_1_1Boxes.html">aworx::Boxes</a>, which is derived from <code>std::vector&lt;aworx::Box&gt;</code>. If this is done, <b>ALox</b> will "flatten" the given arrays when the <em>Prefix Logables</em> are passed to the <em>Loggers</em>. This means, instead of adding the array to the overall list of <em>Logables</em>, the single objects contained in the array are added.</p>
<dl class="section note"><dt>Note</dt><dd>This technique of passing a whole list of objects trough one parameter is found several times with <b>ALox</b>. For example, the various overloaded versions of method <b>Lox.Once</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Lox.html#a6461dec7c62cad4cb618ac730bac95a9">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1Lox.html#adf12d740a5c327f144757d7893af1374">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1Lox.html#a7347b1bdc9a7abe966bd812190f54db8">Java</a>) is using the same technique. The following code snippets sample how such object array are created right in the parameter list of the invocation.</dd>
<dd>
C++: <div class="fragment"><div class="line"><a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/group__GrpMacrosDebugLog.html#ga68c8af8941a64be4f6e075ab31c6c05b">Log_Once</a>( <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lib_1_1boxing_1_1Boxes.html">Boxes</a>(<span class="stringliteral">&quot;One - {} - {}!&quot;</span>, <span class="stringliteral">&quot;two&quot;</span>, 3 ) );</div></div><!-- fragment --> C#: <div class="fragment"><div class="line"><a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.Once( <span class="keyword">new</span> Object[] {<span class="stringliteral">&quot;One - {} - {}!&quot;</span>, <span class="stringliteral">&quot;two&quot;</span>, 3}  );</div></div><!-- fragment --> Java: <div class="fragment"><div class="line"><a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.once( <span class="keyword">new</span> Object[] {<span class="stringliteral">&quot;One - {} - {}!&quot;</span>, <span class="stringliteral">&quot;two&quot;</span>, 3}  );</div></div><!-- fragment --></dd></dl>
<h1><a class="anchor" id="man_prefix_logables_processing"></a>
3. How ALox Processes Prefix Logables</h1>
<p>With any sort of <em>Log Statement</em> in <b>ALox</b>, the <em>Prefix Logables</em> are collected according to the <em>Scope</em> and the <em>Log Domain</em> of that <em>Log Statement</em>. In the same fashion as <em>Scope Domains</em> are concatenated, <b>ALox</b> adds <em>Prefix Logables</em> to the list of <em>Logables</em> that are passed to each <em>Logger</em> instance. Consequently, the list that a <em>Logger</em> receives is filled as follows:</p>
<ol type="1">
<li><em>Prefix Logable</em> of <em>Scope.Global</em> </li>
<li><em>Prefix Logables</em> of <em>Scope.ThreadOuter</em> (can be more than one)</li>
<li><em>Prefix Logable</em> of <em>Scope.Path</em> (PACKAGE)</li>
<li><em>Prefix Logable</em> of <em>Scope.Filename</em> (CLASS)</li>
<li><em>Prefix Logable</em> of <em>Scope.Method</em> </li>
<li>The <em>Prefix Logables</em> of the parent <em>Log Domain</em> in the order of there setting (recursively prepended!)</li>
<li>The <em>Prefix Logables</em> of the <em>Log Domain</em> in the order of there setting</li>
<li><b>The <em>Logable</em> of the <em>Log Statement</em> itself</b></li>
<li><em>Prefix Logables</em> of <em>Scope.ThreadInner</em> (can be more than one)</li>
</ol>
<p>If in <b>6</b>. or <b>7</b>. a <em>Prefix Logable</em> was passed with optional parameter <code>otherPLs</code> valued <b>Inclusion.Exclude</b>, then after adding this <em>Logable</em>, the collection of further <em>Prefix Logables</em> is stopped. Because all objects are collected in reverse order, starting with objects of <em>Scope.ThreadInner</em>, this means that objects otherwise collected in <b>1</b>. to <b>5</b>. (respectively <b>6</b>.) are not added. This allows to have a setting of a <em>Prefix Logable</em> which is bound to a domain to 'overwrite' those bound to a <em>Scope</em>.</p>
<p>As with any 'normal' <em>Logable</em> that is passed to the <em>Logger</em>, it is completely up to the <em>Logger</em> what to do with this data.</p>
<p>Those <em>Logables</em> passed with <em>Scope.ThreadInner</em> are appended to the list <em>after</em> the <em>Log Statements</em>' <em>Logable</em> and therefore should be considered a 'suffix', not a prefix. You might wonder why this whole feature is named 'prefix', especially as this term is not applicable to objects in an ordered array. The answer to this is given in the next section.</p>
<h1><a class="anchor" id="man_prefix_logables_usecases"></a>
4. Use cases of Prefix Logables</h1>
<p>Talking about the use cases of feature <em>Prefix Logables</em>, we have to distinguish between logging arbitrary objects, what <b>ALox</b> supports and logging textual (string) messages, what is by far the most widely application for <b>ALox</b>.</p>
<h2><a class="anchor" id="man_prefix_logables_usecases_textual"></a>
4.1 Textual Logging</h2>
<p>When logging textual messages (more precisely: when using <em>Loggers</em> derived from abstract class <b>TextLogger</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1core_1_1textlogger_1_1TextLogger.html">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1core_1_1textlogger_1_1TextLogger.html">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1core_1_1textlogger_1_1TextLogger.html">Java</a>), just as all textual <em>Loggers</em> delivered with <b>ALox</b> are), the impact of <em>Prefix Logable</em> is simple. Class <b>TextLogger</b> just passes all objects found in the list of <em>Logables</em> to its <b>ObjectConverter</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1core_1_1textlogger_1_1ObjectConverter.html">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1core_1_1textlogger_1_1ObjectConverter.html">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/interfacecom_1_1aworx_1_1lox_1_1core_1_1textlogger_1_1ObjectConverter.html">Java</a>) which in turn (in its default implementation) passes them to field <b>StandardConverter::FormatterPS</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1core_1_1textlogger_1_1StandardConverter.html#a85f447c2e5d7073292ccd3ed59824b5e">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1core_1_1textlogger_1_1StandardConverter.html#a85f447c2e5d7073292ccd3ed59824b5e">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1core_1_1textlogger_1_1StandardConverter.html#ad4175b7278824555775c22bae96a901c">Java</a>). This formatter, has object <b>StandardConverter::FormatterJS</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1core_1_1textlogger_1_1StandardConverter.html#a41deffcdf2933af4c71b1d2441ca4b2f">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1core_1_1textlogger_1_1StandardConverter.html#a41deffcdf2933af4c71b1d2441ca4b2f">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1core_1_1textlogger_1_1StandardConverter.html#ab9740fecd76d8232d40e83277d76a4fd">Java</a>) attached. This way, <b>TextLogger</b> is well prepared to assemble a nicely formatted log output, by default accepting Python formatter strings as well as the corresponding Java syntax.</p>
<dl class="section note"><dt>Note</dt><dd>As already explained in this manual and in the documentation of class <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lib_1_1strings_1_1format_1_1Formatter.html">Formatter</a>, there is an important feature that supports the concept of <em>Prefix Logables</em> very nicely: While usually (in other libraries and languages) such formatting classes accept <b>one</b> format string and an arbitrary amount of objects, with this class the format string is included in the object list. The first object may or may not be a format string. If it is not, the object is just "applied" (appended in textual representation) to the log output. As soon as a format string with placeholders is detected, the formatting process starts. All arguments consumed by the format string are then skipped in the list and - if still arguments exist - the algorithm continues from the start.<br />
 As a consequence, prefix logables can contain a format string and arguments, while still the <em>Logables</em> which are collected from the <em>Log Statement</em> can themselves contain a format string and corresponding arguments.</dd>
<dd>
For more information on <em>Loggers</em> and <em>TextLogger</em>, see chapters <a class="el" href="man_colorful_loggers.html">16 - Colorful Loggers</a> and <a class="el" href="man_ext_loggers.html">A - Loggers and Implementing Custom Types</a>.</dd></dl>
<p>This explains the term <em>'prefix'</em>: Apart from <em>Prefix Logables</em> of <em>Scope.ThreadInner</em>, all <em>Prefix Logables</em> are prefixes to the 'log message'. Those of <em>Scope.ThreadInner</em> are suffixes. For the architects of the <b>ALox</b> API it was just too teasing to name the whole concept <em>Prefix Logables</em> and this way being able to have - for the most obvious use case - the user code look like this:</p>
<div class="fragment"><div class="line"><a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.SetPrefix( <span class="stringliteral">&quot;Data File: &quot;</span>, <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">Scope</a>.Filename );</div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.Info( <span class="stringliteral">&quot;Opened.&quot;</span> );</div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.Info( <span class="stringliteral">&quot;Read.&quot;</span> );</div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.Info( <span class="stringliteral">&quot;Closed.&quot;</span> );</div></div><!-- fragment --><p> The output will look similar to this:</p>
<pre class="fragment">UT_dox_manual.cs(347):Log_SetPrefix()     [/]: Data File: Opened.
UT_dox_manual.cs(350):Log_SetPrefix()     [/]: Data File: Read.
UT_dox_manual.cs(353):Log_SetPrefix()     [/]: Data File: Closed.</pre><p>A next use case is recursively increasing 'indentation' of the log messages, as demonstrated here:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> RecursiveDataType Search( <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lib_1_1strings_1_1String.html">String</a> name )</div><div class="line">{</div><div class="line">    <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.SetPrefix( <span class="stringliteral">&quot;  &quot;</span>, <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">Scope</a>.ThreadOuter ); <span class="comment">// add indent</span></div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.Info( <span class="stringliteral">&quot;Inspecting object: &quot;</span> + Name );</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( Name.Equals ( name ) )</div><div class="line">    {</div><div class="line">        <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.SetPrefix( null, <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">Scope</a>.ThreadOuter ); <span class="comment">// remove indent</span></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// recursion</span></div><div class="line">    RecursiveDataType returnValue= null;</div><div class="line">    <span class="keywordflow">foreach</span>( RecursiveDataType child <span class="keywordflow">in</span> Children )</div><div class="line">        <span class="keywordflow">if</span>( (returnValue= child.Search( name )) != null )</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1Log.html">Log</a>.SetPrefix( null, <a class="codeRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6">Scope</a>.ThreadOuter ); <span class="comment">// remove indent</span></div><div class="line">    <span class="keywordflow">return</span> returnValue;</div><div class="line">}</div></div><!-- fragment --><p> Note that this sample is using <em><a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6a1ee3f312b05c55202500569aadfc8d9b">Scope.ThreadOuter</a></em>. If using <em>Scope.Method</em> it would fail, because only the thread-related <em>Scopes</em> allow to add multiple objects. With thread-related <em>Scopes</em>, this works like a 'push and pull' mechanism. Luckily, with using the thread-related <em>Scopes</em>, the whole indentation is automatically <em>thread-safe!</em> </p>
<p>Indentation can also be useful when adding prefixes for different language-related <em>Scopes</em>. For example classes of a nested namespace (in Java 'package'), might be considered core, helper tools that usually have a low <b>Verbosity</b> setting. It might be a good option to indent all their logging by setting a prefix for their namespace. If they need to be debugged, and their <em>Verbosity</em> is increased, <em>Log Statement</em> of those are due to the indentation still very easily distinguishable from the rest of the log output. Such structured log output can help to increase the readability of a debug-log tremendously.</p>
<p>As an alternative to 'indentation', think about using the escape codes found in class <b>ESC</b> (<a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lox_1_1ESC.html">C++</a>, <a class="elRef" doxygen="ALox/html/cs_ref/cs_ref.tag:./cs_ref/" href="./cs_ref/classcs_1_1aworx_1_1lox_1_1ESC.html">C#</a>, <a class="elRef" doxygen="ALox/html/java_ref/java_ref.tag:./java_ref/" href="./java_ref/classcom_1_1aworx_1_1lox_1_1ESC.html">Java</a>). Prefixing those instead of normal strings or spaces, leads to nicely colorized, bold and italic log output, at least with text-loggers supporting such styles (ALox provides such <em>Loggers</em> e.g. for ANSI consoles or Windows OS command windows).</p>
<p>Use cases are depending on the application and situation. Let us touch a last one here: Consider an application that causes errors in certain situations. Let's say, a phone app seems to start logging errors 'randomly' which means, you do not know when. You suspect it happens when the network connection drops. A first quick investigation could be to add a <em>Prefix Logable</em> <b>"Online:  "</b>, respectively <b>"Offline: "</b> as soon as the devices' OS signals a change. You simply set this using <em><a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lox.html#aaecc53892786f2fa11e682f633af84c6a4cc6684df7b4a92b1dec6fce3264fac8">Scope.Global</a></em>, or alternatively for the <em>Log Domain</em> where the error occurs. In the next debug-runs, you have all messages prefixed with the current state. You do not need to follow your log output <em>'backward'</em> to find the most recent log message giving you information about that status. Generally spoken: <em>Prefix Logables</em> allow to add status information to log lines providing information collected elsewhere.</p>
<h2><a class="anchor" id="man_prefix_logables_usecases_binary"></a>
4.2 Arbitrary Object Logging</h2>
<p>The situation with <em>Loggers</em> designed to log arbitrary objects is different. (How to create such custom, application specific <em>Loggers</em> is described in <a class="el" href="man_ext_loggers.html">A - Loggers and Implementing Custom Types</a>).</p>
<p>If only arbitrary objects were supported in <b>ALox</b> and the standard textual logging would not exist as the predominant use-case, then the whole feature probably would have been named <b>Context Logables</b>. Instead of providing the 'context' with each <em>Log Statement</em> to a custom <em>Logger</em>, or setting it explicitly using a custom interface method of such custom <em>Logger</em>, arbitrary context data can be used leveraging the various <em>Scope</em> options.</p>
<p>Imagine for example a custom <em>Logger</em> that logs into a database. A 'context' in this case could be the database table to use. <em>Log Statements</em> of different <em>Scopes</em> would then 'automatically' direct their <em>Logables</em> to different tables in the database, if different <em>Prefix Logables</em> had been set for the <em>Scopes</em>.</p>
<p>Another sample could be logging application metrics to an online metrics-server. The parameters and information passed to the server are probably encoded in a URL. Now, the bigger parts of such parameters do not change within a context (aka <em>Scope</em>). Those would be passed only once per <em>Scope</em> to <b>ALox</b> using the feature of <em>Prefix Logables</em>. The metrics-<em>Log Statements</em> themselves would only carry the rest of the detailed information specific to the metrics information that are supposed to be sent.</p>
<p>Use cases are endless and can not be named here, they depend the field of application that ALox is used to support.</p>
<h1><a class="anchor" id="man_prefix_logables_cppspecifics"></a>
5. ALox for C++ specifics</h1>
<p>One of the design goals of the <b>ALox</b> Logging Library is to avoid code clutter when using it. In a perfect world, <em>Log Statements</em> would be as clear and easy to read as comment lines. C++ does not provide life-cycle management for allocated data (as Java and C# do) and this causes a potential problem when using <em>Prefix Logables</em>.</p>
<p>When logging <b>arbitrary objects</b>, the use cases touched in the previous section make it obvious that <b>ALox</b> can not be responsible for life-cycle management of <em>Prefix Logables</em>. Therefore, if data is used as <em>Prefix Logable</em> which is exclusively created for that purpose (and are no general long-living objects), there is no way to avoid some extra code that creates and deletes such objects, probably enclosed by </p><pre class="fragment">    #if defined(ALOX_DBG_LOG) // alternatively ALOX_REL_LOG, or both
    ...
    #endif
</pre><p>or embedded in macro </p><pre class="fragment">    Log_Prune( ... )    // alternatively Lox_Prune()
</pre><p>We think with release logging and binary object logging, both considered a 'heavy' use of <b>ALox</b> anyhow, extra code should not be anything to be concerned about.</p>
<p>With <b>textual logging</b>, especially in the case of debug logging, this is different. Here, the designers of <b>ALox</b> are concerned about extra code which increases the 'intrusiveness' of <b>ALox!</b> Therefore, the following rule applies. For <em>Logables</em> of box type <code>char</code>[], <b>ALox</b> internally creates a <b>copy</b> of the string provided. Of-course, when such <em>Prefix Logable</em> is removed, <b>ALox</b> deletes it. The benefit of this is huge: A user of <b>ALox</b> does not need to care about keeping string-type <em>Prefix Logables</em> 'alive' after setting them. This means, any locally assembled, short-living string can be passed to method <b>Lox.SetPrefix</b> and right afterwards, it can be deleted or removed by C++ from the stack if the (C++ -)scope is left.</p>
<p>It is important to understand the impact:</p><ul>
<li>With string-type <em>Prefix Logables</em>, you do not need to worry about the life cycle of the string passed.</li>
<li>With <em>Prefix Logables</em> of arbitrary type, it is the users' responsibility to keep objects intact as long as any <em>Log Statement</em> may be invoked that gets such <em>Prefix Logable</em> passed.</li>
<li>Unlike, with <b>ALox</b> for C#/Java, setting an <b>AString</b> as <em>Prefix Logable</em> and afterwards changing the instance, such change is <b>not</b> reflected in the prefix object! This is because the contents of the <b>AString</b> is copied.</li>
</ul>
<p>The latter is of-course a disadvantage of this design: The <em>Prefix Logables</em> becomes a static object that does not reflect changes of its origin object! But there is an easy way out. Remember that only boxed objects of type <code>char</code>[] are copied. The trick to have changes of an <b>AString</b> instantly reflected in the logging, is to pass it wrapped in an object of type <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lib_1_1boxing_1_1BoxedAs.html">BoxedAs&lt;AString&gt;</a>. If this is done, the contents is <b>not</b> copied. Instead a reference to the <b>AString</b> is boxed and any change of this object is reflected in the <em>Prefix Logable</em>.</p>
<dl class="section note"><dt>Note</dt><dd>This approach is not only applicable to class <b>AString</b> but to any custom string type that by default gets boxed as <code>char</code>[]. The only precondition is that along with the setup of <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a> in respect to the custom type, the type <b>BoxedAs&lt;CustomString&gt;</b> has to be equipped with boxing interface <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a>.<br />
 How to adopt custom string types to support boxing, including this "trick" is described in the documentation of <b>ALib Boxing</b> in chapter <a class="elRef" doxygen="ALox/html/cpp_ref/cpp_ref.tag:./cpp_ref/" href="./cpp_ref/namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_strings_custom">6.5 Boxing Custom String Types</a>.</dd></dl>
<h1><a class="anchor" id="man_prefix_logables_wrapup"></a>
6. Wrap-Up</h1>
<p>This is what this chapter has covered in respect to <em>Prefix Logables</em>:</p><ul>
<li><em>Prefix Logables</em> are <em>Logables</em> that can be set according to the <em>Scope</em> mechanisms featured by <b>ALox</b>, or according to a <em>Log Domain</em>.</li>
<li>With every <em>Log Statement</em> executed by <b>ALox</b>, all applicable <em>Prefix Logables</em> are collected in a list and passed to each <em>Logger</em>.</li>
<li>The most prominent use case for <em>Prefix Logables</em> is adding a prefix, a color or (optionally recursive) indentation to textual log messages.</li>
<li>With custom <em>Loggers</em> using arbitrary types of <em>Logables</em>, the use cases are different but not less powerful. Consider the feature to be named <em>Context Logables</em> rather than <em>Prefix Logables</em>.</li>
<li>In <b>ALox for C++</b> a copy of any string-type <em>Prefix Logable</em> set is created. Therefore, a user must not worry about the life-cycle of such <em>Prefix Logables</em>. If arbitrary objects are used, the user of <b>ALox</b> has to ensure that <em>Prefix Logables</em> survive until the last corresponding <em>Log Statement</em> is executed.</li>
</ul>
<p>As with other features using <b>ALox</b> <em>Scopes</em>, on the first sight, this seems to be a little complicated. Especially when looking at the list given in <a class="el" href="man_prefix_logables.html#man_prefix_logables_processing">How ALox Processes Prefix Logables</a>. But when you look at the use cases, it becomes clear, that from the nine options of that list, mostly one is used in parallel, seldom two. Once the concept of <em>Scope Domains</em> is fully understood, the use of this feature and of others that leverage <b>ALox</b> <em>Scopes</em>, should quickly become very intuitive.</p>
<hr/>
 <center>Next chapter: <a class="el" href="man_log_data.html">08 - Log Data (Debug Variables)</a> </center> <center> <a class="el" href="manual.html">Back to index</a> </center> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 9 2017 16:16:29 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<!-- Start of StatCounter Code e -->
<script type="text/javascript">
var sc_project=11242602;
var sc_invisible=1;
var sc_security="5ac13373";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web statistics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11242602/0/5ac13373/1/" alt="web
statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
