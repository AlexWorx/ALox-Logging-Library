<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>ALox C# Reference: ThreadLock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cs_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">ALox C# Reference
   &#160;<span id="projectnumber">V. 1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../index.html"><span>ALox&#160;Home</span></a></li>
      <li><a href="../faq.html"><span>FAQ</span></a></li>
      <li><a href="../manual.html"><span>Manual</span></a></li>
      <li><a href="index.html"><span>ALox&#160;for&#160;C#</span></a></li>
      <li><a href="setup_projects_vs_cs.html"><span>VStudio&#160;Setup</span></a></li>
      <li><a href="tutorial_cs.html"><span>Tutorial</span></a></li>
      <li class="current"><a href="annotated.html"><span>Class&#160;Ref.</span></a></li>
      <li><a href="https://github.com/AlexWorx/ALox-Logging-Library"><span>Download</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecom.html">com</a></li><li class="navelem"><a class="el" href="namespacecom_1_1aworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespacecom_1_1aworx_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html">ThreadLock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcom_1_1aworx_1_1util_1_1ThreadLock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ThreadLock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class allows <em>mutual exclusive access</em> to resources that the using software agrees on to protect with a certain instance hereof. In other words, access to certain resources of a software that has to be thread safe, can be protected if each thread (aka critical section code) uses the same <a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html" title="This class allows mutual exclusive access to resources that the using software agrees on to protect w...">ThreadLock</a> to control the access to.  
 <a href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac633439ece63e381762e30fc8599c1a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#ac633439ece63e381762e30fc8599c1a9">ThreadLock</a> (bool <a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#a1ea15561e57893d4e2a4a16a366cdb68">recursiveMode</a>=true, bool setUnsafeMode=false)</td></tr>
<tr class="memdesc:ac633439ece63e381762e30fc8599c1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html" title="This class allows mutual exclusive access to resources that the using software agrees on to protect w...">ThreadLock</a> that allows recursion. A warning will be given (ALox Error) when the given recursion level is reached (and each multiple of it). In addition the lock can be initialized to be unsafe, which means the locking critical sections is disabled.  <a href="#ac633439ece63e381762e30fc8599c1a9">More...</a><br/></td></tr>
<tr class="separator:ac633439ece63e381762e30fc8599c1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a94cc394ebd68410e938195a5c4849"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#a00a94cc394ebd68410e938195a5c4849">Aquire</a> ()</td></tr>
<tr class="memdesc:a00a94cc394ebd68410e938195a5c4849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread which invokes this method gets registered as the current owner of this object, until the same thread releases the ownership invoking unlock(). In the case that this object is already owned by another thread, the invoking thread is suspended until ownership can be gained. Multiple (nested) calls to this method are counted and the object is only released when the same number of unlock() calls have been made.  <a href="#a00a94cc394ebd68410e938195a5c4849">More...</a><br/></td></tr>
<tr class="separator:a00a94cc394ebd68410e938195a5c4849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c93747c8daa99d65c2a04c6be0748c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#a94c93747c8daa99d65c2a04c6be0748c">Release</a> ()</td></tr>
<tr class="memdesc:a94c93747c8daa99d65c2a04c6be0748c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases ownership of this object. If lock() was called multiple times before, the same number of calls to this method have to be performed to release ownership.  <a href="#a94c93747c8daa99d65c2a04c6be0748c">More...</a><br/></td></tr>
<tr class="separator:a94c93747c8daa99d65c2a04c6be0748c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012fbb0f39e57c0a44ec83dd408fcda3"><td class="memItemLeft" align="right" valign="top">override String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#a012fbb0f39e57c0a44ec83dd408fcda3">ToString</a> ()</td></tr>
<tr class="memdesc:a012fbb0f39e57c0a44ec83dd408fcda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a String that represents this object.  <a href="#a012fbb0f39e57c0a44ec83dd408fcda3">More...</a><br/></td></tr>
<tr class="separator:a012fbb0f39e57c0a44ec83dd408fcda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c3cd592757e0998048abf426d2412c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#ae8c3cd592757e0998048abf426d2412c">SetUnsafe</a> (bool setUnsafe)</td></tr>
<tr class="memdesc:ae8c3cd592757e0998048abf426d2412c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If parameter is true, the whole locking system is disabled. The only objective here is to to gain execution speed, as thread synchronization causes relatively expensive system calls. Use this method only if you are 100% sure that your (otherwise) critical section are executed in a single threaded environment. And: "relative expensive" means: they are not really expensive. This only for the rare case that your critical section is very, very frequently executed.  <a href="#ae8c3cd592757e0998048abf426d2412c">More...</a><br/></td></tr>
<tr class="separator:ae8c3cd592757e0998048abf426d2412c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2bccd9812728e715f73c27dac06614"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#abf2bccd9812728e715f73c27dac06614">IsUnsafe</a> ()</td></tr>
<tr class="memdesc:abf2bccd9812728e715f73c27dac06614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if this instance was set to unsafe mode.  <a href="#abf2bccd9812728e715f73c27dac06614">More...</a><br/></td></tr>
<tr class="separator:abf2bccd9812728e715f73c27dac06614"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7b9819e5cf7944efedca64a67c5adbfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#a7b9819e5cf7944efedca64a67c5adbfc">UseAssertions</a> = true</td></tr>
<tr class="memdesc:a7b9819e5cf7944efedca64a67c5adbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to use assert() to detected misuse in debug mode. Default is on, and you should keep it on!  <a href="#a7b9819e5cf7944efedca64a67c5adbfc">More...</a><br/></td></tr>
<tr class="separator:a7b9819e5cf7944efedca64a67c5adbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b8fc043406437eb58d55168c137af1"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#a09b8fc043406437eb58d55168c137af1">WaitALoxWarningLimit</a> = <a class="el" href="classcom_1_1aworx_1_1util_1_1Ticker.html#ab80965005ac6ffa5c7b676f60abf9bc1">Ticker.FromMillis</a>( 1000 )</td></tr>
<tr class="memdesc:a09b8fc043406437eb58d55168c137af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a threshold that causes lock() to log a warning if acquiring the access using method lock() takes longer than the given number of milliseconds. To disable such messages, set this value to 0. Default is 1 sec. Measured in ticks, see class <a class="el" href="classcom_1_1aworx_1_1util_1_1Ticker.html" title="This class provides a pure static interface into system dependent time values (usually 64 bit tick co...">Ticker</a>.  <a href="#a09b8fc043406437eb58d55168c137af1">More...</a><br/></td></tr>
<tr class="separator:a09b8fc043406437eb58d55168c137af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b35011c911bf00d065eba8af27620a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#a2b35011c911bf00d065eba8af27620a7">RecursionWarningThreshold</a> = 10</td></tr>
<tr class="memdesc:a2b35011c911bf00d065eba8af27620a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limit of recursions. If limit is reached or a multiple of it, an error logged using ALox.  <a href="#a2b35011c911bf00d065eba8af27620a7">More...</a><br/></td></tr>
<tr class="separator:a2b35011c911bf00d065eba8af27620a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1ea15561e57893d4e2a4a16a366cdb68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#a1ea15561e57893d4e2a4a16a366cdb68">recursiveMode</a></td></tr>
<tr class="memdesc:a1ea15561e57893d4e2a4a16a366cdb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag if recursion support is on. If not, nested locks are not counted.  <a href="#a1ea15561e57893d4e2a4a16a366cdb68">More...</a><br/></td></tr>
<tr class="separator:a1ea15561e57893d4e2a4a16a366cdb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f41e1e3070abd18f7cdfdb9a95b3d9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#a7f41e1e3070abd18f7cdfdb9a95b3d9c">lockCount</a></td></tr>
<tr class="memdesc:a7f41e1e3070abd18f7cdfdb9a95b3d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter for the number of lock() calls of the current thread.  <a href="#a7f41e1e3070abd18f7cdfdb9a95b3d9c">More...</a><br/></td></tr>
<tr class="separator:a7f41e1e3070abd18f7cdfdb9a95b3d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194df7b1414f1a1181802f255faff967"><td class="memItemLeft" align="right" valign="top">Thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#a194df7b1414f1a1181802f255faff967">owner</a></td></tr>
<tr class="memdesc:a194df7b1414f1a1181802f255faff967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter for the number of lock() calls of the current thread.  <a href="#a194df7b1414f1a1181802f255faff967">More...</a><br/></td></tr>
<tr class="separator:a194df7b1414f1a1181802f255faff967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc9273ae9737bab384e14ef7d4b5c7a"><td class="memItemLeft" align="right" valign="top">Object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html#a4cc9273ae9737bab384e14ef7d4b5c7a">mutex</a></td></tr>
<tr class="memdesc:a4cc9273ae9737bab384e14ef7d4b5c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal object to lock on.  <a href="#a4cc9273ae9737bab384e14ef7d4b5c7a">More...</a><br/></td></tr>
<tr class="separator:a4cc9273ae9737bab384e14ef7d4b5c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class allows <em>mutual exclusive access</em> to resources that the using software agrees on to protect with a certain instance hereof. In other words, access to certain resources of a software that has to be thread safe, can be protected if each thread (aka critical section code) uses the same <a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html" title="This class allows mutual exclusive access to resources that the using software agrees on to protect w...">ThreadLock</a> to control the access to. </p>
<hr/>
<p> If a lock() is not followed by a corresponding unlock(), other threads will not be able to gain control to this object and will wait endlessly (deadlock situation). To avoid this, it is a good practice to embed pairs of lock()/unlock() calls into try/finally statements as follows: </p>
<pre class="fragment">try { tl.lock(); ...critical section code .... } finally { tl.unlock() } 
</pre><p><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html" title="This class allows mutual exclusive access to resources that the using software agrees on to protect w...">ThreadLock</a> uses an internal counter to allow multiple calls to lock() and to be freed only when a same amount of unlock() calls are performed. This behavior can be switched off by a constructor parameter. If switched off, each recursive lock() calls will not be counted and each call to unlock() will instantly free the mutex. This mode is even less recommended than using this class in recursive mode.</p>
<p>Furthermore, <a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html" title="This class allows mutual exclusive access to resources that the using software agrees on to protect w...">ThreadLock</a> allows to disable locking using setUnsafe(). The objective here is to gain execution speed, as thread synchronization causes relatively expensive system calls.</p>
<p>Caution: Use this class with great care. Deadlocks are not easy to detect and debug. Use this class only if standard synchronization of the JAVA language seems too limited and mechanisms like the class uses internally would need to be implemented. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac633439ece63e381762e30fc8599c1a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html">ThreadLock</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursiveMode</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setUnsafeMode</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html" title="This class allows mutual exclusive access to resources that the using software agrees on to protect w...">ThreadLock</a> that allows recursion. A warning will be given (ALox Error) when the given recursion level is reached (and each multiple of it). In addition the lock can be initialized to be unsafe, which means the locking critical sections is disabled. </p>
<hr/>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recursiveMode</td><td>(Optional) Flag if recursion support is on. If not, nested locks are not counted. </td></tr>
    <tr><td class="paramname">setUnsafeMode</td><td>(Optional) True to set this unsafe. Please don't! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a00a94cc394ebd68410e938195a5c4849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Aquire </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread which invokes this method gets registered as the current owner of this object, until the same thread releases the ownership invoking unlock(). In the case that this object is already owned by another thread, the invoking thread is suspended until ownership can be gained. Multiple (nested) calls to this method are counted and the object is only released when the same number of unlock() calls have been made. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="abf2bccd9812728e715f73c27dac06614"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsUnsafe </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query if this instance was set to unsafe mode. </p>
<hr/>
<dl class="section return"><dt>Returns</dt><dd>True if unsafe, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a94c93747c8daa99d65c2a04c6be0748c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Release </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases ownership of this object. If lock() was called multiple times before, the same number of calls to this method have to be performed to release ownership. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="ae8c3cd592757e0998048abf426d2412c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetUnsafe </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setUnsafe</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If parameter is true, the whole locking system is disabled. The only objective here is to to gain execution speed, as thread synchronization causes relatively expensive system calls. Use this method only if you are 100% sure that your (otherwise) critical section are executed in a single threaded environment. And: "relative expensive" means: they are not really expensive. This only for the rare case that your critical section is very, very frequently executed. </p>
<hr/>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setUnsafe</td><td>If true, <a class="el" href="classcom_1_1aworx_1_1util_1_1ThreadLock.html" title="This class allows mutual exclusive access to resources that the using software agrees on to protect w...">ThreadLock</a> is set unsafe, safe otherwise.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a012fbb0f39e57c0a44ec83dd408fcda3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">override String ToString </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a String that represents this object. </p>
<hr/>
<dl class="section return"><dt>Returns</dt><dd>A String that represents this object. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7f41e1e3070abd18f7cdfdb9a95b3d9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lockCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter for the number of lock() calls of the current thread. </p>

</div>
</div>
<a class="anchor" id="a4cc9273ae9737bab384e14ef7d4b5c7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Object mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal object to lock on. </p>

</div>
</div>
<a class="anchor" id="a194df7b1414f1a1181802f255faff967"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Thread owner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter for the number of lock() calls of the current thread. </p>

</div>
</div>
<a class="anchor" id="a2b35011c911bf00d065eba8af27620a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RecursionWarningThreshold = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limit of recursions. If limit is reached or a multiple of it, an error logged using ALox. </p>

</div>
</div>
<a class="anchor" id="a1ea15561e57893d4e2a4a16a366cdb68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool recursiveMode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag if recursion support is on. If not, nested locks are not counted. </p>

</div>
</div>
<a class="anchor" id="a7b9819e5cf7944efedca64a67c5adbfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UseAssertions = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag to use assert() to detected misuse in debug mode. Default is on, and you should keep it on! </p>

</div>
</div>
<a class="anchor" id="a09b8fc043406437eb58d55168c137af1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long WaitALoxWarningLimit = <a class="el" href="classcom_1_1aworx_1_1util_1_1Ticker.html#ab80965005ac6ffa5c7b676f60abf9bc1">Ticker.FromMillis</a>( 1000 )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a threshold that causes lock() to log a warning if acquiring the access using method lock() takes longer than the given number of milliseconds. To disable such messages, set this value to 0. Default is 1 sec. Measured in ticks, see class <a class="el" href="classcom_1_1aworx_1_1util_1_1Ticker.html" title="This class provides a pure static interface into system dependent time values (usually 64 bit tick co...">Ticker</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ThreadLock.cs</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 21 2013 23:08:33 for ALox C# Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
