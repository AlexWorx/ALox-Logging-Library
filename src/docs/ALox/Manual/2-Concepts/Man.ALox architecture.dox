// #################################################################################################
//  ALox - Logging in Bauhaus Style!
//
//  (c) 2013 A-Worx GmbH, Published under the The MIT License (Open Source License, see LICENSE.txt)
//  
//  File:	04.Man.ALox architecture.dox                                          ALox Documentation
// #################################################################################################

/**
\page man_alox_architecture         Overview of the ALox architecture

\tableofcontents

# 1. Namespaces # {#man_architecture_namespaces}

ALox is based on three namespaces (in Java named "packages"). A design principle of namespaces
in ALox is that the relationship between namespaces is not bidirectional. This means that if a
class in a namespace A inherits or uses a class in a namespace B, then there is no reference
from namespace B into namespace A. You can say here that "A knows B" but "B does not know A".

Lets start with two namespaces:
- **com.aworx.lox.core**<br>
  As the name says, within *com.aworx.lox.core* you will find the core classes needed for logging. Besides
  the abstract class [Logger](@ref #com.aworx.lox.core.Logger), there are classes that
  care about internal things like caller information or log domains. <br>
  In addtion there are utility classes, currently for *TextLoggers*, probably more to come
  in the future. As a basic user of ALox, you do not need to know too much about the classes
  in *com.aworx.lox.core*.

- **com.aworx.lox**<br>
  In namespace *com.aworx.lox* the central class is [Lox](@ref #com.aworx.lox.Lox) which acts as a
  container for the loggers, manages a set of different settings and prvides the user 
  interface (API) into ALox release logging.<br>
  In addtion you will find class [Log](@ref #com.aworx.lox.Log) which is a static interface
  into one dedicated *Lox* instance and this is all about debug logging.
  (For information about the terms debug and release logging, see \ref faq_debug_vs_release_logging.)

Now, namespace *com.aworx.lox* knows namespace *com.aworx.lox.core* (but not vice versa): 
  
\dot
digraph G 
{
    node [shape=plaintext, fontsize="10", fontname="Courier"]

    lox     [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx.lox</b></TD></TR>
                           <TR><TD                              >class Lox</TD></TR>
                           <TR><TD                              >class Log</TD></TR>
                           <TR><TD                              >class LogTools</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    core    [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0"> 
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx.lox.core</b></TD></TR>
                           <TR><TD                              >class LogDomain</TD></TR>
                           <TR><TD                              >class CallerInfo</TD></TR>
                           <TR><TD                              >class Logger</TD></TR>
                           <TR><TD                              >class TextLogger</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    lox -> core     [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
}
\enddot

The third namespace is:

- **com.aworx.loggers**<br>
  Namespace *com.aworx.lox.loggers* provide ready to use *Logger* types, e.g. 
  [ConsoleLogger](@ref #com.aworx.lox.loggers.ConsoleLogger) or
  [MemoryLogger](@ref #com.aworx.lox.loggers.MemoryLogger).

Neither *com.aworx.lox.core* nor *com.aworx.lox* know about this namespace. Of-course, *com.aworx.lox.loggers* knows about *com.aworx.lox.core*.
This makes sense, because instances of *Lox* get instances of abstract type *Logger* attached.
All that*Lox* knows is that they are derived from class *Logger* in namespace *com.aworx.lox.core*.
This allows you to create your own loggers. 

Let's imagine you are using ALox from within your own namespace *yournamespace* and you have 
created your own *Logger* class, residing in namepsace *yourloggers*. 
This then looks as follows:


\dot
digraph G 
{
    node [shape=plaintext, fontsize="10", fontname="Courier"]

    core    [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx.lox.core</b></TD></TR>
                           <TR><TD                              >class LogDomain</TD></TR>
                           <TR><TD                              >class CallerInfo</TD></TR>
                           <TR><TD                              >class Logger</TD></TR>
                           <TR><TD                              >class TextLogger</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    lox     [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx.lox</b></TD></TR>
                           <TR><TD                              >class Lox</TD></TR>
                           <TR><TD                              >class Log</TD></TR>
                           <TR><TD                              >class LogTools</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    loggers [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx.lox.loggers</b></TD></TR>
                           <TR><TD                              >class ConsoleLogger</TD></TR>
                           <TR><TD                              >class MemoryLogger</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    yournamespace [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b><font color="blue">yournamespace</font></b></TD></TR>
                           <TR><TD                              >class YourClass</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    yourloggers   [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b><font color="blue">yourloggers</font></b></TD></TR>
                           <TR><TD                              >class YourLogger</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];


    lox             -> core          [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    loggers         -> core          [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    yournamespace   -> lox           [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    yournamespace   -> loggers       [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    yournamespace   -> yourloggers   [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    yourloggers     -> loggers       [label= " probably knows" arrowhead="open",  fontsize="10", fontname="Helvetica", style="dashed"];
    yourloggers     -> core          [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
}
\enddot

Besides understanding a little of the architecture of ALox, a simple takeaway from this
is that you need to include namespaces *com.aworx.lox* and *com.aworx.lox.loggers* in your code, but not *com.aworx.lox.core*
(only when you want to create your own, custom loggers),

Finally, there is a "underlying" namespace called *com.aworx.util*. This is pure, basic
utility code. Some of the classes are just faster versions (more Bauhaus!) than equivalent
existing system classes. Others do exist only to enable ALox code to look the same 
across languages and platforms. Of-course, you can read the reference documentation
and you might use them somewhere, but this is not what we intended here. There are many
other libraries existing that are much more complete and standard. Again, we are building upon
them, only because we really think it makes our life easier in respect to porting ALox 
and because it makes your logging life just faster.

As you might guess, all other three packages build on *util*, so the graph is:


\dot
digraph G 
{
    node [shape=plaintext, fontsize="10", fontname="Courier"]

    core    [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx.lox.core</b></TD></TR>
                           <TR><TD                              >class LogDomain</TD></TR>
                           <TR><TD                              >class CallerInfo</TD></TR>
                           <TR><TD                              >class Logger</TD></TR>
                           <TR><TD                              >class TextLogger</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    lox     [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx.lox</b></TD></TR>
                           <TR><TD                              >class Lox</TD></TR>
                           <TR><TD                              >class Log</TD></TR>
                           <TR><TD                              >class LogTools</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    loggers [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx.lox.loggers</b></TD></TR>
                           <TR><TD                              >class ConsoleLogger</TD></TR>
                           <TR><TD                              >class MemoryLogger</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    util [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx.util</b></TD></TR>
                           <TR><TD                              >class MString</TD></TR>
                           <TR><TD                              >class TickTime</TD></TR>
                           <TR><TD                              >class ThreadLock</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];


    lox             -> core     [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    loggers         -> core     [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    lox             -> util     [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    loggers         -> util     [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    core            -> util     [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
}
\enddot

\note
Every rule has an exclamation, so we admit: we broke the "a package that is known by another does not know that other"
intentionally by adding the enums 
[Log.Level](@ref #com.aworx.lox.Log.Level),
[Log.DomainLevel](@ref #com.aworx.lox.Log.Level) and
[Log.Scope](@ref #com.aworx.lox.Log.Level) to class *Log* in namespace *com.aworx.lox*. They absolutely should
not be there! And *com.aworx.lox.core* classes rely on them. But the advantage of doing this was to tempting that
we broke the rule. We did it just for the reason that your code should look nice when you use ALox!

<br>
# 2. Loggers # {#man_architecture_logger}

ALox is designed to support different log streams. A log stream is a destination of log messages
and can be the IDE console, the terminal console, a file, a web service or anything that accepts
data streams. The abstract class [Logger] (@ref #com.aworx.lox.core.Logger) represents
such log stream. While some implementations of class Logger are provided with the ALox package,
the system allows custom implementations of Loggers that log information to any 'data drain' in
any format you like. 

\dot
digraph logger 
{
    node [shape=record, fontname=Courier,   fontsize=12];
    edge [shape=record, fontname=Helvetica, fontsize=10];
    logger  [ label="Logger"            URL="\ref com.aworx.lox.core.Logger"];
    cl      [ label="ConsoleLogger"     URL="\ref com.aworx.lox.loggers.ConsoleLogger"];
    ml      [ label="Memory Logger"     URL="\ref com.aworx.lox.loggers.MemoryLogger"];
    my      [ label="My Custom Logger"  ];
    cl -> logger  [ label= "extends" arrowhead="open", style="dashed", URL="\ref com.aworx.lox.Lox.AddLogger" ];
    ml -> logger  [ label= "extends" arrowhead="open", style="dashed", URL="\ref com.aworx.lox.Lox.AddLogger" ];
    my -> logger  [ label= "extends" arrowhead="open", style="dashed", URL="\ref com.aworx.lox.Lox.AddLogger" ];
}
\enddot

An application that supports different loggers at once, might decide to log only a subset
of the log messages to each of the loggers. To achieve this, each Logger allows to configure
log domain levels separately. The same log domain can be enabled in one Logger, but disabled
in another Logger. 

(For more information see chapter \ref man_loggers.)

<br>
# 3. Lox - Managing Loggers # {#man_architecture_lox}

The interface of class Logger is very basic and not intended to be used directly to perform any
logging. Furthermore, if one log message should go to more than one Logger, then each logger would have
to be invoked.<br>
To achieve both (have a convenient interface and dispatch log messages to more than one Logger), ALox
provides class [Lox] (@ref #com.aworx.lox.Lox). It acts as a container for all Loggers that
are created during the lifecycle of an application. In rare cases of complex logging scenarios, even
multiple instances of that class might be created with different Loggers contained. 

\dot
digraph example 
{
    node [shape=record, fontname=Courier,   fontsize=12];
    edge [shape=record, fontname=Helvetica, fontsize=10];
    lox [ label="Lox"       URL="\ref com.aworx.lox.Lox"];
    cl [ label="ConsoleLogger"    URL="\ref com.aworx.lox.core.Logger"];
    ml [ label="Memory Logger"    URL="\ref com.aworx.lox.core.Logger"];
    lox -> cl  [ label= "contains" arrowhead="open",  URL="\ref com.aworx.lox.Lox.AddLogger" ];
    lox -> ml  [ label= "contains" arrowhead="open",  URL="\ref com.aworx.lox.Lox.AddLogger" ];
}
\enddot

Various methods of class Lox provide an optional parameter to filter the command to certain Loggers
only. The standard use of such filters is to apply different log domain settings to different Loggers
contained in the Lox instance. Once the domain levels are properly set, log messages are automatically
appearing in the right loggers (none, some or all) depending on the log domain and log level specified in 
the log statement. However, there is also the possibility to filter log statements directly against Logger
names. For standard scenarios this is not recommended, because the flexibility to add new Loggers
(for new log formats or log message data drains) might be lost. 


<br>
# 4. Log - Debug Logging # {#man_architecture_log}

There are two fundamental logging scenarios that we call **debug logging** and **release logging**.
(For information, see \ref faq_debug_vs_release_logging.)

For various reasons (performance, code size, security, etc), debug log statements should be disabled
and removed (pruned) from the release version of a software.

To achieve all goals and provide a very simple interface into debug logging, the ALox ecosystem
provides class [Log] (@ref #com.aworx.lox.Log). This class is a 100% static interface into
class Lox. In other words, class Log creates and holds exaclty one static instance of class Lox and
mimics the complete interface of that instance into corresponding static methods.

\dot
digraph example 
{
    node [shape=record, fontname=Courier,   fontsize=12];
    edge [shape=record, fontname=Helvetica, fontsize=10];
    log  [ label="{Log|1:1 static prunable interface into Lox}"     URL="\ref com.aworx.lox.Lox"];
    lox  [ label="Lox"                                              URL="\ref com.aworx.lox.Lox"];
    cl   [ label="ConsoleLogger"                                    URL="\ref com.aworx.lox.core.Logger"];
    ml   [ label="MemoryLogger"                                     URL="\ref com.aworx.lox.core.Logger"];
    xyzl [ label="XYZLogger"                                        URL="\ref com.aworx.lox.core.Logger"];
    log -> lox  [ label= "Conains 1 singleton" arrowhead="open", style="solid", URL="\ref com.aworx.lox.Lox.AddLogger" ];
    lox -> cl   [ label= "contains" arrowhead="open",               URL="\ref com.aworx.lox.Lox.AddLogger" ];
    lox -> ml   [ label= "contains" arrowhead="open",               URL="\ref com.aworx.lox.Lox.AddLogger" ];
    lox -> xyzl [ label= "contains" arrowhead="open",               URL="\ref com.aworx.lox.Lox.AddLogger" ];
}
\enddot

The assumption (restriction) that is taken here, is that debug logging is implemented by using
only one Lox. This should be sufficient for most scenarios, because, as described above, within that Lox 
instance various Loggers with own log domain settings will provide a lot of flexibility to log different 
types of messages within a complex software into different streams and manipulate the verbosity for
each stream accordingly.

Depending on the platform and language, ALox provides a feature to automatically prune all statements 
that are deemed to be debug logging. 


<br>
# 5. Summary # {#man_architecture_summary}

The following summarizes the takeaways of this chapter:
- ALox is split in three namespaces, where two of them need to be referenced in your ALox enabled code,
  namely *com.aworx.lox" and *com.aworx.lox.loggers*.

- To implement own log data streams (data drains to log into, like databases, web services, etc.) 
  and your own log formats, custom implementations of class [Logger](@ref #com.aworx.lox.core.Logger) can be
  created.

- For debug logging, class [Log](@ref #com.aworx.lox.Log) is the right interface in ALox (and an extremely 
  simple way as well). All invocations related to class Log get easily pruned from your code.

- To implement release logging (e.g. to send error states or usage info of a mobile app to a server)
  an instance of class [Lox](@ref #com.aworx.lox.Lox) has to be created. The interface
  into the Lox is almost 100% the same as the interface of [Log](@ref #com.aworx.lox.Log) which is used
  for debug logging.

*/