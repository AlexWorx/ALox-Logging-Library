// #################################################################################################
//  ALox - Logging in Bauhaus Style!
//
//  (c) 2013 A-Worx GmbH, Published under the The MIT License (Open Source License, see LICENSE.txt)
//  
//  File:	06.Man.LevelsAndDomains.dox                                           ALox Documentation
// #################################################################################################

/**
\page man_levelsanddomains          Log Levels, Log Domains and Log Domain Levels

\tableofcontents

This chapter provides all details on log levels and log domains. Before reading it, be sure that
you have read and understood the chapter \ref man_alox_architecture. 


\~Comment ###
########################### Log Levels ############################
############# \~
\section man_levelsanddomains_levels     Log Levels

It is very common for logging ecosystems to provide the concept of *log levels*. Such log level
is provided either as a parameter to the log call or is provided by offering different log methods, like
*error()*, *warning()* or *verbose()*. (Alox provides both mechanisms.)
ALox is no exclamation to this. The four levels offered are enumerated in [Log.Level](@ref #com::aworx::lox::Log::Level)
and are named and sorted like this:
 - *Error*
 - *Warning*
 - *Info*
 - *Verbose*

The sorting of log levels means that if for example the log level '*Info*' is enabled, then all
log levels below '*Info*' ('*Warning*' and '*Error*') are also enabled. This way, changing the
log level changes the so called "verbosity" of your application. The higher the level setting
is, the more log messages will appear in the log.
                                                  
\~Comment ###
########################### Log Domains and Log Domain Levels ############################
############# \~
<br>
\section man_levelsanddomains_domains     Log Domains and Log Domain Levels
But the ALox logging ecosystem differs from most others in the respect that log levels are not evaluated
against a global setting. Log levels are always evaluated in consideration of a specific *log domain*.

*Log domains* are simple names (strings) that a developer specifies with a log statement. 
In a kind, *log domains* specify a "topic" or "theme" to which that certain log statement 
belongs to.
For example, those parts of a software that implement the user interface, could perform all 
log statements using the log domain "UI", while the parts that read or write into a database
could be named "DBIO" or similar. 

Now, ALox administers a setting for the log level per *log domain*. Such setting is called *log domain level*.
At runtime, for each log statement, the *log level* is evaluated against the *log domain level* and the log
message is either suppressed or not.

The *log domain levels* are enumerated in [Log.DomainLevel](@ref #com::aworx::lox::Log::DomainLevel) and are:

- *Off*
- *Errors*
- *WarningsAndErrors*
- *InfoWarningsAndErrors*
- *All*
- *Inherit*

This should be self explanatory, despite the last one, '*Inherit**, which is explained in the
next section.

\~Comment ###
########################### Hierarchical Log Domains ############################
############# \~
\section man_levelsanddomains_hierarchical_domains     Hierarchical Log Domains

One of the major design goals of ALox is simplicity. By nature simplicity is sometimes in 
in competition with flexibility or feature richness of an API. One way to resolve such conflicting 
goals is to provide features that - if not wanted or needed or not even known -  are invisible to 
the user. The concept of hierarchical log domains is a good sample of how this was achieved in the
ALox API design. 

Domain names can incorporate a domain separator character '/' (alternatively '\\' or '|'). As long
as such domain names are used in the normal way, nothing changes. However, as soon as sub domains
are addressed (portions of domain names are given into the API), then the hierarchical domain
system internally takes action.

Let us look at a sample: The UI portion of an application might define three domains:
- "UI" for general UI messages
- "UI/MENU" for messages generated by user menu selections
- "UI/DLG" for messages generated by dialog boxes

The program code of the UI would register the three domains as follows (C# sample):

\code{.cs}
Log.RegDomain( "UI",        Log.Scope.None );
Log.RegDomain( "UI/MENU",   Log.Scope.None );
Log.RegDomain( "UI/DLG",    Log.Scope.None );
\endcode

*(See  [Log.RegDomain()](@ref #com::aworx::lox::Log::RegDomain) for further reference.)*

<br>
Now, without using the feature of hierarchical domains, the user code that controls
the level setting for the domains would set the level of the domains as follows:
  
\code{.cs}
Log.SetDomain( "UI",	    Log.DomainLevel.InfoWarningsAndErrors );
Log.SetDomain( "UI/MENU",	Log.DomainLevel.InfoWarningsAndErrors );
Log.SetDomain( "UI/DLG",	Log.DomainLevel.InfoWarningsAndErrors );
\endcode

*(See  [Log.SetDomain()](@ref #com::aworx::lox::Log::SetDomain) for further reference.)*

Due to the fact that the default value for the level setting of a domain is 
[Log.DomainLevel.Inherit](@ref #com::aworx::lox::Log::DomainLevel), the two sub domains
of "UI" do not need to be set. They inherit the setting from their parent. It is
sufficient to set just the parent domain:

\code{.cs}
Log.SetDomain( "UI",	    Log.DomainLevel.InfoWarningsAndErrors );
\endcode

In the case, that one of the sub domains should receive a different setting, then
this can be easily done applying a specific level to it:
    
\code{.cs}
Log.SetDomain( "UI",	    Log.DomainLevel.InfoWarningsAndErrors );
Log.SetDomain( "UI/DLG",	Log.DomainLevel.Errors );
\endcode

In this sample, the sub domain "UI/DLG" gets its own setting, while the sub domain "UI/MENU"
is still inheriting the setting from parent domain "UI".

The optional parameter 'recursive' controls, if a level setting is recursively applied
to all sub domains. It defaults to true. Hence, the following code would set all three
domains to level *InfoWarningsAndErrors*:

\code{.cs}
Log.SetDomain( "UI/DLG",	Log.DomainLevel.Errors );
Log.SetDomain( "UI",	    Log.DomainLevel.InfoWarningsAndErrors );
\endcode

To prevent this, it is recommended to keep the right order of calls (parent domains first) 
or alternatively to specify the parameter *recursive* explicitly to false:

\code{.cs}
Log.SetDomain( "UI/DLG",	Log.DomainLevel.Errors );
Log.SetDomain( "UI",	    Log.DomainLevel.InfoWarningsAndErrors, false );
\endcode


The advantages of hierarchical domains so far are:
- You can control a whole set of domains with one statement
- If new versions of libraries provide new sub domains, their level setting is
  automatically controlled without explicitly adding a corresponding call to
  [Log.SetDomain()](@ref #com::aworx::lox::Log::SetDomain).

But there is one more point on it, described later in this chapter. First let us
look at the root domain of a Logger.

\~Comment ###
########################### Logger Root Domains ############################
############# \~
<br>
\section man_levelsanddomains_root_domain     The root domain of class Logger

As we have learned about the hierarchical organizations of domains, the next
concept is easy to understand. Each instance of class 
[Logger](@ref #com::aworx::lox::loggers::Logger) contains a public field of
type  [LogDomain](@ref #com::aworx::lox::core::LogDomain) which represents 
the *root domain*. Whenever a new domain is registered with a Lox, each logger
contained in this Lox gets this domain added as a sub domain of its root domain.

Now, if the *domain level* of such sub domain is not specified (using
[Lox.SetDomain](@ref #com::aworx::lox::core::Lox::SetDomain) or
[Log.SetDomain](@ref #com::aworx::lox::Log::SetDomain) the setting
defaults to "inherit" and hence these sub domains inherit the setting
of the root domain. Therefore, the level setting of a Loggers root domain
determine the "default" domain level for "unknown" (respectively "unset") domains. 

Different derivates of class Logger might have different preferences here. For
example the class [ConsoleLogger](@ref #com::aworx::lox::loggers::ConsoleLogger) in its
constructor, sets the domain level to [Log.DomainLevel.All](@ref #com::aworx::lox::Log.DomainLevel).
This way, messages that get logged on domains that have not been explicitly set
in the boot section of an application (or somewhere else) are displayed in the 
console. This makes sense, as the console is mainly for debug purposes. As soon as
a log statement appears under a domain that is not set properly, the programmer can
insert a corresponding statement to set the domain as wanted. In contrast to this,
the root domain in class [MemoryLogger](@ref #com::aworx::lox::loggers::MemoryLogger) is
set to [Log.DomainLevel.Off](@ref #com::aworx::lox::Log.DomainLevel). This way,
all log messages are suppressed unless explicitly set active. 

To change this behavior, use method 
[Lox.SetDomain](@ref #com::aworx::lox::core::Lox::SetDomain) or
[Log.SetDomain](@ref #com::aworx::lox::Log::SetDomain) on domain name "/"
and provide the right logger name in the filter parameter. For example, if you
want to see only *warning* and *error* messages for domains that are not explicitly
set, insert the following code right after a logger is added:

\code{.cs}
Log.SetDomain( "/", Log.DomainLevel.WarningsAndErrors, false, "Console" );
\endcode


\~Comment ###
########################### Default Domains ############################
############# \~
<br>
\section man_levelsanddomains_default_domains     Default domains

People might argue that providing a domain name to each log statement is an overhead of
typing. That is true. For this reason - and to get even more benefits - ALox provides the concept
of *default domains*. 

Domains, when registered, can be set as the default domain for a given 
[Log.Scope](@ref #com::aworx::lox::Log::Scope). 
Unfortunately but naturally, the possible values for the scope are platform/language dependent.
For example, in JAVA, the scope can be the whole package a class resides in, the class only or 
just a single method of a class. In C#, the scope can be the actual source file or the
actual method within a source file. Namespaces can not be the scope in C#, due to restrictions
in the way that *caller information* is collected.

Now, setting a domain as default is done by specifying a scope value other than 
[Log.Scope.None](@ref #com::aworx::lox::Log::Scope) to
[Log.RegDomain](@ref #com::aworx::lox::Log::RegDomain): 

\code{.cs}
Log.RegDomain( "UI",        Log.Scope.SourceFile );
Log.RegDomain( "UI/MENU",   Log.Scope.None );
Log.RegDomain( "UI/DLG",    Log.Scope.None );
\endcode

This sets the domain "UI" as the default domain for this source file. As a result, the
following two log statements are equal:

\code{.cs}
Log.Info( "UI", "User interface initialized" );
Log.Info( "User interface initialized" );
\endcode

In other words: If no domain name is given, the last recently registered default domain
name for is used. 

If a log statement is placed within two scopes at the same time (e.g.
Method and SoruceFile) then the inner scopes have higher preference than outer scopes. 

The advantage of using default domains are:
- less typing and better readability
- the domain name can be changed in one place
- copy and pasting code into different "domains" does not involve updating the domain 
  name in each log statement.

It is not an error to register a domain twice. For example, if a domain should
become the default domain for two different scopes, then for each scope a corresponding
call to RegDomain can be placed at appropriate locations in the code.

In general, the use of domain names is handled very uncritically by ALox. If a
domain is used without prior registering, an internal warning message is logged, but the 
domain is just created on the fly and everything works nicely. On the other hand, 
registering a domain several times does not hurt.
It is a good practice to avoid multiple registrations of domains for the same scope 
and the tutorials for the different languages that ALox support describe how this
is done:

- For C#, see tutorial chapter \ref tutcs_llld_3.



 
\~Comment ###
########################### Default Domains and domain hierarchy ############################
############# \~
<br>
\section man_levelsanddomains_hierarchical_default_domains     Default domains and domain hierarchy

Let us look at the sample from above once more:

\code{.cs}
Log.RegDomain( "UI",        Log.Scope.SourceFile );
Log.RegDomain( "UI/MENU",   Log.Scope.None );
Log.RegDomain( "UI/DLG",    Log.Scope.None );
\endcode

Now, as we have our root domain "UI" set up as the default domain, we can address the
sub domains using the '~' symbol. The following two log statements become are equal: 

\code{.cs}
Log.Info( "UI/DLG", "Dialog opened" );
Log.Info( "~/DLG", "Dialog opened" );
\endcode

The benefits are the same as above:

- less typing and better readability
- the domain name can be changed in one place
- copy and pasting code into different "domains" does not involve updating the domain 
  name in each log statement, as long as the the same sub domain names are wanted.


\~Comment ###
########################### The internal domain "ALOX" ############################
############# \~
<br>

\section man_levelsanddomains_internal_domain   The internal domain "ALOX"

We want to end this chapter, with a look at internal log messages coming from the ALox 
ecosystem itself and how their level can be controlled. This is quite easy 
and straightforward. 

ALox uses a domain called "ALOX" to log internal. This name is not hard coded, but represented
in a field in class [Lox](@ref #com::aworx::lox::core::Lox). E.g. in C#, this field
is called [Lox.InternalDomain](@ref #com::aworx::lox::core::Lox.InternalDomain).
If you want to change that (which should only be needed if you operate with different Lox instances
that share one or more Logger instances and you want to distinguish which Lox instance caused
a message), you go ahead as follows:

\code{.cs}
Lox aLox= new Lox();
aLox.InternalDomain= "ABC";
\endcode

If you want to change it for the static singleton Lox encapsulated in class Log, the code is:

\code{.cs}
Log.LOX.InternalDomain= "XYZ"
\endcode

But again, changing this should be barely necessary.

More interesting is of course to enable or disable the domain for certain loggers. Again, console loggers
that are enabled for debug messages of your software might want to show all internal messages, while 
distinct derivates of loggers, especially release loggers, might not. 

The API request this internal domain's log level to be specified in the moment a logger
is added to the log. See parameter 'internalDomainLevel' in 
[Log.AddLogger()](@ref #com::aworx::lox::Log::AddLogger)  respectively [Lox.AddLogger()](@ref #com::aworx::lox::core::Lox::AddLogger).

Of course, the domain level of the internal domain can be manipulated any time later, like any other domains' log level using
[Log.SetDomain()](@ref #com::aworx::lox::Log::SetDomain)  respectively [Lox.SetDomain()](@ref #com::aworx::lox::core::Lox::SetDomain).
The code would look like this:

\code{.cs}
Log.SetDomain( Log.LOX.InternalDomain, Log.DomainLevel.WarningsAndErrors, false, "Console" );
\endcode


\~Comment ###
########################### Summary ############################
############# \~
<br>

\section man_levelsanddomains_summary   Summary
In this chapter we covered the following things:
- The log levels *Error*, *Warning*, *Info*, *Verbose*
- Log domains and their domain level setting which controls the 
  output of log messages of different levels.
- Hierarchical log domains and how domain log levels are inherited
- The root domain of the class Logger, which determines the domain level
  of "unknown" domains
- Setting default domains for scopes
- Using the swung dash character "~". to address sub domains of default domains
- The internal domain of class Lox



\~Comment
- final section: the internal domain
- section: More on log domains
    - hierarchy
    - reference to: where to put log code
-  Root Domain und ihr Wert der vom ConsoleLogger überschrieben wird
-    Logger die später erzeugt werden...
\~

*/