// #################################################################################################
//  Documentation - ALox Logging Library
//
//  (c) 2013-2015 A-Worx GmbH, Germany
//  Published under MIT License (Open Source License, see LICENSE.txt)
// #################################################################################################


####################################################################################################
### Page cppprepro
####################################################################################################


/**
\page cppprepro    ALox and the C++ Preprocessor

\tableofcontents


# 1. Introduction  # {#cppprepro_1}
## 1.1. Structure of ALox Preprocessor Usage ## {#cppprepro_11}
The C/C++ preprocessor supports different tasks and different ways of symbol/macro definitions.
This can lead to some confusion and hard to understand errors at compile time.<p>

This is why ALox volunteers to adhere to a strict separation of preprocessor symbols and macros
in respect to naming and documentation:<br>
1. <b>Compilation Symbols:</b>
   These are variables that can be passed to the compiler (usually using the -D option)

2. <b>Code Selection Symbols:</b>
   These are preprocessor variables that are used for conditional compilation. Mostly their
   existence is derived from compilation symbols.

3. <b>Macros:</b>
   Finally, we are calling those preprocessor symbols, that stand for (and get replaced by) a
   piece of C++ code a "macro". For some good reasons, a complete <em>API level</em> into
   ALox is provided based on macros and it is advised to use these macros for debug logging
   at least. For release logging, these macros might be beneficial, but there are reasons to
   choose the C++ based API instead.


## 1.2. A-Worx Util Classes AWXU ## {#cppprepro_12}
ALox for C++ uses a few classes that are not related to logging but are general purpose classes.
On the one hand,  design is loosely based on library classes of C# and Java and on the other,
ALox for C# and Java provide similar utility classes. Together, this allows the code bases
of all three ALox implementations to match wherever this seemed to be appropriate.<p>
These classes reside in namespace <em>aworx::util</em> and are referred to as
<em>A-Worx Util Classes</em> or in short <em>AWXU</em>.<p>

To keep things simple, AWXU is not compiled into a separated library. It is included into ALox
in source code and this way compiled into the ALox library itself.
The only separation from ALox is is made from the fact that its sources reside in a separated
source directory. AWXU sources neither refer to any ALox sources nor do they depend on ALox
compilation symbols.


## 1.3. Reference Guide ## {#cppprepro_13}
For a reference to all preprocessor symbols and macros discussed in the following sections,
please see the corresponding symbol groups:
1. Compilation symbols
   - \ref GrpALoxCompilerSymbols
   - \ref GrpAWXUCompilerSymbols
2. Code selection symbols
   - \ref GrpALoxCodeSelectorSymbols
   - \ref GrpAWXUCodeSelectorSymbols
3. Macros
   - \ref GrpMacrosDebugLog
   - \ref GrpMacrosReleaseLog
   - \ref GrpALoxMacrosLowLevel
   - \ref GrpAWXUMacros

<br>
# 2. Compilation Symbols #  {#cppprepro_compsymbols}
As stated above, ALox volunteers to separate everything that is related to the C++ preprocessor
into three different categories. This section is about symbols that can be passed to the compiler.<p>

<b>Naming</b><br>
Many of the symbols are named using a postfix <em>_ON</em> or <em>_OFF</em> what indicates
that they can be used to switch a code selection symbol (see next sections) which is named
the same but excluding the postfix, on or off. As a sample, the <em>compilation symbols</em>
\ref ALOX_DBG_LOG_ON and \ref ALOX_DBG_LOG_OFF are controlling the definition of
the <em>code selection symbol</em> \ref ALOX_DBG_LOG.<p>

<b>Avoiding library compilation problems</b><br>
As with other C++ libraries, some of the compilation symbols change the interface and
footprint ('sizeof()') of some of the classes. Consequently, linking a code unit that was compiled
with different settings for one of these symbols, can fail. Even worse: in some cases, linking
still works, but a process running these code units crashes unexpectedly. Such crashes are
never easy to understand. So it is advised to be careful modifying compiler symbols and make
sure that those symbols whose documentation hints to the fact that they change the footprint of
the code, share the same value across all compilation units and the ALox library itself.<br>
Two mechanisms to  detect compilation setup problems exists. One is built in and automatically
active. It is implemented and documented in method:
\ref aworx::lox::Log::InitALox "Log::InitALox".<br>
The other can be used (e.g within bootstrapping code of source entities using ALox) to 'manually'
verify the compilation settings of a specific compilation unit. To implement this, the macro
\ref ALOX_COMPILER_SYMBOL_SETTINGS exist. The usage could look like that:
\verbatim
    ALOX_COMPILER_SYMBOL_SETTINGS
    cout << "ALox compilation symbols: "    << endl;
    cout << acss.Buffer()  << endl << endl;
\endverbatim


<b>Default values</b><br>
If no compilation symbols are given, appropriate default values are chosen by ALox headers.
Some of these default values refer to the somehow standard symbols <em>NDEBUG</em>, <em>DEBUG</em>
and <em>_DEBUG</em> used by other libraries. These default settings include:

- extra debug code is switched off.
- multi threading support is switched on.
- debug logging is switched on in debug builts and switched off in release builts.
- debug logging caller information is switched on.
- release logging is switched on.
- release logging caller information is switched off.

<b>Reference guide:</b><br>
The compilation symbols for ALox and AWXU are listed here:
- \ref GrpALoxCompilerSymbols
- \ref GrpAWXUCompilerSymbols

<br>
# 3. Code Selection Symbols # {#cppprepro_3}

These symbols are mostly derived (by the ALox header files) from the \ref GrpALoxCompilerSymbols
discussed in the previous section and, their naming oftenly corresponds to these, excluding the
postfix <em>_ON</em> and <em>_OFF</em>.<p>
These symbols must not be passed to the compiler and must not be set manually from within code
entities that use ALox libraries. They can be used in code entities that use ALox to select code
depending on the same settings of the ALox library compilation.
(Besides ALox specific symbols of that type, of-course, also platform specific symbols are
used to select code, e.g. "__GNUC__", "__GLIBCXX__", "_MSC_VER", etc.).<p>

Code selection symbols could be used to implement ALox logging using pairs of
\verbatim
#ifdef ALOX_XYZ_SYMBOL
#endif
\endverbatim
lines.

While they are useful to implement rather large extra code blocks which are only used if
certain logging is enabled, in general it is not recommended to use this mechanism for each
and every log statement. Instead, it is recommended to use the ALox macros discussed in the next
section.<p>

ALox itself uses these symbols to enable the compilation of specific versions of the library
and to conditionally select the definition of the ALox macros.

For a complete reference, please refer to \ref GrpALoxCodeSelectorSymbols.
<p>

<br>
# 4. C++ Macros# {#cppprepro_4}

## 4.1 Why Using Macros? ## {#cppprepro_41}
ALox for C++ makes extensive use of preprocessor macros. Why is this? Aren't preprocessor
macros error-prone and in general not adequate for modern C++ programming style? Well, in general
yes. But there are two main reasons why the decision was taken to build the highest interface
level into the ALox library on macros:

- **Pruning of debug log code**<br>
  For removing all logging invocations that are placed to support the analysis of the code while
  developing the application, a special macro \ref Log_Prune, that encloses all macros used for debug
  logging is set empty. While pruning could also be achieved in different ways, e.g. using
  compiler optimization techniques, the use of the preprocessor is reliable across compilers and
  platforms.
<p>

- **Adding caller information**<br>
ALox uses built-in standard preprocessor symbols like  "__FILE__" and "__LINE__" to provide information
about the position of logging statement within the source. Hiding these needed symbols within ALox
specific macros, reliefs the sources that use ALox from a lot of overhead.<p>

We think, from the fact that source code editors which color C++ macros specifically, a next small
benefit is seen when looking at the source code: Alike colored comment lines, all log lines
shine in their own preprocessor color.

## 4.2. ALox Macro Language ## {#cppprepro_42}

ALox provides a complete set of macros designed to incorporate debug and release logging statements
into software using ALox. Maybe the term "macro language" is overstating a little what it is, but
what this name wants to imply is that<br>
a) it is recommended to implement ALox logging in C++ sources by using these macros exclusively and <br>
b) that these macros are comprising a higher abstraction level of the ALox API itself.<p>
A "higher level" means, that the ALox classes do not "know" or use these macros as the classes
reside on a lower API level.<p>

This is a difference to other versions of ALox (ALox for C#, ALox for Java). The reasons for
relying on macros in the C++ version were already mentioned above. By providing not only a set
of macros to implement debug logging, but also one for release logging, one of the differences
to other ALox implementations is, that ALox for C++ allows to prune release logging from the code
separated from pruning debug logging.

\note In ALox for C# and ALox for Java, the pruning of release logging statements is not supported
by default (users can implement this still if applying certain rules). What is supported in all
ALox implementations however, is of-course to disable release logging statements at runtime.<br>
It might be important to understand the difference: When release
logging is disabled, the code for release logging still remains in the binaries, which has an
impact on their size and (a marginal) impact on their speed. In addition it is possibility to reverse
engineer such binaries and learn about internals of the software when somebody is doing so.<br>
In this respect, ALox for C++ is the most flexible implementation of ALox, which is rising from the
fact of using the C++ preprocessor.<p>

The macros and their documentation are divided into two different groups:<br>
- \ref GrpMacrosDebugLog
- \ref GrpMacrosReleaseLog

While all macros for debug logging start with the prefix <em>Log_</em>, those for release
logging are using the prefix <em>Lox_</em>. Otherwise, their naming and parameters are the
same. The rest of the macro names in most cases corresponds to methods found in
class \ref aworx::lox::Lox.<p>

\note This naming convention provides maximum source compatibility to ALox for C# and Alox for Java,
in which debug logging and its pruning is performed using a "mirror" class of class Lox, which
is called Log.

Both sets include the <code>Log_Prune()</code>, respectively <code>Lox_Prune()</code> macro.
All that these two macros do is pruning the code that is passed to them in the moment that
debug logging (respectively release logging) is supposed to be pruned.<p>

For an introduction of how to use these macros, see \ref cpptutorial.<br>
For a complete list, refer to
- \ref GrpMacrosDebugLog and
- \ref GrpMacrosReleaseLog.<p>

<br>
## 4.3. ALox Low Level Macros ## {#cppprepro_43}

The two sets of ALox macros for debug and release logging that where introduced in the previous
chapter, rely on a small set of low level macros.
While these macros are not deemed to be used directly, using or even manipulating them might
be another way for expert users to tweak ALox.<p>

The macros are listed and documented here:  \ref GrpALoxMacrosLowLevel.<p>

For developers who are interested in manipulating them, please refer to the source code of
ALox to get an understanding on how such manipulation would influence the existing
\ref GrpMacrosDebugLog and \ref GrpMacrosReleaseLog, and also how to build your own macros
upon them.

## 4.4. AWXU Macros ## {#cppprepro_44}
As mentioned allready, the ALox class library includes some utility classes, packaged into AWXU.
There are also a few macros available that are provided by AWXU. These are not related to
logging but might be useful in general.<p>
For people who are interested in and may want to use these macros within projects that use ALox
anyhow, the documentation is found here: \ref GrpAWXUMacros.

*/




