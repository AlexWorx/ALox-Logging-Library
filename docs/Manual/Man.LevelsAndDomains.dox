// #################################################################################################
//  Documentation - ALox Logging Library
//
//  (c) 2013-2016 A-Worx GmbH, Germany
//  Published under MIT License (Open Source License, see LICENSE.txt)
// #################################################################################################

/**
\page man_levelsanddomains          Log Levels, Log Domains and Log Domain Levels

\tableofcontents

This chapter provides all details on log levels and log domains. Before reading it, be sure that
you have read and understood the chapter \ref man_alox_architecture.

\note <b>Differences of ALox for C++, C# and Java</b>:<br>
      As ALox is available for C++, C# and Java, the class and member names within this document
      may vary a little per language. Especially the class **Log** has no interface in C++ while
      in C# and Java its' interface is a copy of that of class **Lox**, made for pruning the code.
      In contrast, in C++ the macros Log_xxx and Lox_xxx are used to provide pruned and non-pruned
      access to methods of class Lox. Please remember this, when reading this manual and translate
      the references used herein to the right ones of the language of your choice.


\~Comment ############################################################################################## \~
<br>
# 1. Log Levels# {#man_levelsanddomains_levels}

It is very common for logging eco-systems, and ALox is no exclamation to this, to implement the
concept of *log levels*. Such log level is provided either as a parameter to the log call or is
provided by offering different log methods, like *error()*, *warning()* or *verbose()* (or
both, as ALox does.)
The four levels offered are enumerated in
<b>Log.Level</b>
([C++] (@ref #aworx::lox::Log::Level),
 [C#]  (@ref #cs::aworx::lox::Log::Level),
 [JAVA](@ref #com::aworx::lox::Log::Level) )
and are named and sorted like this:
 - *Verbose*
 - *Info*
 - *Warning*
 - *Error*

The sorting of log levels means that if for example the log level '*Info*' is enabled, then all
log levels below '*Info*' ('*Warning*' and '*Error*') are also enabled. This way, changing the
log level changes the so called "verbosity" of your application. The higher the level setting
is, the more log messages will appear in the log.

\~Comment ############################################################################################## \~
<br>
# 2. Log Domains and Log Domain Levels # {#man_levelsanddomains_domains}

The ALox logging ecosystem differs from most others in the respect that log levels are not evaluated
against a global setting. Log levels are always evaluated in consideration of a specific *log domain*.

_Log domains_ are simple names (strings) that a developer specifies with a log statement.
In a kind, *log domains* specify a "topic" or "theme" to which that certain log statement
belongs to.
For example, those parts of a software that implement the user interface, could perform all
log statements using the log domain "UI", while the parts that read or write into a database
could be named "DBIO" or similar.

Now, ALox administers a setting for the log level per *log domain*. Such setting is called *log domain level*.
At runtime, for each log statement, the *log level* is evaluated against the *log domain level* and the log
message is either suppressed or not.

The *log domain levels* are enumerated in
<b>Log.DomainLevel</b>
([C++] (@ref #aworx::lox::Log::DomainLevel),
 [C#]  (@ref #cs::aworx::lox::Log::DomainLevel),
 [JAVA](@ref #com::aworx::lox::Log::DomainLevel) )
and are:

- *Off*
- *Errors*
- *WarningsAndErrors*
- *InfoWarningsAndErrors*
- *All*
- *Inherit*

This should be self explanatory, despite the last one, *Inherit*, which is explained in the
next section.

\~Comment ############################################################################################## \~
<br>
# 3. Hierarchical Log Domains # {#man_levelsanddomains_hierarchical_domains}


One of the major design goals of ALox is simplicity. By nature simplicity is sometimes in
in competition with flexibility or feature richness of an API. One way to resolve such conflicting
goals is to provide features that - if not wanted or needed or not even known -  are invisible to
the user. The concept of hierarchical log domains is a good sample of how this was achieved in the
ALox API design.

Domain names can incorporate a domain separator character '/' (alternatively '\\' or '|'). As long
as such domain names are used in the normal way, nothing changes. However, as soon as sub domains
are addressed (portions of domain names are given into the API), then the hierarchical domain
system internally takes action.

Let us look at a sample: The UI portion of an application might define three domains:
- "UI" for general UI messages
- "UI/MENU" for messages generated by user menu selections
- "UI/DLG" for messages generated by dialog boxes

The program code of the UI would register the three domains as follows (C# sample):

\snippet "UT_alox_usermanual.cs"        Man_LAD_3___1


(See
<b>Lox.SetDomain</b>
([C++] (@ref #aworx::lox::Lox::SetDomain(const TString&, Log::Scope)),
 [C#]  (@ref #cs::aworx::lox::Lox::SetDomain),
 [JAVA](@ref #com::aworx::lox::Lox::setDomain) )
for further reference.)

<br>
Now, without using the feature of hierarchical domains, the user code that controls
the level setting for the domains would set the level of the domains as follows:

\snippet "UT_alox_usermanual.cs"        Man_LAD_3___2

<em>(See
<b>Lox.SetDomain</b>
([C++] (@ref #aworx::lox::Lox::SetDomain),
 [C#]  (@ref #cs::aworx::lox::Lox::SetDomain),
 [JAVA](@ref #com::aworx::lox::Lox::setDomain) )
for further reference.) </em>

Due to the fact that the default value for the level setting of a domain is
<b>Log.DomainLevel.Inherit</b>
([C++] (@ref #aworx::lox::Log::DomainLevel),
 [C#]  (@ref #cs::aworx::lox::Log::DomainLevel),
 [JAVA](@ref #com::aworx::lox::Log::DomainLevel) ),
the two sub domains
of "UI" do not need to be set. They inherit the setting from their parent. It is
sufficient to set just the parent domain:

\snippet "UT_alox_usermanual.cs"        Man_LAD_3___3

In the case, that one of the sub domains should receive a different setting, then
this can be easily done applying a specific level to it:

\snippet "UT_alox_usermanual.cs"        Man_LAD_3___4

In this sample, the sub domain "UI/DLG" gets its own setting, while the sub domain "UI/MENU"
is still inheriting the setting from parent domain "UI".

The optional parameter \p propagation controls, if a level setting is recursively applied
to all sub domains. It defaults to
<b>%Propagation.ToDescendants</b>
([C++] (@ref #aworx::lib::enums::Propagation.ToDescendants),
 [C#]  (@ref #cs::aworx::lib::enums::Propagation.ToDescendants),
 [JAVA](@ref #com::aworx::lib::enums::Propagation.TO_DESCENDANTS) ),
Hence, the following code would set all three
domains to level *InfoWarningsAndErrors*:

\snippet "UT_alox_usermanual.cs"        Man_LAD_3___5

To prevent this, it is recommended to keep the right order of calls (parent domains first, as
in the previous sample)
or alternatively to specify the parameter \p propagation explicitly to false:

\snippet "UT_alox_usermanual.cs"        Man_LAD_3___6


The advantages of hierarchical domains so far are:
- You can control a whole set of domains with one statement
- If new versions of libraries provide new sub domains, their level setting is
  automatically controlled without explicitly adding a corresponding call to
  <em>Log.SetDomain()</em>.

But there is one more point on it, described later in this chapter. First let us
look at the root domain of a Logger.

\~Comment ############################################################################################## \~
<br>
# 4. The Root Domain of class Logger # {#man_levelsanddomains_root_domain}

As we have learned about the hierarchical organizations of domains, the next
concept is easy to understand. Each instance of class
<b>Logger</b>
([C++] (@ref #aworx::lox::core::Logger),
 [C#]  (@ref #cs::aworx::lox::core::Logger),
 [JAVA](@ref #com::aworx::lox::core::Logger) ),
contains a public field of
type
<b>Domain</b>
([C++] (@ref #aworx::lox::core::Domain),
 [C#]  (@ref #cs::aworx::lox::core::Domain),
 [JAVA](@ref #com::aworx::lox::core::Domain) ),
which represents the *root domain*. Whenever a new domain is registered with a Lox, each logger
contained in this Lox gets this domain added as a sub domain of its root domain.

Now, if the *domain level* of such sub domain is not specified (using
<b>Lox.SetDomain</b>
([C++] (@ref #aworx::lox::Lox::SetDomain),
 [C#]  (@ref #cs::aworx::lox::Lox::SetDomain),
 [JAVA](@ref #com::aworx::lox::Lox::setDomain) )
the setting defaults to "inherit" and hence these sub domains inherit the setting
of the root domain. Therefore, the level setting of a Loggers' root domain
determines the "default" domain level for "unknown" domains.

Different derivates of class Logger might have different preferences here. For
example:
- Class
  <b>ConsoleLogger</b>
  ([C++] (@ref #aworx::lox::loggers::ConsoleLogger),
   [C#]  (@ref #cs::aworx::lox::loggers::ConsoleLogger),
   [JAVA](@ref #com::aworx::lox::loggers::ConsoleLogger) ),
  in its constructor, sets the domain level of its root domain to
  <b>DomainLevel.All</b>
  ([C++] (@ref #aworx::lox::Log::DomainLevel),
   [C#]  (@ref #cs::aworx::lox::Log::DomainLevel),
   [JAVA](@ref #com::aworx::lox::Log::DomainLevel) ).
  This way, messages that get logged on domains that have not been explicitly set
  in the boot section of an application (or somewhere else) are displayed in the
  console. This makes sense, as the console is mainly for debug purposes. As soon as
  a log statement appears under a domain that is not set properly, the programmer can
  insert a corresponding statement to set the domain as wanted.

- In contrast to this, classes
  <b>TextFileLogger</b>
  ([C++] (@ref #aworx::lox::loggers::TextFileLogger),
   [C#]  (@ref #cs::aworx::lox::loggers::TextFileLogger),
   [JAVA](@ref #com::aworx::lox::loggers::TextFileLogger) ) or
  <b>MemoryLogger</b>
  ([C++] (@ref #aworx::lox::loggers::MemoryLogger),
   [C#]  (@ref #cs::aworx::lox::loggers::MemoryLogger),
   [JAVA](@ref #com::aworx::lox::loggers::MemoryLogger) ),
  when constructed, set its root domain to
  <b>DomainLevel.Off</b>
  ([C++] (@ref #aworx::lox::Log::DomainLevel),
   [C#]  (@ref #cs::aworx::lox::Log::DomainLevel),
   [JAVA](@ref #com::aworx::lox::Log::DomainLevel) ).
  This way, all log messages are suppressed unless explicitly set active.

To change this default behavior, use method
<b>Lox.SetDomain</b>
  ([C++] (@ref #aworx::lox::Lox::SetDomain),
   [C#]  (@ref #cs::aworx::lox::Lox::SetDomain),
   [JAVA](@ref #com::aworx::lox::Lox::setDomain) ) on domain name "/"
 and provide the right logger name in the filter parameter. For example, if you
 want to see only *warning* and *error* messages for domains that are not explicitly
 set, insert the following code right after a logger is added:

\snippet "UT_alox_usermanual.cs"        Man_LAD_4___1

In this line of code, we are using the interface method of class \b Lox (in fact, the debug logging
version \b Log) and we are filtering the logger we want to change.  This is the standard approach.
If we are dealing with a logger that is not attached to a \b Lox yet (or for any other reason), it
is also possible to change the domain level of any domain directly in a logger, even before
adding a logger to a \b Lox:

\snippet "UT_alox_usermanual.cs"        Man_LAD_4___2

This is what is happening:
- By default, loggers of type \b TextFileLogger set the level of their root domain to \e Off.
- Therefore, the \b TextFileLogger is quiet after it is created. Even internal ALox errors and
  warnings got switched off.
- When certain things happen, we activate the domain "MYAPP/DATABASE" to gather information
  about errors that occur in our applications' database code. As we are hunting some misbehaviour,
  we are activating log level \e Info netxt to \e Error and \e Warning.


\~Comment ############################################################################################## \~
<br>
# 5. Default Domains # {#man_levelsanddomains_default_domains}

People might argue that providing a domain name to each log statement is an overhead of
typing. That is true. For this reason - and to get even more benefits - ALox provides the concept
of *default domains*.

Domains, when registered, can be set as the default domain for a given
[Log.Scope](@ref #com.aworx.lox.Log.Scope).
Unfortunately but naturally, the possible values for the scope are platform/language dependent.
For example, in Java, the scope can be the whole package a class resides in, the class only or
just a single method of a class. In C#, the scope can be the actual source file or the
actual method within a source file. Namespaces can not be the scope in C#, due to restrictions
in the way that *caller information* is collected.

Now, setting a domain as default is done by specifying a scope value other than
<em>None</em> to
<b>Lox.SetDomain</b>
([C++] (@ref #aworx::lox::Lox::SetDomain(const TString&, Log::Scope)),
 [C#]  (@ref #cs::aworx::lox::Lox::SetDomain),
 [JAVA](@ref #com::aworx::lox::Lox::setDomain) )

\snippet "UT_alox_usermanual.cs"        Man_LAD_5___1

This sets the domain "UI" as the default domain for this source file. As a result, the
following two log statements are equal:

\snippet "UT_alox_usermanual.cs"        Man_LAD_5___2

In other words: If no domain name is given, the last recently registered default domain
name for is used.

If a log statement is placed within two scopes at the same time (e.g.
Method and SoruceFile) then the inner scopes have higher preference than outer scopes.

The advantage of using default domains are:
- less typing and better readability
- the domain name can be changed in one place
- copy and pasting code into different "domains" does not involve updating the domain
  name in each log statement.

It is not an error to register a domain twice. For example, if a domain should
become the default domain for two different scopes, then for each scope a corresponding
call to SetDomain can be placed at appropriate locations in the code.

In general, the use of domain names is handled very uncritically by ALox. If a
domain is used without prior registering, an internal warning message is logged, but the
domain is just created on the fly and everything works nicely. On the other hand,
registering a domain several times does not hurt.
It is a good practice to avoid multiple registrations of domains for the same scope
and the tutorials for the different languages that ALox support describe how this
is done:

- For C#, see tutorial chapter \ref tutcs_llld_3.


\~Comment ############################################################################################## \~
<br>
# 6. Default Domains and Domain Hierarchy # {#man_levelsanddomains_hierarchical_default_domains}

Let us look at the sample from above once more:

\snippet "UT_alox_usermanual.cs"        Man_LAD_6___1

Now, as we have our root domain "UI" set up as the default domain, we can address the
sub domains using the '~' symbol. The following two log statements become are equal:

\snippet "UT_alox_usermanual.cs"        Man_LAD_6___2

The benefits are the same as above:

- less typing and better readability
- the domain name can be changed in one place
- copy and pasting code into different "domains" does not involve updating the domain
  name in each log statement, as long as the same sub domain names are wanted.



\~Comment ############################################################################################## \~
<br>
# 7. The Internal Domain "ALOX" # {#man_levelsanddomains_internal_domain}

Now, let us have a look at internal log messages coming from the ALox ecosystem itself and how their
domain level can be controlled. This is quite easy and straightforward.

ALox uses a domain called "ALOX" to log internal. This name is not hard coded, but represented
in a field in class
<b>Lox.</b>
([C++] (@ref #aworx::lox::Lox),
 [C#]  (@ref #cs::aworx::lox::Lox),
 [JAVA](@ref #com::aworx::lox::Lox) ).
E.g. in C#, this field
is called [Lox.InternalDomain](@ref #cs.aworx.lox.Lox.InternalDomain).
If you want to change the internal domain name, you go ahead as follows:

\snippet "UT_alox_usermanual.cs"        Man_LAD_7___1

If you want to change it for the static singleton Lox encapsulated in class Log, the code is:

\snippet "UT_alox_usermanual.cs"        Man_LAD_7___2

More interesting is of course to enable or disable the domain for certain loggers. Again, console loggers
that are enabled for debug messages of your software might want to show all internal messages, while
distinct derivates of loggers, especially release loggers, might not.

The API request this internal domain's log level to be specified in the moment a logger
is added to the log. See parameter <em>internalDomainLevel</em> in
<b>Lox.AddLogger</b>
([C++] (@ref #aworx::lox::Lox::AddLogger),
 [C#]  (@ref #cs::aworx::lox::Lox::AddLogger),
 [JAVA](@ref #com::aworx::lox::Lox::addLogger) ).

Of course, the domain level of the internal domain can be manipulated
like any other domains <em>Log/Lox.SetDomain()</em>.
The code would look like this:

\snippet "UT_alox_usermanual.cs"        Man_LAD_7___3

In the moment a \b Logger gets added to a \b Lox, the method checks whether the internal domain is
already registered with the given logger. If not, it is registered and set to domain level
\b WarningsAndErrors.
This means, that it does not play a role, if changes to the level of domain "ALOX" are performed
prior to adding a logger (using
<b>Logger.SetDomain</b>
([C++] (@ref #aworx::lox::core::Logger::SetDomain),
 [C#]  (@ref #cs::aworx::lox::core::Logger::SetDomain),
 [JAVA](@ref #com::aworx::lox::core::Logger::setDomain) ) ) or after a logger was added (using
<b>Lox.SetDomain</b>
([C++] (@ref #aworx::lox::Lox::SetDomain),
 [C#]  (@ref #cs::aworx::lox::Lox::SetDomain),
 [JAVA](@ref #com::aworx::lox::Lox::setDomain) ) ).


\~Comment ############################################################################################## \~
<br>
# 8. Setting Different Domain Levels on Different Loggers # {#man_levelsanddomains_separating_loggers}

We want to end this chapter, with another very important feature that the ALox logging ecosystem just
"provides by design": The concept of matching *log levels* against *log domains* does not only allow
us to configure the verbosity of the log output per domain. In addition, because of the simple fact
that the *domain log level* setting is stored per *Logger* and not globally, ALox can be configured
to have different loggers logging completely different things.

As we have already seen a source sample of that provided in the tutorials (see section
<em>Directing log output to distinct loggers</em>:
  [C++](@ref tutcpp_more_seplog),
  [C#](@ref tutcs_more_seplog),
  [Java](@ref tutjava_more_seplog)),
we want to give now a more formal description on how this is achieved:

- Create and add your loggers using <b>AddLogger</b>
- For each **log domain** with log output that should go to all loggers invoke
  <b>SetDomain</b> without specifying the parameter <b>loggerFilter</b>
- For each <b>log domain</b> with a log output that should go exclusively to a certain logger (or a set of
  loggers) go ahead and:
  - for each logger, that should receive the domains' log messages, invoke <b>SetDomain</b>
    and specify the parameter <b>loggerFilter</b> to address the according logger by name. For these loggers set the
    parameter domainLevel to your desired verbosity.
  - for each logger, that should **not** receive the domains' log messages, invoke **SetDomain**
    and specify the parameter **loggerFilter** to address the according logger by name. For these loggers set the
    parameter domainLevel to **DomainLevel.Off**.

This probably sounds more complex than it is. If you think about it for a second, it should become obvious.

This mechanism allows for example to redirect all logs coming from an external library (or a different
department in your company or just a portion of code that you  are currently not interested in) maybe
together with your logs into a file, while on the debug console you see exclusively the things
that bother your right now.

Or, as another example, you could consider a logger that sends alert emails to you. Of-course, you just
want to receive such mails on very special occasions, e.g. something really severe happens.


\~Comment ############################################################################################## \~
<br>
# 9. Summary # {#man_levelsanddomains_summary}

Okay, this was quite a bunch of things that we need to know about *log levels* and corresponding *log domains* and
their *log domain levels*.<br>
So, let us summarize the takeaways of this chapter and repeat quickly what we learned:


- Each log call is related to a certain *log domain*.
- The log levels *Error*, *Warning*, *Info*, *Verbose* of each log call determine how they get filtered
  according to the *log domain level* of the domain that a log call specifies.
- Log domains are hierarchically organized and domain levels can be inherited through this hierarchy.
- Log domains are attached to Loggers and hence can be controlled per Logger.
- Each logger has a *root domain*. Due to the inheritance feature of the *domain level*, this root domains's level
  determines the level of "unknown" domains (domains that have not been set or registered during the lifetime of the logger).
- It is possible to set a default domain for a certain scope.
- Using the swung dash character "~" allows to address sub domains of default domains.
- class Lox has an own domain "ALOX" for internal messages.
- The parameter *loggerFilter* of method *Log.SetDomain()* allows to separate log messages of certain log domains
  into different log streams.

<p>

--------------------------------------------------------------------
Next chapter: \ref man_loggers

*/
