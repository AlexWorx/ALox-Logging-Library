// #################################################################################################
//  Documentation - ALox Logging Library
//
//  (c) 2013-2016 A-Worx GmbH, Germany
//  Published under MIT License (Open Source License, see LICENSE.txt)
// #################################################################################################

/**
\page man_alox_architecture         Overview of the ALox architecture

\tableofcontents

\note <b>Differences of ALox for C++, C# and Java</b>:<br>
      As ALox is available for C++, C# and Java, the class and member names within this document
      may vary a little per language. Especially the class **Log** has no interface in C++ while
      in C# and Java its' interface is a copy of that of class **Lox**, made for pruning the code.
      In contrast, in C++ the macros Log_xxx and Lox_xxx are used to provide pruned and non-pruned
      access to methods of class Lox. Please remember this, when reading this manual and translate
      the references used herein to the right ones of the language of your choice.

# 1. Namespaces # {#man_architecture_namespaces}

The implementation parts of the ALox Library are split into different namespaces
(in Java called "packages"). A design principle of namespaces in ALox is that the relationship
between namespaces is not bidirectional. This means that if one class in a namespace A inherits
or uses a class in a namespace B, then there is no reference from (any) class namespace B
into namespace A.
You can say here that "if A knows B" then "B does not know A".

Lets start with two namespaces:

- <b>\[java.|cs.\]%aworx.lox</b>
  ([C++](@ref #aworx::lox),
  [C#]  (@ref #cs::aworx::lox),
  [JAVA](@ref #com::aworx::lox) )<br>
  This is the main and basic namespace of ALox. The central class is
  <b>Lox</b>
  ([C++] (@ref #aworx::lox::Lox),
   [C#]  (@ref #cs::aworx::lox::Lox),
   [JAVA](@ref #com::aworx::lox::Lox)),
  which acts as a container for the loggers, manages a set of different settings and
  provides the user interface (API) into ALox logging.<br>

- <b>\[java.|cs.\]%aworx.lox.core</b>
 ([C++](@ref #aworx::lox::core),
 [C#]  (@ref #cs::aworx::lox::core),
 [JAVA](@ref #com::aworx::lox::core) ) <br>
  As the name says, within this namespace (package) you will find the core classes needed for
  logging. Besides the abstract class
  <b>Logger</b>
  ([C++] (@ref #aworx::lox::core::Logger),
   [C#]  (@ref #cs::aworx::lox::core::Logger),
   [JAVA](@ref #com::aworx::lox::core::Logger)),
  there are classes that
  care about internal things like caller information or log domains. <br>
  In addition, utility classes for certain logger types are located here
  (currently for *TextLoggers*, probably more to come in the future).
  A normal user of the ALox Logging Library would not use classes of this namespace directly.


Now, namespace <b>%aworx.lox</b> knows namespace <b>%aworx.lox.core</b>, but not vice versa:

\dot
digraph G
{
    node [shape=plaintext, fontsize="10", fontname="Courier"]

    lox     [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>aworx.lox</b></TD></TR>
                           <TR><TD                              >class Lox</TD></TR>
                           <TR><TD                              >class Log</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    core    [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>aworx.lox.core</b></TD></TR>
                           <TR><TD                              >class Domain</TD></TR>
                           <TR><TD                              >class CallerInfo</TD></TR>
                           <TR><TD                              >class Logger</TD></TR>
                           <TR><TD                              >class TextLogger</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    lox -> core     [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
}
\enddot

A third namespace is:
- <b>\[java.|cs.\]%aworx.lox.loggers</b>
 ([C++](@ref #aworx::lox::loggers),
 [C#]  (@ref #cs::aworx::lox::loggers),
 [JAVA](@ref #com::aworx::lox::loggers) ) <br>
This namespace provide ready to use *Logger* types, e.g.
  <b>ConsoleLogger</b>
  ([C++] (@ref #aworx::lox::loggers::ConsoleLogger),
   [C#]  (@ref #cs::aworx::lox::loggers::ConsoleLogger),
   [JAVA](@ref #com::aworx::lox::loggers::ConsoleLogger)), or
  <b>MemoryLogger</b>
  ([C++] (@ref #aworx::lox::loggers::MemoryLogger),
   [C#]  (@ref #cs::aworx::lox::loggers::MemoryLogger),
   [JAVA](@ref #com::aworx::lox::loggers::MemoryLogger)).

Neither <b>%aworx.lox.core</b> nor <b>%aworx.lox</b> know about this namespace. Of-course, <b>%aworx.lox.loggers</b> knows
about <b>%aworx.lox.core</b>.
This makes sense, because instances of *Lox* get instances of abstract type *Logger* attached.
All that class *Lox* knows is that they are derived from class *Logger* in namespace *aworx.lox.core*.
This allows you to create your own loggers.

Let's imagine you are using ALox from within your own namespace *yournamespace* and you have
created your own *Logger* class, residing in namespace *yourloggers*.
This then looks as follows:


\dot
digraph G
{
    node [shape=plaintext, fontsize="10", fontname="Courier"]

    core    [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>aworx.lox.core</b></TD></TR>
                           <TR><TD                              >class Domain</TD></TR>
                           <TR><TD                              >class CallerInfo</TD></TR>
                           <TR><TD                              >class Logger</TD></TR>
                           <TR><TD                              >class TextLogger</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    lox     [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>aworx.lox</b></TD></TR>
                           <TR><TD                              >class Lox</TD></TR>
                           <TR><TD                              >class Log</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    loggers [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>aworx.lox.loggers</b></TD></TR>
                           <TR><TD                              >class ConsoleLogger</TD></TR>
                           <TR><TD                              >class MemoryLogger</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    yournamespace [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b><font color="blue">yournamespace</font></b></TD></TR>
                           <TR><TD                              >class YourClass</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    yourloggers   [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b><font color="blue">yourloggers</font></b></TD></TR>
                           <TR><TD                              >class YourLogger</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];


    lox             -> core          [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    loggers         -> core          [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    yournamespace   -> lox           [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    yournamespace   -> loggers       [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    yournamespace   -> yourloggers   [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    yourloggers     -> loggers       [label= " probably knows" arrowhead="open",  fontsize="10", fontname="Helvetica", style="dashed"];
    yourloggers     -> core          [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
}
\enddot

Besides understanding a little about the namespaces strategy of ALox, a simple takeaway from this
is that you need to make namespaces <b>%aworx.lox</b> and <b>%aworx.lox.loggers</b> available to your
code, but not <b>%aworx.lox.core</b>
(only when you want to create your own, custom loggers),

Finally, there is a "underlying" namespace called <b>%aworx.lib</b>. This is pure, basic
utility code. Some of the classes are just faster versions (more Bauhaus!) than equivalent
existing system classes. Others do exist only to enable ALox code to look the same
across languages and platforms. Of-course, you can read the reference documentation
and you might use them somewhere, but this is not what we intended here. There are many
other libraries existing that are much more complete and standard. Again, we are building upon
them, only because we really think it makes our life easier in respect to porting ALox
and because it makes your logging life just faster.

As you might guess, all other packages are built on <b>%aworx.lib</b>, so the graph is:


\dot
digraph G
{
    node [shape=plaintext, fontsize="10", fontname="Courier"]

    core    [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx.lox.core</b></TD></TR>
                           <TR><TD                              >class Domain</TD></TR>
                           <TR><TD                              >class CallerInfo</TD></TR>
                           <TR><TD                              >class Logger</TD></TR>
                           <TR><TD                              >class TextLogger</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    lox     [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx.lox</b></TD></TR>
                           <TR><TD                              >class Lox</TD></TR>
                           <TR><TD                              >class Log</TD></TR>
                           <TR><TD                              >class LogTools</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    loggers [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx.lox.loggers</b></TD></TR>
                           <TR><TD                              >class ConsoleLogger</TD></TR>
                           <TR><TD                              >class MemoryLogger</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];

    util [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
                           <TR><TD PORT="first" BGCOLOR="gray"  ><b>com.aworx</b></TD></TR>
                           <TR><TD                              >class AString</TD></TR>
                           <TR><TD                              >class TickTime</TD></TR>
                           <TR><TD                              >class ThreadLock</TD></TR>
                           <TR><TD                              >...</TD></TR>
              </TABLE>>];


    lox             -> core     [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    loggers         -> core     [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    lox             -> util     [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    loggers         -> util     [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
    core            -> util     [label= " knows" arrowhead="open",  fontsize="10", fontname="Helvetica"];
}
\enddot

\note
Every rule has an exclamation, so we admit: we broke the "if A knows B" then "B does not know A" rule
intentionally by adding the enums
-  <b>Log.Level</b>
  ([C++] (@ref #aworx::lox::Log.Level),
   [C#]  (@ref #cs::aworx::lox::Log.Level),
   [JAVA](@ref #com::aworx::lox::Log.Level)),
-  <b>Log.DomainLevel</b>
  ([C++] (@ref #aworx::lox::Log.DomainLevel),
   [C#]  (@ref #cs::aworx::lox::Log.DomainLevel),
   [JAVA](@ref #com::aworx::lox::Log.DomainLevel)) and
-  <b>Log.Scope</b>
  ([C++] (@ref #aworx::lox::Log.Scope),
   [C#]  (@ref #cs::aworx::lox::Log.Scope),
   [JAVA](@ref #com::aworx::lox::Log.Scope))<br>

\note to class *Log* in namespace <b>%aworx.lox</b>. They absolutely should
not be there but rather be in <b>%aworx.lox.core</b>.<br>
But the advantage of doing this was too tempting that we broke the rule.
We did it just for the reason that your code should look nice when you use ALox.




# 2. Loggers # {#man_architecture_logger}

ALox is designed to support different log streams. A log stream is a destination of log messages
and can be the IDE console, the terminal console, a file, a web service or anything that accepts
data streams. The abstract class
<b>Logger</b>
  ([C++] (@ref #aworx::lox::core::Logger),
   [C#]  (@ref #cs::aworx::lox::core::Logger),
   [JAVA](@ref #com::aworx::lox::core::Logger))
represents such a log stream. While some implementations of class Logger are provided with the ALox package,
the system allows custom implementations of Loggers that log information to any 'data drain' in
any format you like.

\dot
digraph logger
{
    node [shape=record, fontname=Courier,   fontsize=12];
    edge [shape=record, fontname=Helvetica, fontsize=10];
    logger  [ label="Logger"            URL="\ref com.aworx.lox.core.Logger"];
    cl      [ label="ConsoleLogger"     URL="\ref com.aworx.lox.loggers.ConsoleLogger"];
    ml      [ label="Memory Logger"     URL="\ref com.aworx.lox.loggers.MemoryLogger"];
    my      [ label="My Custom Logger"  ];
    cl -> logger  [ label= "extends" arrowhead="open", style="dashed", URL="\ref cs.aworx.lox.Lox.AddLogger" ];
    ml -> logger  [ label= "extends" arrowhead="open", style="dashed", URL="\ref cs.aworx.lox.Lox.AddLogger" ];
    my -> logger  [ label= "extends" arrowhead="open", style="dashed", URL="\ref cs.aworx.lox.Lox.AddLogger" ];
}
\enddot

An application that supports different loggers at once, might decide to log only a subset
of the log messages to each of the loggers. To achieve this, each Logger allows to configure
log domain levels separately. The same log domain can be enabled in one Logger, but disabled
in another Logger.

(For more information see chapter \ref man_loggers.)


# 3. Lox - Managing Loggers # {#man_architecture_lox}

The interface of class Logger is very basic and not intended to be used directly to perform any
logging. Furthermore, if one log message should go to more than one Logger, then each logger would have
to be invoked.<br>
To achieve both (have a convenient interface and dispatch log messages to more than one Logger), ALox
provides class
<b>Lox</b>
  ([C++] (@ref #aworx::lox::Lox),
   [C#]  (@ref #cs::aworx::lox::Lox),
   [JAVA](@ref #com::aworx::lox::Lox)).
This class acts as a container for all Loggers that
are created during the lifecycle of an application. In rare cases of complex logging scenarios, even
multiple instances of that class might be created with different Loggers contained.

\dot
digraph example
{
    node [shape=record, fontname=Courier,   fontsize=12];
    edge [shape=record, fontname=Helvetica, fontsize=10];
    lox [ label="Lox"       URL="\ref com.aworx.lox.Lox"];
    cl [ label="ConsoleLogger"    URL="\ref com.aworx.lox.core.Logger"];
    ml [ label="Memory Logger"    URL="\ref com.aworx.lox.core.Logger"];
    lox -> cl  [ label= "contains" arrowhead="open",  URL="\ref cs.aworx.lox.Lox.AddLogger" ];
    lox -> ml  [ label= "contains" arrowhead="open",  URL="\ref cs.aworx.lox.Lox.AddLogger" ];
}
\enddot

Various methods of class Lox provide an optional parameter to filter the command to certain Loggers
only. The standard use of such filters is to apply different log domain settings to different Loggers
contained in the Lox instance. Once the domain levels are properly set, log messages are automatically
appearing in the right loggers (none, some or all) depending on the log domain and log level specified in
the log statement. However, there is also the possibility to filter log statements directly against Logger
names. For standard scenarios this is not recommended, because the flexibility to add new Loggers
(for new log formats or log message data drains) might be lost.


# 4. Log - Debug Logging # {#man_architecture_log}

There are two fundamental logging scenarios that we call **debug logging** and **release logging**.
(For information, see \ref faq_debug_vs_release_logging.)

For various reasons (performance, code size, security, etc), debug log statements should be disabled
and removed (pruned) from the release version of a software.

To achieve all goals and provide a very simple interface into debug logging, the ALox ecosystem
provides class
<b>Log</b>
  ([C++] (@ref #aworx::lox::Log),
   [C#]  (@ref #cs::aworx::lox::Log),
   [JAVA](@ref #com::aworx::lox::Log))
This class is a 100% static interface into
class Lox. In other words, class Log creates and holds exactly one static instance of class Lox and
mimics the complete interface of that instance into corresponding static methods.

\dot
digraph example
{
    node [shape=record, fontname=Courier,   fontsize=12];
    edge [shape=record, fontname=Helvetica, fontsize=10];
    log  [ label="{Log|1:1 static prunable interface into Lox}"     URL="\ref cs.aworx.lox.Lox"];
    lox  [ label="Lox"                                              URL="\ref cs.aworx.lox.Lox"];
    cl   [ label="ConsoleLogger"                                    URL="\ref cs.aworx.lox.core.Logger"];
    ml   [ label="MemoryLogger"                                     URL="\ref cs.aworx.lox.core.Logger"];
    xyzl [ label="XYZLogger"                                        URL="\ref cs.aworx.lox.core.Logger"];
    log -> lox  [ label= "Contains 1 singleton" arrowhead="open", style="solid", URL="\ref cs.aworx.lox.Lox.AddLogger" ];
    lox -> cl   [ label= "contains" arrowhead="open",               URL="\ref cs.aworx.lox.Lox.AddLogger" ];
    lox -> ml   [ label= "contains" arrowhead="open",               URL="\ref cs.aworx.lox.Lox.AddLogger" ];
    lox -> xyzl [ label= "contains" arrowhead="open",               URL="\ref cs.aworx.lox.Lox.AddLogger" ];
}
\enddot

The assumption (restriction) that is taken here, is that debug logging is implemented by using
only one Lox. This should be sufficient for most scenarios, because, as described above, within that Lox
instance various Loggers with own log domain settings will provide a lot of flexibility to log different
types of messages within a complex software into different streams and manipulate the verbosity for
each stream accordingly.

\note The aforementioned things said about class **Lox** are a little different in the C++ version
      of ALox. To quickly summarize the differences:
      - class *Log* in C++ does not mimic the interface of class *Lox*. Instead, debug as well as
        release logging use preprocessor macros to access the interface of class Lox.
      - the static singleton for debug logging can be replaced in single code units. In addition,
        for convenience, the C++ version also provides a ready to use singleton of class *Lox* for
        release logging.<p>
\note For more details on pruning and the use of class *Log*, consult the language specific
      documentation:
      [C++] (@ref cppprepro_macros),
      [C#]  (@ref cspruning) and
      [Java](@ref javasetup_pruning).


# 5. Summary # {#man_architecture_summary}

The following summarizes the takeaways of this chapter:
- ALox is organized namespaces, where at least two of them need to be referenced in your ALox
  enabled code, namely <b>%aworx.lox</b> and <b>%aworx.lox.loggers</b>.

- To implement own log data streams (data drains to log into, like databases, web services, etc.)
  and your own log formats, custom implementations of class
  <b>Logger</b>
  ([C++] (@ref #aworx::lox::core::Logger),
   [C#]  (@ref #cs::aworx::lox::core::Logger),
   [JAVA](@ref #com::aworx::lox::core::Logger)),
  can be created.

- For debug logging, in C# and Java versions, class
  <b>Log</b>
  ([C++] (@ref #aworx::lox::Log),
   [C#]  (@ref #cs::aworx::lox::Log),
   [JAVA](@ref #com::aworx::lox::Log))
  is the right interface in ALox (and an extremely simple way as well).
  All invocations related to class Log get easily pruned from your code.<br>
  In C++, pruning is performed using [preprocessor macros](@ref cppprepro_macros).

- To implement release logging (e.g. to send error states or usage info of a mobile app to a server)
  an instance of class
  <b>Lox</b>
  ([C++] (@ref #aworx::lox::Lox),
   [C#]  (@ref #cs::aworx::lox::Lox),
   [JAVA](@ref #com::aworx::lox::Lox))
  is used. The interface into the *Lox* is almost 100% the same as the interface
  of class **Log**(@ref #com.aworx.lox.Log) which is used for debug logging.<br>
  (Again, in C++ this is a little different, here the macros that provide the interface into
   ALox are named Log_xxx for debug logging and Lox_xxx for release logging. Hence, the
   logging statements look very similar in C++, C# and Java versions of ALox.)

<p>

--------------------------------------------------------------------
Next chapter: \ref man_levelsanddomains

*/
