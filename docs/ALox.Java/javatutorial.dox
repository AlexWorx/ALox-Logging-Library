// #################################################################################################
//  Documentation - ALox Logging Library
//
//  Copyright 2013-2019 A-Worx GmbH, Germany
//  Published under 'Boost Software License' (a free software license, see LICENSE.txt)
// #################################################################################################

/**
\page alox_java_tutorial       ALox for Java Tutorial


\tableofcontents

# 1. Hello ALox # {#alox_java_tut_hello_alox}

Welcome to the ALox for Java tutorial! This tutorial aims to introduce you to ALox as quickly as
possible and put you into a position to decide whether ALox is the right logging library for you.

Let us start with the very quick "hello world" sample:

\snippet HelloALox.java       Tut_Minimum_Hello

When this method gets invoked, the output should look similar to this

       (HelloALox.java:7) sayHello():[00:00.000 +167 Âµs] [main]       [/] (001): Hello ALox!

So, with one line of code we get a <em>Log Statement</em> that incorporates:
- The source file, line number and method, which - depending on the IDE you use - is 'clickable' which
  means a click in the output window opens the source file and highlights the line where the
  <em>Log Statement</em> sits.
- The time that passed since the process started (here 00:00.000 which means below a millisecond)
- The time that passed since the last log line: 167 microseconds. This information is handy for
  a first impression on the execution speed of your methods.
- The name of the thread executing the log (automatically identified as the main thread in this case)
- <c>[/]</c>: to be explained later...
- The log counter (001), which e.g. is useful to quickly find the right output lines in your next
  debug-run.
- Finally the log message itself.

And: In the release build of your software, this line of code is completely pruned away.
Because, as we see later, also in debug versions you can disable log output selectively, with
ALox you can keep your debug <em>Log Statements</em> in your code forever!

Let us quickly start a new chapter of this tutorial and go into more details.

\~Comment ####################################################################################### \~
# 2. Classes Log and Lox # {#alox_java_tut_lox}
The previous chapter was a teaser. We showed the shortest possible sample program which does not
'bootstrap' ALox (aka initialize and configure). This is detected and hence ALox tries to setup
itself with reasonable default options.

ALox has some concepts that need a little more time to understand.
Before we see more code, we have to take some prerequisites.

ALox is designed to support <b>debug logging</b> (log output that should appear only in the debug version of your software) as well
as <b>release logging</b>. In Java such pruning is done using an 'obfuscator' tool and ALox
provides ready to use configuration files and a tutorial on how to use one of the best of its kind.

We want you to understand a little of the class design of ALox, while you
are reading yourself through this tutorial. Some first general notes:

- The most important interface into ALox is class
[Lox](@ref #com::aworx::lox::Lox) which is is a container to hold one or more instances of abstract class
[Logger](@ref #com::aworx::lox::detail::Logger). Through the interface of class *Lox*, the <em>Log Statements</em> are invoked.
Log statements are forwarded to the \e Loggers attached.

- The most simple case is that you have just one \b Lox instance, holding exactly one \e %Logger which logs its output to the
standard output stream of your process (e.g. [AnsiConsoleLogger](@ref #com::aworx::lox::loggers::AnsiConsoleLogger)).
In this tutorial we stick to the simpler cases, maybe adding a second \e Logger here and there.

- Most of the methods that we are using here are invoked on class
  [Log](@ref #com::aworx::lox::Log) instead of class \b Lox. This class is a 'mirror' class of
  \b Lox, a kind of fake class that mimics the interface but internally just calls the original
  methods on a dedicated \b Lox singleton which is used for debug logging. Therefore,

        Log.info( "Hello ALox" )

  means that method
  [info](@ref #com::aworx::lox::Lox::info) is invoked on the predefined singleton of class \b Lox which
  is by default used for debug logging.
  (Class \b Log and any reference on it gets pruned with release versions.)


\~Comment ####################################################################################### \~
# 3 Create a tutorial project or equip your current project with ALox #   {#alox_java_tut_createproject}

If you want to follow the tutorial samples and play around with them a little, you should
either create a tutorial project or right away equip your current project with ALox.
For information about how you do that see: \ref alox_java_setup.

\note
  Of-course, you can easily skip this step and just continue \e reading the tutorial
  without setting up ALox now. For some IDEs, there might be a
  \ref alox_java_setup "ready to use solution" available that minimizes efforts when you want
  to follow the samples and play around a little.

To have all packages for this tutorial set up, add the following lines to the start of
your source file:

\snippet UT_dox_tutorial.java        Tut_using_statement


\~Comment ####################################################################################### \~
# 4. Class Logger #  {#alox_java_tut_logger}

While class \b %Lox is the main interface to ALox logging, abstract class
\ref com::aworx::lox::detail::Logger  "Logger" is performing the log. 'Performing' here means that
derived instances of this abstract class are responsible for writing the \e 'Logables' (the message
or data that is logged) to a 'drain', for example the console or a text file.

Before we can start logging, we need to create one or more \e %Loggers and attach them to
our instance of class \b %Lox.

\note
  In the shortest sample shown above (\ref alox_java_tut_hello_alox  "Hello ALox") we have not done this. For debug
  logging ALox notices this and automatically creates a \e %Logger.


You need to identify the right place in your application where to do this.
A good place is the "main()" method or any other place of your project where some "bootstrapping"
of your application takes place.
Add the following line:

\snippet UT_dox_tutorial.java        Tut_ALox_Logger_1

This tries to identify the best \e Logger type that fits to your console type.
E.g. If the process runs on an ANSI enabled console
or a console window on Windows OS, colorful log output is enabled. Sometimes, this method even
creates two \e Loggers: one for the console and one for your IDE output, when ALox is able to
detect and support such IDE.<br>
For information about what is currently supported and how (with environment variables,
configuration files or command line parameters) this behavior can be changed, see methods
[Log::addDebugLogger](@ref #com::aworx::lox::Log::addDebugLogger) and
[Lox::createConsoleLogger](@ref #com::aworx::lox::Lox::createConsoleLogger).

We never interface with a \c Logger directly. After it is created and added to the \c Lox, we
can mostly forget about it.
For almost all the rest of this introductory tutorial, all you
need to know is that \e Loggers created with this method, write
log messages in textual format e.g. to standard output stream (and/or to the application console).
As said above, other \e Loggers could be added in parallel that use other "drains" to write the
output to, e.g. files, a metrics server in the cloud, etc.

\note
  For Android developers: To stream ALox logging into LogCat create a \e Logger of type
  [AndroidLogCatLogger](@ref com.aworx.lox.android.AndroidLogCatLogger)
  instead of type [ConsoleLogger](@ref com.aworx.lox.loggers.ConsoleLogger) as follows:
  \code{.java}
    Log.setVerbosity( new AndroidLogCatLogger("LogCat"), Verbosity.VERBOSE );
  \endcode
  The normal [ConsoleLogger](@ref com.aworx.lox.loggers.ConsoleLogger) would not produce any
  visible output using the Android Emulator or a debugging device.<br>

Together with the <em>Log Statement</em> of the first introductory sample, your projects code (e.g. in method \c main)
should look like this:

\snippet UT_dox_tutorial.java        Tut_ALox_Logger_2

\~Comment ####################################################################################### \~
# 5. Run the Application #  {#alox_java_tut_run}

When you run your project, output similar to this:

\verbinclude ALox.Java/generated/Tut_ALox_Logger.txt

should appear in your IDE or your console.

\note
  From the meta information of the log output above you can see, that this tutorial has its
  sample code embedded in unit tests and the output is captured when running them and inserted
  here.

\~Comment ####################################################################################### \~
## 5.2. Run your application within your IDE ##        {#alox_java_tut_run_ide}

If you are using an IDE supported by ALox (e.g. Eclipse), you can double click the log line in the output
window. The IDE  opens the source and selects the line of code where the log call was invoked.
This means, each <em>Log Statement</em> is "clickable" in your IDE and links to its source code line in the
editor. This is a tremendous help for developers when debugging their code.

Besides the fact that you can click it, users of ALox are saving even more time. Developers, when
using standard "debug print lines", often phrase textual info like:

        "attn: dbman.savedata(): oops could not store data....ERROR!"

hence, putting some info about the place in the code, where they have put the debug statements. As you see from the
ALox output above, information about the *caller* of the <em>Log Statement</em> is all included automatically.
Advantages are:

- lines are clickable and link to the editor (because ALox formats the scope information accordingly)
- less to type when adding debug print lines
- no need to change the <em>Log Statement</em> when you copy/paste a debug print line to a different class/method
  or when you rename your class/method

Furthermore, as we will see later, the log message type (which seems to be "ERROR!" in the phrase above) is standardized
in ALox and does not need to be phrased in your message text.

Besides scope information and message type, you automatically get:

- the relative time of the log execution (time since application started)
- the time elapsed since the last log
- the ID of the thread that executed the method

The output format and detail of the log line is configurable in ALox. The line above just shows
the default. Details you see can be removed or other details can be added (e.g. the absolute
date / time instead of only the relative).

\note Should your IDE not be supported by ALox in respect to generate "clickable log output lines" (aka lines that
link automatically to the right point in your source code) it might be the case that only by adjusting
the log output format a little, your IDE learns how to read and interpret ALox logging!
<p>

\note
You should adjust your Java IDE in a way that the console window spans over the complete
width of the main window. Also, depending on your screen size, you might decrease the font size of
the output window a little. The output gets wide, because a lot of valuable information is logged
besides the log message. In addition, the output is organized in columns that auto adjust their size.
This takes a wider output into account for the  benefit of largely improved readability.


\~Comment ####################################################################################### \~
## 5.2. A quick note on pruning ##                              {#alox_java_tut_run_release}

At this point, the tutorial on ALox for C# or ALox for C++ include a section about a "release build"
of the current tutorial project. In these languages, such release builds remove all <em>Log Statements</em>
from the code. Java does not know release builds. But pruning is still supported and automated in
ALox for Java as well (not covered in this tutorial, but documented here: \ref alox_java_setup_pruning "Pruning ALox").
The advantages are:<p>

- your release code executes faster
- your release executable gets a smaller footprint
- you are not delivering your debug language to the end user (not even if your executable is reverse engineered)


\~Comment ####################################################################################### \~
# 6. Controlling the  'Verbosity' #     {#alox_java_tut_verbosity}

The code above uses the method [Lox::info()](@ref #com::aworx::lox::Lox::info) (embedded in a preprocessor macro) to create the
log output. There are three other Versions of that method, together constituting the four <em>'Verbosities'</em>:

-  [Log.error()]    (@ref #com.aworx.lox.Log.error)
-  [Log.warning()]  (@ref #com.aworx.lox.Log.warning)
-  [Log.info()]     (@ref #com.aworx.lox.Log.info)
-  [Log.verbose()]  (@ref #com.aworx.lox.Log.verbose)

Let us see what happens when extending our sample as follows:

\snippet UT_dox_tutorial.java        Tut_Verbosity

If you run your application now (in "Debug" mode), the following output should appear:

\verbinclude ALox.Java/generated/Tut_Verbosity.txt

The little space in the meta information, right after the thread name [main] fills
with text-markers <b>[ERR]</b>, <b>[WRN]</b> and <b>[***]</b>, giving info about
which verbosity a <em>Log Statement</em> defines.<br>
In this sample, we are using just one source file, thread name, etc. When more variety
appears, ALox will automatically set tabulators in the meta information of the log output,
so that this information is almost always at the same column. This makes it very easy for example
to identify those log messages of \e Verbosity 'ERROR'.

\note
  If on your machine, ALox detects a console that supports colorizing the log output,
  method \b %Log.addDebugLogger will choose a colorful implementation of class \b %Logger and
  you will see the different output lines in different colors instead of these little text-markers.
  This helps 'visually filtering' log lines even better.

Now, we want to control the \e Verbosity of the log output. Let's say we just want to see
'Error' and 'Warning' messages, and suppress those of \e Verbosity 'Info' and 'Verbose'.
ALox allows to control this on a 'per \e %Logger' basis using method
\ref com::aworx::lox::Lox::setVerbosity "Lox.setVerbosity". We add the line:

\snippet UT_dox_tutorial.java        Tut_Verbosity_SetVerbosity

Here, we are explicitly passing the \e Logger object that ALox creates as a static singleton
for debug-logging purposes, with method \b addDebugLogger().
Instead of passing the reference to the object, we could as well use a \e Loggers' name.
The \e Logger that method \b addDebugLogger() creates is named \c "DEBUG_LOGGER". Therefore, the
line of code shown above can alternatively stated as:

\snippet UT_dox_tutorial.java        Tut_Verbosity_SetVerbosity_2

Our sample now looks like this:

\snippet UT_dox_tutorial.java        Tut_Verbosity_2

and produces the following output:

\verbinclude ALox.Java/generated/Tut_Verbosity_2.txt

As you see, only the <em>Log Statements</em> with \e Verbosity 'ERROR' and 'WARNING' survived.

Obviously ALox uses the attribute \e Verbosity, defined in enum class
\ref com::aworx::lox::Verbosity "Verbosity" two times:
- every <em>Log Statement</em> has a \e Verbosity assigned.
- A \e Logger attached to a \e Lox has a \e Verbosity assigned.

Then ALox matches both attributes to decide whether a <em>Log Statement</em> is executed with a \e Logger or not.

\note
  Some notes on method \b setVerbosity:
  - The first time this method is called for a \e %Logger, this method internally 'registers'
    the given \e %Logger with the \b %Lox object. In other words, there is no other method
    (and no need!) to register a \e %Logger with a \b %Lox.
  - To switch off all log output, use \e Verbosity.OFF.
  - To remove (for any reason) a \e %Logger from a \b %Lox, use method
    \ref com::aworx::lox::Lox::removeLogger "Lox.removeLogger".
  - Method \b addDebugLogger, by default sets \e %Verbosity.VERBOSE for the \e Logger created.

Now, we are able to control the \e Verbosity of the \b 'overall' log output of our application.
But probably, in bigger projects, we need more \b 'granularity' for such control. The next section tells how!

\~Comment ####################################################################################### \~
# 7. Log Domains  #     {#alox_java_tut_logdomains}

Controlling the \e Verbosity of the log output, including switching it completely off,
is of-course a core feature of any logging library.
ALox allows to control such \e Verbosity for different <b>Log Domains</b>. A <em>Log Domain</em> can be seen
like a key-word associated with just every <em>Log Statement</em>. This way, <em>Log Domains</em> are sorting each and every
<em>Log Statement</em> used in an application into a specific \b subset.

Until now, we have not used and set any <em>Log Domain</em> in our samples. We have just omitted the parameter
in our <em>Log Statements</em> and this way the parameter defaulted to an empty string. Look at the following
two <em>Log Statements</em>:

\snippet UT_dox_tutorial.java        Tut_Domains

As you see, two parameters are given now. The first denotes the <em>Log Domain</em>. The string provided can
be arbitrarily chosen. Let us quickly look at the log output:

\verbinclude ALox.Java/generated/Tut_Domains.txt

In the meta information of the log output, just before the line number, formerly appeared
<c>[/]</c> (what we did not explain, yet). Now it says <c>[/HTTP]</c>, respectively <c>[/UI]</c>.
Obviously this field of the meta information denotes the <em>Log Domain</em> associated with the <em>Log Statement</em>.

The <em>Log Domains</em> chosen in this sample obviously group the <em>Log Statements</em> of the application into two sets, one
for <em>Log Statement</em> concerning information about the 'user interface', the other about HTTP communication.
Now, we can control the \e Verbosity of the two sets independently. We are using another
default parameter that we previously omitted. Imagine, the UI of your application works well, but
you have some problems with HTTP connections:

\snippet UT_dox_tutorial.java        Tut_Domains_2

Now the output is:

\verbinclude ALox.Java/generated/Tut_Domains_2.txt

Although both <em>Log Statement</em> share the same \e Verbosity, only the one that belongs to <em>Log Domain</em> "HTTP" is shown.

The next section tells us more about <em>Log Domains</em>. You might already guess what this is
when looking at the meta information of the log output, showing
<c>[/HTTP]</c>, <c>[/UI]</c> and <c>[/]</c> for the <em>Log Domains</em>!


\~Comment ####################################################################################### \~
# 8. Hierarchical Log Domains  #     {#alox_java_tut_logdomains_hierarchical}


ALox organizes <em>Log Domains</em> hierarchically. A first advantage of this is that it becomes easy to switch
\e Verbosity of a whole set of <em>Log Domains</em> by controlling the parent.

Look at the following sample:

\snippet UT_dox_tutorial.java        Tut_DomainsHierarchical

and its output:

\verbinclude ALox.Java/generated/Tut_DomainsHierarchical.txt

We can use a slash (<c> '/'</c>) to separate <em>Log Domains</em> and organize them in a tree structure, just as
we do with directories in a file system. In the sample above, <em>Log Domains</em> \b "DLG" and \b "MOUSE" are
Sub-<em>Log Domains</em> of <em>Log Domain</em> "UI".

With this information, it is important to understand that method
\ref com::aworx::lox::Lox::setVerbosity "Lox.setVerbosity" always sets the given <em>Log Domain</em> and
<b>all its sub-domains</b> to the \e Verbosity value provided. Consequently, the following statement
switches <em>Log Domains</em> \b "UI", \b "UI/MOUSE" and \b "UI/DLG" to the same \e %Verbosity.Warning:

\snippet UT_dox_tutorial.java        Tut_DomainsHierarchical_2

If we were interested how mouse events are processed in our application, we might do invoke:

\snippet UT_dox_tutorial.java        Tut_DomainsHierarchical_3

The order of these two statements is important: If they had been written the other way round,
then the setting of <em>Log Domain</em> \b "UI" had overwritten that of <em>Log Domain</em> \b "UI/MOUSE".

\note
  You might wonder why there is no second version of the method available (or an optional parameter)
  that allows to manipulate only the <em>Log Domain</em> given, without touching its Sub-<em>Log Domains</em>.
  There are good reasons for this and these are explained in the [ALox User Manual](../manual.html).
  It is also explained there, that there is a way to stop recursion and in which situations this
  might be useful.
  But for now and in standard situations: The setting of \e Verbosity is recursive!

Almost everywhere ALox accepts a <em>Log Domain</em> name as a parameter, a <b>domain path</b> can be given.
This even works with the dot and dot-dot syntax that we know from file paths. Also, \b relative
and \b absolute path names can be given. Here are some samples:

        "DOM"          // a relative path name
        "./DOM"        // same as "DOM"
        "/DOM"         // an absolute path name
        "/DOM/XYZ/.."  // same as "/DOM"
        "/DOM/.."      // same as "/"
        "DOM/XYZ/.."   // same as "DOM"
        "DOM/./XYZ"    // same as "DOM/XYZ"

Now, we are able control the \e Verbosity of a (sub-)tree of <em>Log Domains</em>. The next section tells us
more about why the hierarchical organization of <em>Log Domains</em> is extremely useful.

\~Comment ####################################################################################### \~
# 9. Scope Domains  #     {#alox_java_tut_scope_domains}

As we saw, optional parameter \p{domain} of <em>Log Statements</em> allows us to group the log output into
different areas of interest and control the \e Verbosity per group. This is nice, but
- We have to type more
- We have to recall the 'actual' <em>Log Domains</em>' name when we insert a <em>Log Statement</em>
- The <em>Log Statement</em> become less easier to read (remember: <em>Log Statement</em> should fit to your code like comment lines)
- When copy/pasting code, all <em>Log Domain</em> might have to be changed to the destinations' domain name
- When we want to change a <em>Log Domain</em> name, we have to change it everywhere we use it.

To avoid all this (and gain even more) ALox provides a feature called <b>Scope Domains</b>.

The term \e Scope is known from your programming language. For example, a variable declared
within a class method, 'automatically' carries the scope of that method. This means, it is not
visible outside of that method. ALox uses a similar approach: All <em>Log Statements</em> within a method might
carry the same <em>Log Domain</em>. In other words, we can set a 'default value' for a <em>Log Domain</em> to be used for
all <em>Log Statements</em> of a method.

The interface in ALox which provides this feature is found with the set of overloaded versions of
\ref com::aworx::lox::Lox::setDomain "Lox.setDomain". Here is a sample:

\snippet UT_dox_tutorial.java        Tut_ScopeDomains

and its output:

\verbinclude ALox.Java/generated/Tut_ScopeDomains.txt

You see, all disadvantages we just listed are blown away using <em>Scope Domains</em>.

In the sample above, we have used \e %Scope.METHOD. Another type is \e %Scope.CLASS which
"binds" a given <em>Log Domain</em> path to all <em>Log Statements</em> within a Java class. As with scopes in your programming
language, \e Scopes in ALox are nested and of-course \e %Scope.CLASS is an <b>'outer Scope'</b>
of \e %Scope.METHOD. For a single <em>Log Statement</em>, both <em>Scope Domains</em> might apply at the same time. With having
hierarchically organized <em>Log Domains</em>, ALox concatenates all <em>Scope Domains</em> applicable. Look at the following
sample:

\snippet UT_dox_tutorial.java        Tut_ScopeDomains_Zipper

and its output when both sample methods are executed:

\verbinclude ALox.Java/generated/Tut_ScopeDomains_Zipper.txt

Imagine, class Zipper resides in a package, together with other
'utility classes'. Somewhere in these classes, probably at the place where this 'utility library'
is initialized (once, when bootstrapping a process), the following statement might be added:

\snippet UT_dox_tutorial.java        Tut_ScopeDomains_Path

This sets <em>Log Domain</em> "UTIL" for \e %Scope.PACKAGE, which is again an <b>outer scope</b> of \e %Scope.CLASS.
Without changing the code in class Zipper, invoking its methods then leads to the output:

\verbinclude ALox.Java/generated/Tut_ScopeDomains_Zipper_Path.txt

What happens when <em>Scope Domains</em> are set and we still use optional parameter \p{domain} with a <em>Log Statement</em>? Let
us just try out:

\snippet UT_dox_tutorial.java        Tut_ScopeDomains_ParamDom


\verbinclude ALox.Java/generated/Tut_ScopeDomains_ParamDom.txt

As you see, the path provided with parameter \p{domain} gets appended to the path of <em>Scope Domains</em> evaluated.
You can consider this parameter being a 'local' \e Scope, or an <b>inner</b> scope of \e %Scope.METHOD!

Finally, imagine you want to 'overwrite' current applicable <em>Scope Domains</em> and direct a certain <em>Log Statement</em>
to a different <em>Log Domain</em>. All you need to do is to use an absolute domain path with parameter \p{domain}:

\snippet UT_dox_tutorial.java        Tut_ScopeDomains_ParamDom_2


\verbinclude ALox.Java/generated/Tut_ScopeDomains_ParamDom_2.txt

In this sample, the second <em>Log Statement</em> uses an absolute path. The reason is, that the error dectected
in the code, obviously belongs to a different topic. The sample suggests, that it is not related
to reading a file, but it is related to a wrong configuration. So, the log output goes directly
to the corresponding domain.

This is enough about <em>Scope Domains</em> in the context of this tutorial. All details about <em>Log Domain</em> and <em>Scope Domains</em> are found
in the [ALox User Manual](../manual.html). Among other things, you will find:
- Information on a \e %Scope.Global
- How to use outer \e Scopes of \e %Scope.PACKAGE, addressing outer packages
- Information on 'thread-related' \e Scopes, which allow to change <em>Log Domain</em> on a per thread basis in different ways
- More samples and use cases, e.g. when to use absolute paths in <em>Scope Domains</em>.


\~Comment ####################################################################################### \~
# 10. Formatting #   {#alox_java_tut_formatting}

While talking about rather complicated things like <em>Log Domains</em> and \e Scopes, we must not
forget to talk about the log output itself. \alox is designed to be able to pass any type of
data to one or more \e Loggers. In the default case, a textual output of these \e "Logables" is wanted.
We have seen in previous samples already, that if two objects are passed, their textual representation
is just concatenated:

\snippet UT_dox_tutorial.java        Tut_Format_1
\verbinclude ALox.Java/generated/Tut_Format_1.txt

But in fact, this concatenation is just the "fallback" strategy of a quite powerful formatting
system coming with \alox. In short, \alox here relies on underlying library \alib, which
provides abstract class \ref com::aworx::lib::strings::format::Formatter "Formatter"
allowing to format a set of arguments in accordance with a given format string that contains placeholder symbols.

Now there are two tricks implemented: First, if no format string is recognized, a simple
concatenation is performed. This is what we already saw. But secondly, if one formatter does not
recognize a format string, a next formatter can be asked.

Two formatters are provided by \alib and \alox (by default) installs both in parallel:
1. \ref com::aworx::lib::strings::format::FormatterPythonStyle "FormatterPythonStyle"<br>
   Implements an extended version of
   [Python String Fromat Syntax](https://docs.python.org/3.5/library/string.html#format-string-syntax),
   which is also similar to what C# offers.
2. \ref com::aworx::lib::strings::format::FormatterJavaStyle "FormatterJavaStyle"<br>
   Implements the
   [formatting standards of the Java language](http://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html),
   which in turn are a little like good old \c printf, but of-course much more powerful and also type-safe.

With this background information, it is no surprise that the line above can alternatively be
written like this:

\snippet UT_dox_tutorial.java        Tut_Format_P

which is Python compatible syntax, or like this:

\snippet UT_dox_tutorial.java        Tut_Format_J

which is how Java formatters declare format strings!

If more arguments exists than a format string "consumes", the next remaining argument is treated
like the first one: if a format string is detected it is processed, otherwise the textual representation
of the argument is just appended to the log output. Because of this, the following statements
all produce the same log output:

\snippet UT_dox_tutorial.java        Tut_Format_Multi

Of-course it is even allowed to mix Python style and Java style format strings in one log statement:

\snippet UT_dox_tutorial.java        Tut_Format_Mix

The output is:

\verbinclude ALox.Java/generated/Tut_Format_Mix.txt

However, please note that it is \b not allowed to mix Python and Java styles within one format
string!

In general, we are recommending to use Python style syntax with \b ALox, because it is more powerful and
probably also better readable. The full documentation of the formats and how this is adopted
within the C++ version of <b>%ALib/%ALox</b> is found with documentation of classes
\ref com::aworx::lib::strings::format::FormatterPythonStyle "FormatterPythonStyle" and
\ref com::aworx::lib::strings::format::FormatterJavaStyle   "FormatterJavaStyle". Let us conclude this chapter
with some more samples:

\snippet UT_dox_tutorial.java        Tut_Format_Sample_1
\verbinclude ALox.Java/generated/Tut_Format_Sample_1.txt


\~Comment ####################################################################################### \~
# 11. Conditional logging  #   {#alox_java_tut_conditional}

## 11.1. Lox.Assert  ##

Often log lines should only be displayed if a certain condition is met. Here is a
sample:

\snippet UT_dox_tutorial.java        Tut_ConditionalLogging

The last two lines can be replaced by one using method
[Log.Assert()]  (@ref #com.aworx.lox.Log.Assert) as follows:

\snippet UT_dox_tutorial.java        Tut_ConditionalLogging2

Advantages are again less typing and better readability of the code. Furthermore, the Java compiler
would probably not prune the *if statement* if it was a more complex evaluation.
As with using *Assert()* the evaluation of the expression is definitely pruned from your code.
(Be sure you do not put side effects into expressions of *Assert()* invocations).

\note
- The method Assert() starts with capitalized "A" because "assert" is a reserved key word in Java.
- In accordance with the concept of assertions, the condition has to be \c false to have ALox perform the log.
- The \e Verbosity of *Assert()* is *Verbosity.ERROR*.


## 11.2. Lox.if  ##

A similar method to \b %Lox.Assert this is
[Lox.If]       (@ref #com::aworx::lox::Lox::If). The differences to \b Lox.Assert are:
- The given condition is interpreted the other way round: if \c true, the <em>Log Statement</em> is executed.
- The \e Verbosity of the <em>Log Statement</em> is not fixed but can (has to) be specified with parameter \p{verbosity}.

Hence, the very same effect as given in the previous sample can be achieved with:

\snippet UT_dox_tutorial.java        Tut_ConditionalLogging3

\note Same as with method \b %Assert, this methods' name is starting with a capital letter, because
      \c if is a reserved keyword in Java.

## 11.3. Log.Once  ##

Another useful <em>Log Statement</em> provided by ALox is
[Lox.once]   (@ref #com::aworx::lox::Lox::once). As the method name suggests, the statement

\snippet UT_dox_tutorial.java        Tut_ConditionalLoggingOnce

will lead to a log output only the very first time that it is executed. This seems simple, and well
it is - as long as you omit all optional parameters. There are quite a bit, which makes
this statement extremely flexible.

All details are given in a dedicated chapter of the [ALox User Manual](../manual.html). Let us
therefore just summarize some facts:
- A \e Verbosity and <em>Log Domain</em> can be given (of-course)
- A counter to increase the 'once' to 'n-times' can be given.
- The method can be used to log a message every n-th time.
- A key-word can be given, which combines different of such <em>Log Statement</em> to a set. Then the counter
  applies to this set.
- Instead of a keyword, a \e Scope can be given. This implements "Log once per this \e Scope" or
  "Log n-times per this \e Scope"
- A combination of a keyword and a \e Scope can be given. This implements
  "Log those statements of this group in this \e Scope n-times"


\~Comment ####################################################################################### \~
# 12. Prefixes  #   {#alox_java_tut_log_prefix}

Imagine, all log statements of a of a certain kind should be very visible and distinguishable
from other output. You could do this by
- giving them a separated color
- Indent them with spaces
- Start each log line with a clearly visible 'marker text'.

These things can be achieved with ALox using method
[Lox.setPrefix]   (@ref #com::aworx::lox::Lox::setPrefix). With this method, additional \e Logables
are passed to \e %Loggers attached to a \b Lox. When logging text messages (we have not even
talked in this tutorial about <b>logging arbitrary objects</b>) these objects are simply prepended
to the log message itself.

Of-course, <em>Prefix Logable</em> can be defined according to ALox \e Scopes, language-related or thread-related ones.
This means, you can do things like this:
- Add a prefix to all statements of method, source file or source directory
- Add a prefix to all statements executed by a certain tread.

Often, it is simpler to assign a <em>Prefix Logable</em> to a <em>Log Domain</em>. Also this is possible with overloaded versions of
the method.

The real simple sample looks like this:

\snippet UT_dox_tutorial.java        Tut_Prefix

\verbinclude ALox.Java/generated/Tut_Prefix.txt

For colorizing (depending on the availability of a console that supports colors) the following
prefix would be suitable:

\snippet UT_dox_tutorial.java        Tut_Prefix_2

We can not easily show colorful sample output in this tutorial. Try this yourself. ALox supports
colorized output on ANSI consoles (GNU/Linux, etc.) and Windows OS command windows.

More and more complex use cases are elaborated in the [ALox User Manual](../manual.html), for
example it is explained how log output can be 'recursively indented' with very simple statements.
Recursive indentation is very helpful when logging in recursive algorithms or when
structured, composed data objects are logged.

The next chapter shows that ALox has already built-in mechanics for logging out
structured data!

\~Comment ####################################################################################### \~
# 13. LogTools: Log Complex Data ##       {#alox_java_tut_logtools}

ALox also provides some log functions that log more complex stuff. The design decision was made to not
put this into the classes
[Lox](@ref #com.aworx.lox.Lox) /
[Log](@ref #com.aworx.lox.Log) but into a separated class [LogTools](@ref #com.aworx.lox.tools.LogTools).
However, LogTools is used in the same simple fashion as classes \b Log / \b Lox itself.

On the Java language platform two methods are currently available which are briefly covered in the following:

## 13.1 Instance(): Log any object recursively ## {#alox_java_tut_more_logtools_instance}

The method [LogTools.instance()] (@ref #com.aworx.lox.tools.LogTools.instance) allows you to log just any object
recursively in a well formatted way. You can try this out quickly by adding the following code to your sample:

\snippet UT_dox_tutorial.java        Tut_Instance

As you can see, we are just passing a quite complex object, the current thread, to the method. The parameter
that follows the object which is to be logged (the current thread) determines the level of objects which are recursively logged,
starting from the given one (composite objects). You can play around with it, and increase it from 2 to lets say 5. But
be careful: this can lead to a quite long log message!

The given parameter "Actual Thread: " provides a headline for the log output. This allows you to save another
line of code, which would be logging the headline explicitly.

Here are the first lines of output of the above sample:

\verbinclude ALox.Java/generated/Tut_Instance.txt

## 13.2 Exception(): Log an exception recursively (with inner exceptions) ## {#alox_java_tut_more_logtools_exception}

Just like Instance(), the method [LogTools.exception()] (@ref #com.aworx.lox.tools.LogTools.exception) uses the multi
line feature of ALox to log out the contents of a Java Exception well formatted and recursively (following inner exceptions).

Of-course a perfect place in your code to add [LogTools.exception()] (@ref #com.aworx.lox.tools.LogTools.exception) is
the first line within a *catch() block*.

To try it out, add the following code into your project:

\snippet UT_dox_tutorial.java        Tut_Exceptions


Like the method [LogTools.instance()] (@ref #com.aworx.lox.tools.LogTools.instance), a headline for the Exception log output can be specified.
This allows you to save another line of code, which would be logging the headline explicitly.

The following log output will be generated:

\verbinclude ALox.Java/generated/Tut_Exceptions.txt


\~Comment ####################################################################################### \~
# 14. Name Your Threads  #       {#alox_java_tut_threadnames}

In multi-threaded applications, ALox by default logs information about the thread id or name
that executed the code containing your log statements.
(This can be configured for ALox textual \e Loggers with class \ref com::aworx::lox::detail::textlogger::MetaInfo "MetaInfo".)

Often threads do not have a name, but just an ID. It would be much nicer to see a
name instead. ALox provides a simple mechanism to overwrite thread names with method
[Log.mapThreadName](@ref #com.aworx.lox.Log.mapThreadName).

The mechanism is simple, but it might not be simple to identify the right place in
the code to put it! Some code can be executed from different threads, and sometimes
(for example when using an UI framework) you might not even know exactly which thread will invoke
your code. However, the good news is that each thread ID has to be mapped only once during
the lifecycle of the program, but may be mapped multiple times. Therefore, the guideline is:

- Identify a piece of code from which you are sure that only one certain thread invokes that code.
- Make sure that this code is not executed frequently to avoid the mapping overhead.
- Make sure that this code is executed early in the lifecycle of your application.

For the sample of UI Frameworks, a good place to invoke [Log.mapThreadName](@ref #com.aworx.lox.Log.mapThreadName)
is the initial creation callback of your main application UI component. Normally, it is
enough to put this statement only in one component (the main one), because all other components
will be initialized by the same Framework thread.

But as this is a convenience concept anyhow, it is good practice to not care too much
about it at first. Later, when your application grows, you can check your log files periodically for new, unmapped
thread IDs. When you see one, scroll up in the log file and try to identify the very first appearance
of this new ID. A double click on the log line will open the code that invoked the log.
If you have populated your code with a reasonable amount of log entries, you will end up at the
right place automatically! It also might be a good idea to restart your app with all domains set
to \e Verbosity.Verbose and then look for the first appearances of unknown threads.

\~Comment ####################################################################################### \~
# 15. ALox Log Data #      {#alox_java_tut_logdata}

We hope that you are fully aware when reading through this tutorial, that all debug-log statements
that are sampled here, are \b pruned from the release executables.
One of the great benefits of ALox is that this removal of the statements is done quite
automatically (depending on the language version you are using). Once, you have set-up your projects
rightfully, your next release built is silent and does not contain your ALox <em>Log Statements</em>.

The concept of <b>Log Data</b> leverages this feature of ALox to allow to create variables
that are existing exclusively in a debug compilation of your software. You can consider this
feature as a "low hanging fruit" - not necessarily related with logging - but for ALox easy
to implement and for the user easy to use. As the access to <em>Log Data</em> is exclusively done through the
ALox API, the data is nicely 'encapsulated' and the probability of creating side effects is
reduced in comparison to other ways to introduce temporary variables used for debugging.

The methods to store and retrieve <em>Log Data</em> with ALox are
\ref com::aworx::lox::Lox::store "Lox.store" and
\ref com::aworx::lox::Lox::retrieve "Lox.retrieve".

Here is a sample code which sets a debug variable in ALox providing a version of a file that
was read by an application:

\snippet UT_dox_tutorial.java        Tut_LogData

Now, whenever it might be interesting, this file version can be accessed:

\snippet UT_dox_tutorial.java        Tut_LogData_2

The output will be:

\verbinclude ALox.Java/generated/Tut_LogData.txt

If method "Read()" of the sample above was not executed and therefore no variable was
stored, ALox just creates an empty, default object. The output in this case would look like this:

\verbinclude ALox.Java/generated/Tut_LogData2.txt


\~Comment ####################################################################################### \~
# 16. ALox Configuration Information and Internal Log Messages #      {#alox_java_tut_config}

In complex projects it might get a little confusing to keep track about the
\e Loggers and their \e Verbosity, <em>Scope Domains</em>, <em>Prefix Logables</em> and <em>Log Data</em> set.

More importantly, when other software components of your project
are using ALox as well (defining their own domains) then you might not know exactly which
<em>Log Domains</em> get registered and used by those.
The same applies when working in a team.

Let us create a sample, do some ALox configuration and then invoke method
\ref com::aworx::lox::Lox::state "Lox.state":

\snippet UT_dox_tutorial.java        Tut_LogState

\b %Lox.state gathers internal configuration information and logs it out.
The output is quite self explanatory:

\verbinclude ALox.Java/generated/Tut_LogState.txt

Besides this, there is a <b>second option</b> to inspect what happens internally in class *Lox*.
ALox is equipped with an internal <em>Log Domain</em>. This domain is used by ALox to
log messages about itself! All we have to do, is setting the \e Verbosity of the internal
domain to verbose for our debug \e Logger:

\snippet UT_dox_tutorial.java        Tut_LogInternalDomains

The output will be:

\verbinclude ALox.Java/generated/Tut_LogInternalDomains.txt

This way, you can exactly observe what is going on inside ALox.

To summarize: We have to ways to look into ALox:

1. Method [Log.state()](@ref #com.aworx.lox.Log.state) logs a "snapshot" of the current states. The advantage of this is,
   that it is all logged sequentially in one place and does not clutter your log output.
2. By setting the \e Verbosity of the internal <em>Log Domain</em>
   \ref com::aworx::lox::ALox::INTERNAL_DOMAINS "ALox.INTERNAL_DOMAINS"
   to a more verbose level. While this clutters your log output and you
   might have to search the pieces in your overall log stream, the advantage here is that you see the scope information and therefore
   you see "where" a certain manipulation of the settings took place...and you can click on it!

\note
    The internal <em>Log Domain</em> found in static, read-only field \ref com::aworx::lox::ALox::INTERNAL_DOMAINS "ALox.INTERNAL_DOMAINS"
    is not just a domain name string. In fact it specifies a completely different <b>domain tree</b>
    which is not related to those domains created when using ALox. Even when changing
    the \e Verbosity for a \e Logger on the root domain \c /, this domain is not affected, because
    it is just not a part of the general domain system. The advantage is that you can not 'accidentally'
    switch this domain on or off.
    In other words, the general domain tree is completely kept free for the users of ALox.

\see
    \alox configuration variable [ALOX_LOXNAME_DUMP_STATE_ON_EXIT](../group__GrpALoxConfigVars.html) provides
    a way to automatically log state information when a \b %Lox gets deleted.

# Further Reading #     {#alox_java_tut_end}

This is the end of the tutorial of ALox for C++. You should be able to use the basic features of the ALox logging ecosystem and
have nice, formatted, configurable log output in your software projects. ALox puts you in the comfortable position to
keep your debug <em>Log Statements</em> in your code, because you can easily configure not only the verbosity as a global
parameter, but for different <em>Log Domains</em> separately. When you start editing code that you have not touched
for a while, you just can enable the corresponding <em>Log Domain</em> and restrict others to warnings and errors for a while.
Because of the efficient ALox implementation, disabled <em>Log Domains</em> do not have a relevant impact on the execution of your
debug code. As soon as you release your code, debug logging is pruned completely from your binaries.

In the [ALox User Manual](../manual.html) you will find all details of the ALox features along
with information on use cases and often explanations why a feature is designed as it is. Some
important things not covered in the tutorial are:

- <b>Release Logging</b><br>
  Release logging is very similar to debug logging. The differences and how to use release-logging is
  described in a [dedicated chapter](../alox_man_debug_and_release_logging.html) of the manual
- <b>External Configuration</b><br>
  Instead of setting \e Verbosities and other changeable configuration "from within the source"
  (by adding ALox API invocations to your software), such data can also come from INI files,
  environment variables, command-line parameters or a any custom source that your application
  uses. This is especially important on larger projects, when working in teams.<br>
  A summary of all ALox configuration variables is found in reference chapter:
  [I - Configuration Variables](../group__GrpALoxConfigVars.html).
- <b>Trimming Source File Paths</b><br>
  For C++ and C# users: ALox automatically trims paths of source code files. This can
  be optimized, as described in
  [Trimming Source File Paths and Clickable IDE Output](../alox_man_trim_source_path.html).
- <b>Log Domain Substitution</b><br>
  What this is, is described in
  [Log Domain Substitution](../alox_man_domain_substitution.html).


If however, you just want to start using ALox and get to know more details over time, you should
only read \ref alox_java_setup.

Finally, for the daily work, the [ALox class reference](annotated.html) gives a lot of help!

*/
