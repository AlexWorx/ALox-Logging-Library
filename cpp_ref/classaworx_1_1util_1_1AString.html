<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>ALox: AString Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!-- so strange, that doxgen does not highlight each menu item. Just some... -->
<script>
  $(document).ready(function() {     
    fnameStart= window.location.href.lastIndexOf('/')
    fnameEnd=   window.location.href.indexOf('_', fnameStart )
    if( fnameEnd < 0 ) {
        fnameEnd=   window.location.href.indexOf('.', fnameStart )
    }
    if( fnameEnd > -1 ) {
        subString= window.location.href.substring( fnameStart, fnameEnd )
        $('li').toArray().forEach(function(li){
            if(     typeof li.firstChild.href != 'undefined'
                &&  li.firstChild.href.indexOf(subString) > 0 
                ){
               li.classList.add('current');
            }
        });
    }
  });
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">ALox 
   &#160;<span id="projectnumber">Logging for C++, C# and Java (V 1.2.0)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../index.html"><span>ALox&#160;Home</span></a></li>
      <li><a href="../faq.html"><span>FAQ</span></a></li>
      <li><a href="../manual.html"><span>Manual</span></a></li>
      <li class="current"><a href="cppmainpage.html"><span>ALox&#160;for&#160;C++</span></a></li>
      <li><a href="../cs_ref/csmainpage.html"><span>ALox&#160;for&#160;C#</span></a></li>
      <li><a href="../java_ref/javamainpage.html"><span>ALox&#160;for&#160;Java</span></a></li>
      <li><a href="https://github.com/AlexWorx/ALox-Logging-Library"><span>Download</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="cppmainpage.html"><span>Overview</span></a></li>
      <li><a href="cpptutorial.html"><span>Tutorial</span></a></li>
      <li><a href="cppsetup.html"><span>IDE/Build&#160;system&#160;setup</span></a></li>
      <li><a href="cppprepro.html"><span>ALox&#160;Preprocessor&#160;Symbols</span></a></li>
      <li class="current"><a href="annotated.html"><span>Class&#160;Reference</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="classes.html"><span>Alphabetical&#160;Index</span></a></li>
      <li><a href="annotated.html"><span>Namespace&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classaworx_1_1util_1_1AString-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AString Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="astring_8hpp_source.html">astring.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AString:</div>
<div class="dyncontent">
<div class="center"><img src="classaworx_1_1util_1_1AString__inherit__graph.png" border="0" usemap="#AString_inherit__map" alt="Inheritance graph"/></div>
<map name="AString_inherit__map" id="AString_inherit__map">
<area shape="rect" id="node2" href="classaworx_1_1util_1_1AStringPreAlloc.html" title="AStringPreAlloc\&lt; 64 \&gt;" alt="" coords="5,87,157,114"/><area shape="rect" id="node3" href="classaworx_1_1util_1_1AStringPreAlloc.html" title="AStringPreAlloc\&lt; BUFFER\l_SIZE \&gt;" alt="" coords="181,80,360,121"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab4fc75cf20644d0e62fb0242b3e7b401"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ab4fc75cf20644d0e62fb0242b3e7b401">Align</a> { <a class="el" href="classaworx_1_1util_1_1AString.html#ab4fc75cf20644d0e62fb0242b3e7b401a21507b40c80068eda19865706fdc2403">RIGHT</a>, 
<a class="el" href="classaworx_1_1util_1_1AString.html#ab4fc75cf20644d0e62fb0242b3e7b401a684d325a7303f52e64011467ff5c5758">LEFT</a>, 
<a class="el" href="classaworx_1_1util_1_1AString.html#ab4fc75cf20644d0e62fb0242b3e7b401ac397289ee45877be0cd49811fe245b4e">CENTER</a>
 }</td></tr>
<tr class="separator:ab4fc75cf20644d0e62fb0242b3e7b401"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0b0cd464a33e5aad4820e30b998ccf0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a0b0cd464a33e5aad4820e30b998ccf0a">AWXU_ONE_TIME_WARNING_DECL</a> (<a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a>, <a class="el" href="classaworx_1_1util_1_1AString.html#a61e8aa44b25c72e5a3f07105d2baff7a">SetLength</a>)</td></tr>
<tr class="separator:a0b0cd464a33e5aad4820e30b998ccf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89488a700bd8dd6ebf25720d5b92dd7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a89488a700bd8dd6ebf25720d5b92dd7f">AWXU_ONE_TIME_WARNING_DECL</a> (<a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a>, ReplaceExternalBuffer)</td></tr>
<tr class="separator:a89488a700bd8dd6ebf25720d5b92dd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0756c872ebdd3cae7349ea56e50e938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ac0756c872ebdd3cae7349ea56e50e938">AString</a> ()</td></tr>
<tr class="separator:ac0756c872ebdd3cae7349ea56e50e938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96fbd724b1775e840ceaf97495cc280"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aa96fbd724b1775e840ceaf97495cc280">AString</a> (int size)</td></tr>
<tr class="separator:aa96fbd724b1775e840ceaf97495cc280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8add89adb1af553183eda9d1ade16789"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a8add89adb1af553183eda9d1ade16789">AString</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;src, int regionStart=0, int regionLength=MAX_INT)</td></tr>
<tr class="separator:a8add89adb1af553183eda9d1ade16789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382bb1676b37a7734091db656bbc8054"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a382bb1676b37a7734091db656bbc8054">AString</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *src, int regionStart=0, int regionLength=MAX_INT)</td></tr>
<tr class="separator:a382bb1676b37a7734091db656bbc8054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14f8c3b4e138b7f6caa0b9223b20dc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ae14f8c3b4e138b7f6caa0b9223b20dc9">AString</a> (const std::string &amp;src, int regionStart=0, int regionLength=MAX_INT)</td></tr>
<tr class="separator:ae14f8c3b4e138b7f6caa0b9223b20dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fba7f8403265ec1dff71986eacfcde2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a2fba7f8403265ec1dff71986eacfcde2">AString</a> (const std::string *src, int regionStart=0, int regionLength=MAX_INT)</td></tr>
<tr class="separator:a2fba7f8403265ec1dff71986eacfcde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d03f22fcd0224fab0baee2f86c43996"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a7d03f22fcd0224fab0baee2f86c43996">AString</a> (const char *src, int regionStart=0, int regionLength=MAX_INT)</td></tr>
<tr class="separator:a7d03f22fcd0224fab0baee2f86c43996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83fa296890941b4c9e9b5c6deeb6ad4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aa83fa296890941b4c9e9b5c6deeb6ad4">~AString</a> ()</td></tr>
<tr class="separator:aa83fa296890941b4c9e9b5c6deeb6ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5ce30daece7ec96d0b70ccc5d46002"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a5d5ce30daece7ec96d0b70ccc5d46002">Buffer</a> () const </td></tr>
<tr class="separator:a5d5ce30daece7ec96d0b70ccc5d46002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e891964a37680c01e21dedac6ffe670"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a6e891964a37680c01e21dedac6ffe670">Length</a> () const </td></tr>
<tr class="separator:a6e891964a37680c01e21dedac6ffe670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcd1bd3507cc74b5a6caf334806fc14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#afbcd1bd3507cc74b5a6caf334806fc14">GetAllocation</a> () const </td></tr>
<tr class="separator:afbcd1bd3507cc74b5a6caf334806fc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cfdcb8f47057f88570b1c6d956e86a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#af3cfdcb8f47057f88570b1c6d956e86a">SetAllocation</a> (int newSize=-1)</td></tr>
<tr class="separator:af3cfdcb8f47057f88570b1c6d956e86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ad1aeb7c5920c8693e0d746988311b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ac9ad1aeb7c5920c8693e0d746988311b">EnsureAllocation</a> (int minLen)</td></tr>
<tr class="separator:ac9ad1aeb7c5920c8693e0d746988311b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317a232f7b91caaa97a59bbe2f66864c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a317a232f7b91caaa97a59bbe2f66864c">EnsureAllocationRelative</a> (int growth)</td></tr>
<tr class="separator:a317a232f7b91caaa97a59bbe2f66864c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9f38ad050088d77933c6fb36853cd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a4d9f38ad050088d77933c6fb36853cd5">SetExternalBuffer</a> (char *<a class="el" href="classaworx_1_1util_1_1AString.html#aff2566f4c366b48d73479bef43ee4d2e">buffer</a>, int <a class="el" href="classaworx_1_1util_1_1AString.html#a3f102a2f87691fd6584e24ae6e620cc9">allocSize</a>, int <a class="el" href="classaworx_1_1util_1_1AString.html#a9f59b34b1f25fe00023291b678246bcc">length</a>=0, bool deleteOnResize=false)</td></tr>
<tr class="separator:a4d9f38ad050088d77933c6fb36853cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e8aa44b25c72e5a3f07105d2baff7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a61e8aa44b25c72e5a3f07105d2baff7a">SetLength</a> (int newLength)</td></tr>
<tr class="separator:a61e8aa44b25c72e5a3f07105d2baff7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84608e91c10904ee7b86cb1bf4b8bc05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a84608e91c10904ee7b86cb1bf4b8bc05">Clear</a> ()</td></tr>
<tr class="separator:a84608e91c10904ee7b86cb1bf4b8bc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c15480fa48da19fb53e24ad779296a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ae1c15480fa48da19fb53e24ad779296a">Delete</a> (int regionStart, int regionLength=MAX_INT)</td></tr>
<tr class="separator:ae1c15480fa48da19fb53e24ad779296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf02927501b408253a5f0af532962b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aedf02927501b408253a5f0af532962b3">Insert</a> (int regionStart, int regionLength, char fillChar= ' ')</td></tr>
<tr class="separator:aedf02927501b408253a5f0af532962b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d0db4cdb2f90b772e72bed50e0cb83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ac0d0db4cdb2f90b772e72bed50e0cb83">Fill</a> (char c, int regionStart=0, int regionLength=MAX_INT)</td></tr>
<tr class="separator:ac0d0db4cdb2f90b772e72bed50e0cb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789a7d4b34077f3a9bb20b39ba8f742c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a789a7d4b34077f3a9bb20b39ba8f742c">NewLine</a> ()</td></tr>
<tr class="separator:a789a7d4b34077f3a9bb20b39ba8f742c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b7a58083b125d3be7cf20b0b1c4d1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ac3b7a58083b125d3be7cf20b0b1c4d1d">Tab</a> (int tabSize, int minPad=1, char tabChar= ' ')</td></tr>
<tr class="separator:ac3b7a58083b125d3be7cf20b0b1c4d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b034c69e8c52e49dec3a30b4b497cac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a4b034c69e8c52e49dec3a30b4b497cac">operator=</a> (const char *op)</td></tr>
<tr class="separator:a4b034c69e8c52e49dec3a30b4b497cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b911febd80b5d625dbe84242fdab48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ab7b911febd80b5d625dbe84242fdab48">operator=</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;op)</td></tr>
<tr class="separator:ab7b911febd80b5d625dbe84242fdab48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c46e4a0aec9341ceba81bf024f023f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ac4c46e4a0aec9341ceba81bf024f023f">operator=</a> (const std::string op)</td></tr>
<tr class="separator:ac4c46e4a0aec9341ceba81bf024f023f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d7214d068de14e8649144ecde60c10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a96d7214d068de14e8649144ecde60c10">operator+=</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;op)</td></tr>
<tr class="separator:a96d7214d068de14e8649144ecde60c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23b14d8165276602e1b76ca5b4672fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ac23b14d8165276602e1b76ca5b4672fb">operator+=</a> (const std::string &amp;op)</td></tr>
<tr class="separator:ac23b14d8165276602e1b76ca5b4672fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af812f3b6fef90d131219860cfe2e50b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#af812f3b6fef90d131219860cfe2e50b8">operator+=</a> (const char *op)</td></tr>
<tr class="separator:af812f3b6fef90d131219860cfe2e50b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bc3ac977e1c8ba19c0475c460ec605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a43bc3ac977e1c8ba19c0475c460ec605">operator&lt;&lt;</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;op)</td></tr>
<tr class="separator:a43bc3ac977e1c8ba19c0475c460ec605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3f04d35c1907212f6c857f64125e52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#afb3f04d35c1907212f6c857f64125e52">operator&lt;&lt;</a> (const std::string &amp;op)</td></tr>
<tr class="separator:afb3f04d35c1907212f6c857f64125e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683a70b5179bd5637c51a7fceeb37d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a683a70b5179bd5637c51a7fceeb37d1e">operator&lt;&lt;</a> (const char *op)</td></tr>
<tr class="separator:a683a70b5179bd5637c51a7fceeb37d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10397d47f5a094ca8018afc035c30a24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a10397d47f5a094ca8018afc035c30a24">operator&lt;&lt;</a> (const char op)</td></tr>
<tr class="separator:a10397d47f5a094ca8018afc035c30a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061c18f8d2f5e30e1088dcd187eb96e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a061c18f8d2f5e30e1088dcd187eb96e7">operator&lt;&lt;</a> (const int32_t op)</td></tr>
<tr class="separator:a061c18f8d2f5e30e1088dcd187eb96e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538d3990bee493b8c62faebdc16eb603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a538d3990bee493b8c62faebdc16eb603">operator&lt;&lt;</a> (const uint32_t op)</td></tr>
<tr class="separator:a538d3990bee493b8c62faebdc16eb603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92e63ff587cd6893c004a418f6e865c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ae92e63ff587cd6893c004a418f6e865c">operator&lt;&lt;</a> (const int64_t op)</td></tr>
<tr class="separator:ae92e63ff587cd6893c004a418f6e865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524044275f7e87cc9980908320c59b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a524044275f7e87cc9980908320c59b61">operator&lt;&lt;</a> (const uint64_t op)</td></tr>
<tr class="separator:a524044275f7e87cc9980908320c59b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbedcbae2c3355a837680aaf151759a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#afbedcbae2c3355a837680aaf151759a5">operator&lt;&lt;</a> (const double op)</td></tr>
<tr class="separator:afbedcbae2c3355a837680aaf151759a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681766fc020ab7bef222f7c03a24d4d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a681766fc020ab7bef222f7c03a24d4d0">operator&lt;</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;op) const </td></tr>
<tr class="separator:a681766fc020ab7bef222f7c03a24d4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5311ebf783b15947201bfcf495079bac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a5311ebf783b15947201bfcf495079bac">operator&lt;</a> (const std::string &amp;op) const </td></tr>
<tr class="separator:a5311ebf783b15947201bfcf495079bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8afb09bc6a50ce2518c82c55fe5472c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#af8afb09bc6a50ce2518c82c55fe5472c">operator&lt;</a> (const char *op) const </td></tr>
<tr class="separator:af8afb09bc6a50ce2518c82c55fe5472c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f218c870c801e17ff12709bfec8f81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aa1f218c870c801e17ff12709bfec8f81">operator&gt;</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;op) const </td></tr>
<tr class="separator:aa1f218c870c801e17ff12709bfec8f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a7f8d9526597bfe5beccbf946b74b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a23a7f8d9526597bfe5beccbf946b74b7">operator&gt;</a> (const std::string &amp;op) const </td></tr>
<tr class="separator:a23a7f8d9526597bfe5beccbf946b74b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4075cba35316c3501839e19470c20676"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a4075cba35316c3501839e19470c20676">operator&gt;</a> (const char *op) const </td></tr>
<tr class="separator:a4075cba35316c3501839e19470c20676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0283690fa9919c63e4c83fcd05105f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ab0283690fa9919c63e4c83fcd05105f0">operator==</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;op) const </td></tr>
<tr class="separator:ab0283690fa9919c63e4c83fcd05105f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c4260791afffe8be786b54e0bca1ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a28c4260791afffe8be786b54e0bca1ed">operator==</a> (const std::string &amp;op) const </td></tr>
<tr class="separator:a28c4260791afffe8be786b54e0bca1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab937f152301749a2d7c1f474edf20c99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ab937f152301749a2d7c1f474edf20c99">operator==</a> (const char *op) const </td></tr>
<tr class="separator:ab937f152301749a2d7c1f474edf20c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46150cabe5edd80136b1a96810b5a913"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a46150cabe5edd80136b1a96810b5a913">operator!=</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;op) const </td></tr>
<tr class="separator:a46150cabe5edd80136b1a96810b5a913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3b27705e7b29e49414ba7b22f9270b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a8b3b27705e7b29e49414ba7b22f9270b">operator!=</a> (const std::string &amp;op) const </td></tr>
<tr class="separator:a8b3b27705e7b29e49414ba7b22f9270b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56619ec9350c542bc0d640fdda9a0b6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a56619ec9350c542bc0d640fdda9a0b6a">operator!=</a> (const char *op) const </td></tr>
<tr class="separator:a56619ec9350c542bc0d640fdda9a0b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8068d1bbfd60c6cb178bdc0b2084ab9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8068d1bbfd60c6cb178bdc0b2084ab9b"></a>
char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a8068d1bbfd60c6cb178bdc0b2084ab9b">operator[]</a> (int op)</td></tr>
<tr class="memdesc:a8068d1bbfd60c6cb178bdc0b2084ab9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access single characters. Attn: no range check is performed. <br /></td></tr>
<tr class="separator:a8068d1bbfd60c6cb178bdc0b2084ab9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd117e1722b1dcee4cbe97f29281447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a1bd117e1722b1dcee4cbe97f29281447">Append</a> (int srcLength, const char *src)</td></tr>
<tr class="separator:a1bd117e1722b1dcee4cbe97f29281447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e02062bf4486dc67d54be88bc18f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a51e02062bf4486dc67d54be88bc18f85">Append</a> (int srcLength, const char *src, int regionStart, int regionLength=MAX_INT)</td></tr>
<tr class="separator:a51e02062bf4486dc67d54be88bc18f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f0576a2d6534b53322d04e0e80a1f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a65f0576a2d6534b53322d04e0e80a1f1">Append</a> (const char *src)</td></tr>
<tr class="separator:a65f0576a2d6534b53322d04e0e80a1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12a00fc0dc0124a5cadf7b4d29527b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aa12a00fc0dc0124a5cadf7b4d29527b9">Append</a> (const char *src, int regionStart, int regionLength=MAX_INT)</td></tr>
<tr class="separator:aa12a00fc0dc0124a5cadf7b4d29527b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab86fa1d42ec07c51c98d697eac0faac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aab86fa1d42ec07c51c98d697eac0faac">Append</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;src)</td></tr>
<tr class="separator:aab86fa1d42ec07c51c98d697eac0faac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43911b6ff89386b7d3d57ad18de05e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a43911b6ff89386b7d3d57ad18de05e26">Append</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;src, int regionStart, int regionLength=MAX_INT)</td></tr>
<tr class="separator:a43911b6ff89386b7d3d57ad18de05e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaff5b402f8e9258492c9bd4250c394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a2eaff5b402f8e9258492c9bd4250c394">Append</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *src)</td></tr>
<tr class="separator:a2eaff5b402f8e9258492c9bd4250c394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349bd7e3a7ed45a0e0164b1d3a56df99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a349bd7e3a7ed45a0e0164b1d3a56df99">Append</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *src, int regionStart, int regionLength=MAX_INT)</td></tr>
<tr class="separator:a349bd7e3a7ed45a0e0164b1d3a56df99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095bcfbabe55a7b300ac6a3876cf647b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a095bcfbabe55a7b300ac6a3876cf647b">Append</a> (const std::string &amp;src)</td></tr>
<tr class="separator:a095bcfbabe55a7b300ac6a3876cf647b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a42bcb9669f671e44b84df5488b5356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a8a42bcb9669f671e44b84df5488b5356">Append</a> (const std::string &amp;src, int regionStart, int regionLength=MAX_INT)</td></tr>
<tr class="separator:a8a42bcb9669f671e44b84df5488b5356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf12909b8a4a05b68121fcfffc2133a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#adf12909b8a4a05b68121fcfffc2133a3">Append</a> (const std::string *src)</td></tr>
<tr class="separator:adf12909b8a4a05b68121fcfffc2133a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5514908cc186a89733726f043da118c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aa5514908cc186a89733726f043da118c">Append</a> (const std::string *src, int regionStart, int regionLength=MAX_INT)</td></tr>
<tr class="separator:aa5514908cc186a89733726f043da118c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4cac4f2e24d0cf04004a0d437fab6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a8c4cac4f2e24d0cf04004a0d437fab6e">Append</a> (char c)</td></tr>
<tr class="separator:a8c4cac4f2e24d0cf04004a0d437fab6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2ea8b95017c040460de5fa631b6067"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a3b2ea8b95017c040460de5fa631b6067">Append</a> (char c, int qty)</td></tr>
<tr class="separator:a3b2ea8b95017c040460de5fa631b6067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead19ae6db4339a8a8bbae015476f089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aead19ae6db4339a8a8bbae015476f089">Append</a> (int32_t i, int minDigits=1)</td></tr>
<tr class="separator:aead19ae6db4339a8a8bbae015476f089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f63998dc9e82c799c35b1fb2bd44ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ae5f63998dc9e82c799c35b1fb2bd44ea">Append</a> (uint32_t i, int minDigits=1)</td></tr>
<tr class="separator:ae5f63998dc9e82c799c35b1fb2bd44ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae363c04704bf1825e2e53efc02510d93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ae363c04704bf1825e2e53efc02510d93">Append</a> (int64_t i, int minDigits=1)</td></tr>
<tr class="separator:ae363c04704bf1825e2e53efc02510d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa171465e0db260c5898e2e452a0ff52e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aa171465e0db260c5898e2e452a0ff52e">Append</a> (uint64_t i, int minDigits=1)</td></tr>
<tr class="separator:aa171465e0db260c5898e2e452a0ff52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d62f55c4b2ef472545301d6ba26c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a57d62f55c4b2ef472545301d6ba26c7a">Append</a> (double d, int minDigitsBeforeDot=0, int digitsAfterDot=5)</td></tr>
<tr class="separator:a57d62f55c4b2ef472545301d6ba26c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26860f25b7ccfec04fe122dc1ccd6cde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a26860f25b7ccfec04fe122dc1ccd6cde">Field</a> (int size=-1, <a class="el" href="classaworx_1_1util_1_1AString.html#ab4fc75cf20644d0e62fb0242b3e7b401">Align</a> alignment=<a class="el" href="classaworx_1_1util_1_1AString.html#ab4fc75cf20644d0e62fb0242b3e7b401a21507b40c80068eda19865706fdc2403">Align::RIGHT</a>, char padChar= ' ', int fieldStart=MAX_INT)</td></tr>
<tr class="separator:a26860f25b7ccfec04fe122dc1ccd6cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6f022aa72c59fe8c35482ee247ba41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#afb6f022aa72c59fe8c35482ee247ba41">CompareTo</a> (const char *compareString, bool ignoreCase=false, int compareStringRegionStart=0, int compareStringRegionLength=MAX_INT, int regionStart=0, int regionLength=MAX_INT) const </td></tr>
<tr class="separator:afb6f022aa72c59fe8c35482ee247ba41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c65370809aa47c3d22b8e7b33870c7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a3c65370809aa47c3d22b8e7b33870c7d">CompareTo</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;compareString, bool ignoreCase=false, int compareStringRegionStart=0, int compareStringRegionLength=MAX_INT, int regionStart=0, int regionLength=MAX_INT) const </td></tr>
<tr class="separator:a3c65370809aa47c3d22b8e7b33870c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339d72f5df9522e5b5114a38b4d69f36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a339d72f5df9522e5b5114a38b4d69f36">CompareTo</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *compareString, bool ignoreCase=false, int compareStringRegionStart=0, int compareStringRegionLength=MAX_INT, int regionStart=0, int regionLength=MAX_INT) const </td></tr>
<tr class="separator:a339d72f5df9522e5b5114a38b4d69f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd83f1d2fc78e271b1b84397cbb7c01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a9cd83f1d2fc78e271b1b84397cbb7c01">CompareTo</a> (const std::string *compareString, bool ignoreCase=false, int compareStringRegionStart=0, int compareStringRegionLength=MAX_INT, int regionStart=0, int regionLength=MAX_INT) const </td></tr>
<tr class="separator:a9cd83f1d2fc78e271b1b84397cbb7c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac840893b4f4923f69cf30346b2912d28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ac840893b4f4923f69cf30346b2912d28">CompareTo</a> (const std::string &amp;compareString, bool ignoreCase=false, int compareStringRegionStart=0, int compareStringRegionLength=MAX_INT, int regionStart=0, int regionLength=MAX_INT) const </td></tr>
<tr class="separator:ac840893b4f4923f69cf30346b2912d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f0b304118065fa242f7889845e054c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#af5f0b304118065fa242f7889845e054c">Equals</a> (const char *compareString, bool ignoreCase=false, int compareStringLength=-1) const </td></tr>
<tr class="separator:af5f0b304118065fa242f7889845e054c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89afc5f6a74b70ab46f23d5f769602ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a89afc5f6a74b70ab46f23d5f769602ed">Equals</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;compareString, bool ignoreCase=false) const </td></tr>
<tr class="separator:a89afc5f6a74b70ab46f23d5f769602ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260c52835fbd77a4bb27eba134ba286a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a260c52835fbd77a4bb27eba134ba286a">Equals</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *compareString, bool ignoreCase=false) const </td></tr>
<tr class="separator:a260c52835fbd77a4bb27eba134ba286a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d4c170a9bcac6f044acc31278d120f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a58d4c170a9bcac6f044acc31278d120f">Equals</a> (const std::string &amp;compareString, bool ignoreCase=false) const </td></tr>
<tr class="separator:a58d4c170a9bcac6f044acc31278d120f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13aed62450a2ba59e097c07901cb944e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a13aed62450a2ba59e097c07901cb944e">Equals</a> (std::string *compareString, bool ignoreCase=false) const </td></tr>
<tr class="separator:a13aed62450a2ba59e097c07901cb944e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528c71ed8a66020545f155534f4e19f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a528c71ed8a66020545f155534f4e19f4">ContainsAt</a> (const char *needle, int pos, bool ignoreCase=false, int needleLen=-1) const </td></tr>
<tr class="separator:a528c71ed8a66020545f155534f4e19f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2d307255f3288c2efbc2243396b28c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aab2d307255f3288c2efbc2243396b28c">ContainsAt</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;needle, int pos, bool ignoreCase=false) const </td></tr>
<tr class="separator:aab2d307255f3288c2efbc2243396b28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb9fc19ee5af82fbad535e43c2d446f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#adcb9fc19ee5af82fbad535e43c2d446f">ContainsAt</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *needle, int pos, bool ignoreCase=false) const </td></tr>
<tr class="separator:adcb9fc19ee5af82fbad535e43c2d446f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f6a6f5177b329b878e9197289cd207"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a43f6a6f5177b329b878e9197289cd207">ContainsAt</a> (const std::string &amp;needle, int pos, bool ignoreCase=false) const </td></tr>
<tr class="separator:a43f6a6f5177b329b878e9197289cd207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac686fc55615930a8c050d00d7e7f3e1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ac686fc55615930a8c050d00d7e7f3e1e">ContainsAt</a> (const std::string *needle, int pos, bool ignoreCase=false) const </td></tr>
<tr class="separator:ac686fc55615930a8c050d00d7e7f3e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001e92d3ab44c3f7c0db68f3ca3769fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a001e92d3ab44c3f7c0db68f3ca3769fe">StartsWith</a> (const char *needle, bool ignoreCase=false, int needleLen=-1) const </td></tr>
<tr class="separator:a001e92d3ab44c3f7c0db68f3ca3769fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161da473d936a003e4a1081ff7b8409e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a161da473d936a003e4a1081ff7b8409e">StartsWith</a> (const std::string &amp;needle, bool ignoreCase=false) const </td></tr>
<tr class="separator:a161da473d936a003e4a1081ff7b8409e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a115c26629be0d92153c1819f4d5e33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a5a115c26629be0d92153c1819f4d5e33">StartsWith</a> (const std::string *needle, bool ignoreCase=false) const </td></tr>
<tr class="separator:a5a115c26629be0d92153c1819f4d5e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1d05ecb89a2bc0ea46b3fcc311aaf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a0e1d05ecb89a2bc0ea46b3fcc311aaf9">StartsWith</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;needle, bool ignoreCase=false) const </td></tr>
<tr class="separator:a0e1d05ecb89a2bc0ea46b3fcc311aaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c19bf4ee063ca0ea198077f3f44f207"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a3c19bf4ee063ca0ea198077f3f44f207">StartsWith</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *needle, bool ignoreCase=false) const </td></tr>
<tr class="separator:a3c19bf4ee063ca0ea198077f3f44f207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c289f3f00384c27a05813cfc6422812"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a6c289f3f00384c27a05813cfc6422812">EndsWith</a> (const char *needle, bool ignoreCase=false, int needleLen=-1) const </td></tr>
<tr class="separator:a6c289f3f00384c27a05813cfc6422812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffbfea97aabaaa31a4b1e3a71268299"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aaffbfea97aabaaa31a4b1e3a71268299">EndsWith</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;needle, bool ignoreCase=false) const </td></tr>
<tr class="separator:aaffbfea97aabaaa31a4b1e3a71268299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7772f19d90c67f523ba8184ab560cc4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a7772f19d90c67f523ba8184ab560cc4a">EndsWith</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *needle, bool ignoreCase=false) const </td></tr>
<tr class="separator:a7772f19d90c67f523ba8184ab560cc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d101efe89be1b0e60c1562febb2ade4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a7d101efe89be1b0e60c1562febb2ade4">EndsWith</a> (const std::string &amp;needle, bool ignoreCase=false) const </td></tr>
<tr class="separator:a7d101efe89be1b0e60c1562febb2ade4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b8dd6afd5e735e9afc057b2e65ddde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a95b8dd6afd5e735e9afc057b2e65ddde">EndsWith</a> (const std::string *needle, bool ignoreCase=false) const </td></tr>
<tr class="separator:a95b8dd6afd5e735e9afc057b2e65ddde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb4afcd9544bac1c3f0e27b547f0aa6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a2cb4afcd9544bac1c3f0e27b547f0aa6">IndexOf</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;needle, int startIdx=0, bool ignoreCase=false) const </td></tr>
<tr class="separator:a2cb4afcd9544bac1c3f0e27b547f0aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae5df998ac177f5adc51ba86c2618a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a4ae5df998ac177f5adc51ba86c2618a7">IndexOf</a> (const std::string &amp;needle, int startIdx=0, bool ignoreCase=false) const </td></tr>
<tr class="separator:a4ae5df998ac177f5adc51ba86c2618a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329b980963683dbdf11ff71482eb940a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a329b980963683dbdf11ff71482eb940a">IndexOf</a> (const char *needle, int startIdx=0, bool ignoreCase=false) const </td></tr>
<tr class="separator:a329b980963683dbdf11ff71482eb940a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f588006577fd28203bbb95d6372b591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a4f588006577fd28203bbb95d6372b591">IndexOf</a> (char c, int startIdx=0)</td></tr>
<tr class="separator:a4f588006577fd28203bbb95d6372b591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985f6fe63a751d88d41f69753c937f75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a985f6fe63a751d88d41f69753c937f75">ReplaceCount</a> (const char *searchStr, int searchStringLength, const char *newStr, int newStringLength, int startIdx=0, int maxReplacements=MAX_INT, bool ignoreCase=false)</td></tr>
<tr class="separator:a985f6fe63a751d88d41f69753c937f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591b419cea8ed35489edad51c3c86041"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a591b419cea8ed35489edad51c3c86041">ReplaceCount</a> (const char *searchStr, const char *newStr, int startIdx=0, int maxReplacements=MAX_INT, bool ignoreCase=false)</td></tr>
<tr class="separator:a591b419cea8ed35489edad51c3c86041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d8cdf9bfa3b55a17acf384c75b04b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#af8d8cdf9bfa3b55a17acf384c75b04b2">ReplaceCount</a> (const std::string &amp;searchStr, const std::string &amp;newStr, int startIdx=0, int maxReplacements=MAX_INT, bool ignoreCase=false)</td></tr>
<tr class="separator:af8d8cdf9bfa3b55a17acf384c75b04b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4687aa150903707b9b3e4b5484972b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#adf4687aa150903707b9b3e4b5484972b">ReplaceCount</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;searchStr, const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;newStr, int startIdx=0, int maxReplacements=MAX_INT, bool ignoreCase=false)</td></tr>
<tr class="separator:adf4687aa150903707b9b3e4b5484972b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1407c3839a00b2cfc2e8eec6197702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aab1407c3839a00b2cfc2e8eec6197702">Replace</a> (const char *searchStr, int searchStringLength, const char *newStr, int newStringLength, int startIdx=0, int maxReplacements=MAX_INT, bool ignoreCase=false)</td></tr>
<tr class="separator:aab1407c3839a00b2cfc2e8eec6197702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cd7d7cc6953c6f2ace4c0374ffd64a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a79cd7d7cc6953c6f2ace4c0374ffd64a">Replace</a> (const char *searchStr, const char *newStr, int startIdx=0, int maxReplacements=MAX_INT, bool ignoreCase=false)</td></tr>
<tr class="separator:a79cd7d7cc6953c6f2ace4c0374ffd64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768390df89587b0bd9fb87958a2e3249"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a768390df89587b0bd9fb87958a2e3249">Replace</a> (const std::string &amp;searchStr, const std::string &amp;newStr, int startIdx=0, int maxReplacements=MAX_INT, bool ignoreCase=false)</td></tr>
<tr class="separator:a768390df89587b0bd9fb87958a2e3249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b82fa630a7b30dbac0223788be86799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a0b82fa630a7b30dbac0223788be86799">Replace</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;searchStr, const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;newStr, int startIdx=0, int maxReplacements=MAX_INT, bool ignoreCase=false)</td></tr>
<tr class="separator:a0b82fa630a7b30dbac0223788be86799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeece4e86e6eff9eddc2771bac5745881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aeece4e86e6eff9eddc2771bac5745881">ConvertCase</a> (bool toUpper, int regionStart=0, int regionLength=MAX_INT)</td></tr>
<tr class="separator:aeece4e86e6eff9eddc2771bac5745881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946e9412867b046958667b21a1236eca"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a946e9412867b046958667b21a1236eca">ToString</a> () const </td></tr>
<tr class="separator:a946e9412867b046958667b21a1236eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e5ecd600538ef7e228049ffe52c237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a84e5ecd600538ef7e228049ffe52c237">ToString</a> (int regionStart, int regionLength=MAX_INT) const </td></tr>
<tr class="separator:a84e5ecd600538ef7e228049ffe52c237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972441ff0a13b2cae8b1ac3476173642"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a972441ff0a13b2cae8b1ac3476173642">ToString</a> (std::string &amp;result, bool appendMode=false) const </td></tr>
<tr class="separator:a972441ff0a13b2cae8b1ac3476173642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb445aaafba45d61d62221986193048"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a3eb445aaafba45d61d62221986193048">ToString</a> (std::string &amp;result, int regionStart, int regionLength=MAX_INT, bool appendMode=false) const </td></tr>
<tr class="separator:a3eb445aaafba45d61d62221986193048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e40b1a8cc377df138549e250e4528e9"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a5e40b1a8cc377df138549e250e4528e9">ToLong</a> (int &amp;idx) const </td></tr>
<tr class="separator:a5e40b1a8cc377df138549e250e4528e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34881b165cbfda8a5b1dcca86ddf86f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#af34881b165cbfda8a5b1dcca86ddf86f">ToInt</a> (int &amp;idx) const </td></tr>
<tr class="separator:af34881b165cbfda8a5b1dcca86ddf86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a31ed25febb728a91f74036f2db5c7a35"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a31ed25febb728a91f74036f2db5c7a35">CompareTo</a> (const char *referenceString, int referenceStringLength, const char *compareString, int compareStringLength, bool ignoreCase=false, int compareStringRegionStart=0, int compareStringRegionLength=MAX_INT, int regionStart=0, int regionLength=MAX_INT)</td></tr>
<tr class="separator:a31ed25febb728a91f74036f2db5c7a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada854f4a920822f20a97149c5629afbe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ada854f4a920822f20a97149c5629afbe">IndexOf</a> (const char *haystack, int haystackLen, const char *needle, int needleLen, int startIdx=0, bool ignoreCase=false)</td></tr>
<tr class="separator:ada854f4a920822f20a97149c5629afbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cb4393e5a101150a2c7573a63d66e3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ad4cb4393e5a101150a2c7573a63d66e3">IsNullOrEmpty</a> (const std::string *s)</td></tr>
<tr class="separator:ad4cb4393e5a101150a2c7573a63d66e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8ab00e07a50823c18a186295f5a283"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aee8ab00e07a50823c18a186295f5a283">IsNullOrEmpty</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *ms)</td></tr>
<tr class="separator:aee8ab00e07a50823c18a186295f5a283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ded951d5392202545223646fd90cff9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a1ded951d5392202545223646fd90cff9">IsNullOrEmpty</a> (const char *cs)</td></tr>
<tr class="separator:a1ded951d5392202545223646fd90cff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7ca9ca0520c9c1cbfca8ca50ad5d161d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a7ca9ca0520c9c1cbfca8ca50ad5d161d">NEWLINE</a></td></tr>
<tr class="separator:a7ca9ca0520c9c1cbfca8ca50ad5d161d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac28635535feb25d406ec0f3f9e1b80be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ac28635535feb25d406ec0f3f9e1b80be">construct</a> (const char *src, int srcLength, int regionStart, int regionLength)</td></tr>
<tr class="separator:ac28635535feb25d406ec0f3f9e1b80be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aff2566f4c366b48d73479bef43ee4d2e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#aff2566f4c366b48d73479bef43ee4d2e">buffer</a> =nullptr</td></tr>
<tr class="separator:aff2566f4c366b48d73479bef43ee4d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f102a2f87691fd6584e24ae6e620cc9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a3f102a2f87691fd6584e24ae6e620cc9">allocSize</a> =0</td></tr>
<tr class="separator:a3f102a2f87691fd6584e24ae6e620cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f59b34b1f25fe00023291b678246bcc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a9f59b34b1f25fe00023291b678246bcc">length</a> =0</td></tr>
<tr class="separator:a9f59b34b1f25fe00023291b678246bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad464d10c2231d8bbfa23f5dcaa15af92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#ad464d10c2231d8bbfa23f5dcaa15af92">tabReference</a> =0</td></tr>
<tr class="separator:ad464d10c2231d8bbfa23f5dcaa15af92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9db4d35ad598af0040026b2b59afa4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1AString.html#a3f9db4d35ad598af0040026b2b59afa4">fieldReference</a> =0</td></tr>
<tr class="separator:a3f9db4d35ad598af0040026b2b59afa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><hr/>
<p> A mutable string, that provides public access to its internal buffer and fields. First of all, the existence of this class is motivated to reach a certain level of compatibility between source code that uses the <a class="el" href="namespaceaworx_1_1util.html">AWXU library</a> across different languages (currently Java, C# and C++) that all share a similar AString class.</p>
<p>The given C#/Java StringBuilder/Buffer classes are "sealed" and do not provide direct access to the internal buffer. Hence, to avoid conversion to new immutable strings in certain situations, we rebuild a portion of the StringBuilder functionality here. More complex functions, like formatting operations are not supported and remain the domain language specific classes.</p>
<p>If constructed with zero size or a null pointer string (but not a zero length string), the allocation size is 0. Nevertheless, method <a class="el" href="classaworx_1_1util_1_1AString.html#a5d5ce30daece7ec96d0b70ccc5d46002">Buffer</a> will return a (zero terminated) valid empty cstring (a static singleton). This has the advantage that Buffer will always return a valid (empty) character array but still allocations are avoided, at least deferred. Furthermore, it makes a difference if an AString is constructed using <a class="el" href="classaworx_1_1util_1_1AString.html#ac0756c872ebdd3cae7349ea56e50e938">AString()</a> or <a class="el" href="classaworx_1_1util_1_1AString.html#a7d03f22fcd0224fab0baee2f86c43996">AString("").</a> This allows to differentiate between 'nulled' AStrings and empty AStrings, which is quite handy in certain situations. An object that was filled already can be reset to represent null by either using the assignment operator (= nullptr) or by invoking SetAllocation(0) on the object. The methods Equals, CompareTo and the overloaded comparison operators == and != consequently do allow nullptr comparisons. An AString with zero allocation is equals to a nullptr of type <em>const char*</em>. <br />
 To make this more clear, note the following source code taken from the unit tests:</p>
<pre class="fragment">{
    char*   nullCString= nullptr;

    AString aString;
    EXPECT_TRUE( aString.CompareTo( nullCString) == 0 );
    EXPECT_TRUE( aString.Equals( nullCString) );
    EXPECT_TRUE( aString == nullptr );

    aString= "";
    EXPECT_TRUE( aString.CompareTo( nullCString) != 0 );
    EXPECT_TRUE( !aString.Equals( nullCString) );
    EXPECT_TRUE( aString != nullptr );

    aString= nullCString;
    EXPECT_TRUE( aString.CompareTo( nullCString) == 0 );
    EXPECT_TRUE( aString.Equals( nullCString) );
    EXPECT_TRUE( aString == nullptr );
}</pre><p>A memory-efficient specialization of this class is provided with class <a class="el" href="classaworx_1_1util_1_1AStringPreAlloc.html">AStringPreAlloc</a> and its convenient typedefs <a class="el" href="namespaceaworx_1_1util.html#a09ba3e296bcc9177176ba0546ebaeaab" title="A shortcut to AStringPreAlloc providing an internal preallocated buffer of size 16. ">AString16</a>, <a class="el" href="namespaceaworx_1_1util.html#a52281a7334e76a700e0656076801b4bc" title="A shortcut to AStringPreAlloc providing an internal preallocated buffer of size 32. ">AString32</a> ... <a class="el" href="namespaceaworx_1_1util.html#adc61ac987a5ce6e71b02481e3f324cdf" title="A shortcut to AStringPreAlloc providing an internal preallocated buffer of size 1024. ">AString1K</a>. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ab4fc75cf20644d0e62fb0242b3e7b401"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classaworx_1_1util_1_1AString.html#ab4fc75cf20644d0e62fb0242b3e7b401">Align</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Field alignment (used by method <a class="el" href="classaworx_1_1util_1_1AString.html#a26860f25b7ccfec04fe122dc1ccd6cde">Field</a>) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab4fc75cf20644d0e62fb0242b3e7b401a21507b40c80068eda19865706fdc2403"></a>RIGHT&#160;</td><td class="fielddoc">
<p>Align the contents of the field at the right. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4fc75cf20644d0e62fb0242b3e7b401a684d325a7303f52e64011467ff5c5758"></a>LEFT&#160;</td><td class="fielddoc">
<p>Align the contents of the field at the left. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4fc75cf20644d0e62fb0242b3e7b401ac397289ee45877be0cd49811fe245b4e"></a>CENTER&#160;</td><td class="fielddoc">
<p>Center the contents of the field. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac0756c872ebdd3cae7349ea56e50e938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Constructs an empty AString. Does not allocate a buffer. </p>

</div>
</div>
<a class="anchor" id="aa96fbd724b1775e840ceaf97495cc280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Constructor with specific Buffer size .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The initial size of the internal buffer. If less or equal to 0, no internal allocation is performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8add89adb1af553183eda9d1ade16789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Constructor copying a substring of another AString.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The reference to the AString to copy from. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in ms to append. Defaults to 0. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region in src to append. Defaults to std::numeric_limits&lt;int&gt;::max(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a382bb1676b37a7734091db656bbc8054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Constructor copying a substring of another AString, given as pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The pointer to the AString to copy from. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in ms to append. Defaults to 0. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region in src to append. Defaults to std::numeric_limits&lt;int&gt;::max(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae14f8c3b4e138b7f6caa0b9223b20dc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Constructor copying a substring of a std::string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The reference to std::string to copy from. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in s to append. Defaults to 0. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region in src to append. Defaults to std::numeric_limits&lt;int&gt;::max(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fba7f8403265ec1dff71986eacfcde2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Constructor copying a substring of a std::string, given as pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The pointer to the std::string to copy from. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in s to append. Defaults to 0. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region in src to append. Defaults to std::numeric_limits&lt;int&gt;::max(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d03f22fcd0224fab0baee2f86c43996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Constructor copying a substring of a char *.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source Mutable StringBuilder to copy. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in ms to append. Defaults to 0. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region in src to append. Defaults to std::numeric_limits&lt;int&gt;::max(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa83fa296890941b4c9e9b5c6deeb6ad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Destructs an AString object </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1bd117e1722b1dcee4cbe97f29281447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Append </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append the given cstring. If the length of the string is not known, -1 can be passed. In this case, the length of the string is evaluated using strlen().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcLength</td><td>The length of the cstring. If -1 is provided, the length is determined.</td></tr>
    <tr><td class="paramname">src</td><td>A pointer to the cstring to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a51e02062bf4486dc67d54be88bc18f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Append </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append a region of the given cstring. If the length of the string is not known, -1 can be passed. In this case, the length of the string is evaluated using strlen().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcLength</td><td>The length of the cstring. </td></tr>
    <tr><td class="paramname">src</td><td>The cstring to append. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in src to append. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The maximum length of the region in src to append. Defaults to std::numeric_limits&lt;int&gt;::max()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a65f0576a2d6534b53322d04e0e80a1f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append a cstring. Note: if the length of the cstring is known, it is recommended to use the variant of this method that receives the cstring length as its first parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The cstring to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="aa12a00fc0dc0124a5cadf7b4d29527b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append a region of the given cstring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The cstring to append. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in src to append. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The maximum length of the region in src to append. Defaults to std::numeric_limits&lt;int&gt;::max()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="aab86fa1d42ec07c51c98d697eac0faac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append the given AString. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The AString to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a43911b6ff89386b7d3d57ad18de05e26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append a substring of the given AString.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The AString to append. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in src to append. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The maximum length of the region in src to append. Defaults to std::numeric_limits&lt;int&gt;::max()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a2eaff5b402f8e9258492c9bd4250c394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append a substring of a AString provided as pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The pointer to the AString to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a349bd7e3a7ed45a0e0164b1d3a56df99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append a substring of a AString provided as pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The pointer to the AString to append. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in src to append. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The maximum length of the region in src to append. Defaults to std::numeric_limits&lt;int&gt;::max()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a095bcfbabe55a7b300ac6a3876cf647b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Append </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append a std::string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A std::string reference to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a42bcb9669f671e44b84df5488b5356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Append </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append a substring of a std::string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The std::string to append. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in src to append. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The maximum length of the region in src to append. Defaults to std::numeric_limits&lt;int&gt;::max()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="adf12909b8a4a05b68121fcfffc2133a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Append </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append a substring of a std::string provided as pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The pointer to the std::string to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5514908cc186a89733726f043da118c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Append </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append a substring of a std::string provided as pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The pointer to the std::string to append. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in src to append. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The maximum length of the region in src to append. Defaults to std::numeric_limits&lt;int&gt;::max()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c4cac4f2e24d0cf04004a0d437fab6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Append </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append the given character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b2ea8b95017c040460de5fa631b6067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Append </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append the given character repeatedly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to append. </td></tr>
    <tr><td class="paramname">qty</td><td>The quantity of characters to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="aead19ae6db4339a8a8bbae015476f089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Append </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minDigits</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append the given 32-Bit integer value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The integer value to append. </td></tr>
    <tr><td class="paramname">minDigits</td><td>The minimum number of digits to append. If given value has less digits, '0' characters are prepended. Optional, defaults to 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5f63998dc9e82c799c35b1fb2bd44ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Append </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minDigits</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append the given unsigned 32-Bit integer value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the integer value to append. </td></tr>
    <tr><td class="paramname">minDigits</td><td>The minimum number of digits to append. If given value has less digits, '0' characters are prepended. Optional, defaults to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="ae363c04704bf1825e2e53efc02510d93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Append </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minDigits</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append the given 32-Bit integer value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The integer value to append. </td></tr>
    <tr><td class="paramname">minDigits</td><td>The minimum number of digits to append. If given value has less digits, '0' characters are prepended. Optional, defaults to 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="aa171465e0db260c5898e2e452a0ff52e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Append </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minDigits</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append the given unsigned 32-Bit integer value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the integer value to append. </td></tr>
    <tr><td class="paramname">minDigits</td><td>The minimum number of digits to append. If given value has less digits, '0' characters are prepended. Optional, defaults to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a57d62f55c4b2ef472545301d6ba26c7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Append </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minDigitsBeforeDot</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digitsAfterDot</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Append the given double value using the minimum digits before and after the given number of digits after dot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the integer value to append. </td></tr>
    <tr><td class="paramname">minDigitsBeforeDot</td><td>The minimum number of digits write before the dot. If the number has less digits than minDigits, then trailing '0's are added. Defaults to 0 </td></tr>
    <tr><td class="paramname">digitsAfterDot</td><td>The exact number of digits written after the dot. Defaults to 5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b0cd464a33e5aad4820e30b998ccf0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AWXU_ONE_TIME_WARNING_DECL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1util_1_1AString.html#a61e8aa44b25c72e5a3f07105d2baff7a">SetLength</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, a one time <a class="el" href="classaworx_1_1util_1_1AWXU.html#aa8e112d595a162ca1006b314affdb89c">AWXU::Warning</a> will be issued if <a class="el" href="classaworx_1_1util_1_1AString.html#a61e8aa44b25c72e5a3f07105d2baff7a">SetLength(int)</a> is invoked with a wrong parameter. The warning will be issued only once (unless this static field is reset to true). </p>

</div>
</div>
<a class="anchor" id="a89488a700bd8dd6ebf25720d5b92dd7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AWXU_ONE_TIME_WARNING_DECL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplaceExternalBuffer&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, a one time <a class="el" href="classaworx_1_1util_1_1AWXU.html#aa8e112d595a162ca1006b314affdb89c">AWXU::Warning</a> will be issued when an external buffer, which was set using <a class="el" href="classaworx_1_1util_1_1AString.html#a4d9f38ad050088d77933c6fb36853cd5">SetExternalBuffer()</a> gets replaced by a new allocation. This normally shall not happen, but still might be wanted or at least taken into account. If your software takes such behavior into account, you should set this static field to false on process start-up. If not, it is very useful in debug mode to see if any of your instances of <a class="el" href="classaworx_1_1util_1_1AStringPreAlloc.html">AStringPreAlloc</a> located on the stack are too small and cause unwanted heap allocations. The warning will be issued only once (unless this static field is reset to true). </p>

</div>
</div>
<a class="anchor" id="a5d5ce30daece7ec96d0b70ccc5d46002"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> The internal buffer character array. The Buffer is always zero terminated, hence compatible to any cstring. In case of external modifications (to do this, you have to cast it away from being const!) be sure to adjust the length of this AString using <a class="el" href="classaworx_1_1util_1_1AString.html#a61e8aa44b25c72e5a3f07105d2baff7a">SetLength</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The internal buffer array. </dd></dl>

</div>
</div>
<a class="anchor" id="a84608e91c10904ee7b86cb1bf4b8bc05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Clear the Buffer. Same as <a class="el" href="classaworx_1_1util_1_1AString.html#ae1c15480fa48da19fb53e24ad779296a">Delete</a> (0, <a class="el" href="classaworx_1_1util_1_1AString.html#a6e891964a37680c01e21dedac6ffe670">Length()</a>) but without internal region checks. </p><dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a31ed25febb728a91f74036f2db5c7a35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CompareTo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>referenceString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>referenceStringLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>compareString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringRegionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringRegionLength</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Static method that compares two cstrings (zero terminated character arrays). For both character arrays a region for comparison can be specified. Regions that are out of bounds get adjusted and then compared. If this behavior is not what is wanted, a separate region check and corresponding compare result evaluation has to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">referenceString</td><td>The reference cstring that is compared to the second string provided. </td></tr>
    <tr><td class="paramname">referenceStringLength</td><td>The length of the referenceString. Has to be the same as strlen(referenceString). </td></tr>
    <tr><td class="paramname">compareString</td><td>A cstring that is compared to first cstring provided. </td></tr>
    <tr><td class="paramname">compareStringLength</td><td>The length of the compareString. Has to be the same as strlen(compareString). </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
    <tr><td class="paramname">compareStringRegionStart</td><td>The start of the substring within the given cstring that is to be compared to this. Defaults to 0. </td></tr>
    <tr><td class="paramname">compareStringRegionLength</td><td>The length of the substring within the given cstring that is to be compared to this. Defaults to Integer.MAX_VALUE. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the substring within this cstring that is to be. compared Defaults to 0. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the substring within this cstring that is to be compared. Defaults to Integer.MAX_VALUE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the contents of the cstring regions are equal (or if both regions are empty or out of range). -1 if the instance is less than the given cstring. +1 if the instance is greater than the given cstring or if given cstring is null. </dd></dl>

</div>
</div>
<a class="anchor" id="afb6f022aa72c59fe8c35482ee247ba41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> int CompareTo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>compareString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringRegionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringRegionLength</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Compares a given region of a given cstring with the a region of this instance. Regions that are out of bounds get adjusted and then compared. If this behavior is not what is wanted, a separate region check and corresponding compare result evaluation has to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareString</td><td>An cstring that is compared to this AString. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
    <tr><td class="paramname">compareStringRegionStart</td><td>The start of the substring within the given cstring that is to be compared to this. Defaults to 0. </td></tr>
    <tr><td class="paramname">compareStringRegionLength</td><td>The length of the substring within the given cstring that is to be compared to this. Defaults to Integer.MAX_VALUE. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the substring within this AString that is to be compared. Defaults to 0. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the substring within this AString that is to be compared. Defaults to Integer.MAX_VALUE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the contents of the regions are equal (or if both regions are empty or out of range). -1 if the instance is less than the given cstring. +1 if the instance is greater than the given cstring or if given cstring is null. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c65370809aa47c3d22b8e7b33870c7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CompareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>compareString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringRegionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringRegionLength</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Compares a given region of a given AString with the a region of this instance. Regions that areout of bounds get adjusted and then compared. If this behavior is not what is wanted, a separate region check and corresponding compare result evaluation has to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareString</td><td>The AString reference that is compared to this AString. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
    <tr><td class="paramname">compareStringRegionStart</td><td>The start of the substring within the given AString that is to be compared to this. Defaults to 0. </td></tr>
    <tr><td class="paramname">compareStringRegionLength</td><td>The length of the substring within the given AString that is to be compared to this. Defaults to Integer.MAX_VALUE. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the substring within this AString that is to be compared. Defaults to 0. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the substring within this AString that is to be compared. Defaults to Integer.MAX_VALUE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the contents of the regions are equal (or if both regions are empty or out of range). -1 if the instance is less than the given AString. +1 if the instance is greater than the given AString or if given AString is null. </dd></dl>

</div>
</div>
<a class="anchor" id="a339d72f5df9522e5b5114a38b4d69f36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CompareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *&#160;</td>
          <td class="paramname"><em>compareString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringRegionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringRegionLength</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Compares a given region of a given AString with the a region of this instance. Regions that are out of bounds get adjusted and then compared. If this behavior is not what is wanted, a separate region check and corresponding compare result evaluation has to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareString</td><td>A pointer to the AString that is compared to this AString. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
    <tr><td class="paramname">compareStringRegionStart</td><td>The start of the substring within the given AString that is to be compared to this. Defaults to 0. </td></tr>
    <tr><td class="paramname">compareStringRegionLength</td><td>The length of the substring within the given AString that is to be compared to this. Defaults to Integer.MAX_VALUE. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the substring within this AString that is to be compared. Defaults to 0. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the substring within this AString that is to be compared. Defaults to Integer.MAX_VALUE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the contents of the regions are equal (or if both regions are empty or out of range). -1 if the instance is less than the given AString. +1 if the instance is greater than the given AString or if given AString is null. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cd83f1d2fc78e271b1b84397cbb7c01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CompareTo </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>compareString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringRegionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringRegionLength</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Compares a given region of a given std::string with the a region of this instance. Regions that are out of bounds get adjusted and then compared. If this behavior is not what is wanted, a separate region check and corresponding compare result evaluation has to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareString</td><td>The std::string reference that is compared to this AString. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
    <tr><td class="paramname">compareStringRegionStart</td><td>The start of the substring within the given std::string that is to be compared to this. Defaults to 0. </td></tr>
    <tr><td class="paramname">compareStringRegionLength</td><td>The length of the substring within the given std::string that is to be compared to this. Defaults to Integer.MAX_VALUE. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the substring within this AString that is to be compared. Defaults to 0. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the substring within this AString that is to be compared. Defaults to Integer.MAX_VALUE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the contents of the regions are equal (or if both regions are empty or out of range). -1 if the instance is less than the given std::string. +1 if the instance is greater than the given std::string or if given std::string is null. </dd></dl>

</div>
</div>
<a class="anchor" id="ac840893b4f4923f69cf30346b2912d28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CompareTo </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>compareString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringRegionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringRegionLength</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Compares a given region of a given std::string with the a region of this instance. Regions that are out of bounds get adjusted and then compared. If this behavior is not what is wanted, a separate region check and corresponding compare result evaluation has to be performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareString</td><td>Pointer to the std::string that is compared to this AString. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
    <tr><td class="paramname">compareStringRegionStart</td><td>The start of the substring within the given std::string that is to be compared to this. Defaults to 0. </td></tr>
    <tr><td class="paramname">compareStringRegionLength</td><td>The length of the substring within the given std::string that is to be compared to this. Defaults to Integer.MAX_VALUE. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the substring within this AString that is to be compared. Defaults to 0. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the substring within this AString that is to be compared. Defaults to Integer.MAX_VALUE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the contents of the regions are equal (or if both regions are empty or out of range). -1 if the instance is less than the given std::string. +1 if the instance is greater than the given std::string or if given std::string is null. </dd></dl>

</div>
</div>
<a class="anchor" id="ac28635535feb25d406ec0f3f9e1b80be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void construct </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> The helper method defining the behavior for all constructors that provide some string parameter. This behavior is: allocate the exactly length of the string. If string is empty or nullptr, then no allocation is done. The latter means that <a class="el" href="classaworx_1_1util_1_1AString.html#afbcd1bd3507cc74b5a6caf334806fc14">GetAllocation</a> returns 0 after the AString is constructed. Nevertheless, <a class="el" href="classaworx_1_1util_1_1AString.html#a5d5ce30daece7ec96d0b70ccc5d46002">Buffer()</a> will return a pointer to an empty constant character array, even if no allocation was performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source Mutable StringBuilder to copy. </td></tr>
    <tr><td class="paramname">srcLength</td><td>The length of the source string. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in ms to append. Defaults to 0. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region in src to append. Defaults to std::numeric_limits&lt;int&gt;::max(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a528c71ed8a66020545f155534f4e19f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ContainsAt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>needleLen</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if the given cstring is located at the given position within this AString.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The cstring to search for. If s is null or empty, true is returned. </td></tr>
    <tr><td class="paramname">pos</td><td>The position to search for needle. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
    <tr><td class="paramname">needleLen</td><td>Optionally restricts the length of needle that is compared to with this AString buffer. If -1 (default), the whole string sequence will be matched, the first needleLen characters otherwise. Furthermore, if the length of needle is known, it is a good practice to provide it here to save the costs of determining it inside of this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given cstring is found at the given position. False otherwise . </dd></dl>

</div>
</div>
<a class="anchor" id="aab2d307255f3288c2efbc2243396b28c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ContainsAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if the given AString is located at the given position within this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The AString reference to search. If is null or empty, true is returned. </td></tr>
    <tr><td class="paramname">pos</td><td>The position to search for needle. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given std::string is found at the given position. False otherwise. * </dd></dl>

</div>
</div>
<a class="anchor" id="adcb9fc19ee5af82fbad535e43c2d446f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ContainsAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if the given AString is located at the given position within this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>Pointer to an AString to search. If is null or empty, true is returned. </td></tr>
    <tr><td class="paramname">pos</td><td>The position to search for needle. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given std::string is found at the given position. False otherwise. * </dd></dl>

</div>
</div>
<a class="anchor" id="a43f6a6f5177b329b878e9197289cd207"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ContainsAt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if the given std::string is located at the given position within this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The std::string to search. If is null or empty, true is returned. </td></tr>
    <tr><td class="paramname">pos</td><td>The position to search for needle. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given std::string is found at the given position. False otherwise. * </dd></dl>

</div>
</div>
<a class="anchor" id="ac686fc55615930a8c050d00d7e7f3e1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ContainsAt </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if the given std::string is located at the given position within this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>Pointer to a std::string to search. If is null or empty, true is returned. </td></tr>
    <tr><td class="paramname">pos</td><td>The position to search for needle. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given std::string is found at the given position. False otherwise. * </dd></dl>

</div>
</div>
<a class="anchor" id="aeece4e86e6eff9eddc2771bac5745881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; ConvertCase </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toUpper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Converts all or a region of characters in the Buffer to upper or to lower case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toUpper</td><td>If true, conversion to upper case is performed, to lower else. </td></tr>
    <tr><td class="paramname">regionStart</td><td>Start of the substring to be converted. Defaults to 0 </td></tr>
    <tr><td class="paramname">regionLength</td><td>Length of the substring to be converted. Defaults to std::numeric_limits&lt;int&gt;::max().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1c15480fa48da19fb53e24ad779296a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Delete </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Deletes a region from the Buffer. Note: To delete all contents use <a class="el" href="classaworx_1_1util_1_1AString.html#a84608e91c10904ee7b86cb1bf4b8bc05">Clear</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionStart</td><td>The start of the region to delete. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region to delete. Defaults to std::numeric_limits&lt;int&gt;::max(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c289f3f00384c27a05813cfc6422812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EndsWith </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>needleLen</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if this AString ends with the given cstring. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The cstring to be compared with the end of this AString. If this is null or empty, true is returned. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
    <tr><td class="paramname">needleLen</td><td>Optionally restricts the length of needle that is compared to with this AString buffer. If -1 (default), the whole string sequence will be matched, the first needleLen characters otherwise. Furthermore, if the length of needle is known, it is a good practice to provide it here to save the costs of determining it inside of this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this starts with the given cstring, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="aaffbfea97aabaaa31a4b1e3a71268299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EndsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if this AString ends with the given AString. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The AString to be compared with the end of this AString. If this is empty, true is returned. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this starts with the given AString, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a7772f19d90c67f523ba8184ab560cc4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EndsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if this AString ends with the given AString. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The AString to be compared with the end of this AString. If this is empty, true is returned. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this starts with the given AString, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d101efe89be1b0e60c1562febb2ade4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EndsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if this AString ends with the given std::string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The std::string to be compared with the end of this AString. If this is empty, true is returned. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this starts with the given std::string, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a95b8dd6afd5e735e9afc057b2e65ddde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EndsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if this AString ends with the given std::string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The std::string to be compared with the end of this AString. If this is empty, true is returned. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this starts with the given std::string, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9ad1aeb7c5920c8693e0d746988311b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnsureAllocation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minLen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Ensures that the capacity of the internal buffer meets or exceeds the given value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minLen</td><td>The minimum length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a317a232f7b91caaa97a59bbe2f66864c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnsureAllocationRelative </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>growth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Ensures that the capacity of the internal buffer meets or exceeds the actual length plus the given growth value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">growth</td><td>The desired growth of length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5f0b304118065fa242f7889845e054c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Equals </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>compareString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compareStringLength</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Tests and returns true, if the given string representation equals to what this object represents. True is returned if both are zero length or nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareString</td><td>A cstring that is compared to this AString. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
    <tr><td class="paramname">compareStringLength</td><td>The length of the given cstring. If -1 (default), the length will be evaluated using strlen().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if contents of this and the given AString are equal </dd></dl>

</div>
</div>
<a class="anchor" id="a89afc5f6a74b70ab46f23d5f769602ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>compareString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Tests and returns true, if the given string representation equals to what this object represents. True is returned if both are zero length or nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareString</td><td>A AString that is compared to this AString. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if contents of this and the given AString are equal </dd></dl>

</div>
</div>
<a class="anchor" id="a260c52835fbd77a4bb27eba134ba286a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *&#160;</td>
          <td class="paramname"><em>compareString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Tests and returns true, if the given string representation equals to what this object represents. True is returned if both are zero length or nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareString</td><td>A pointer to a AString that is compared to this AString. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if contents of this and the given AString are equal </dd></dl>

</div>
</div>
<a class="anchor" id="a58d4c170a9bcac6f044acc31278d120f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Equals </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>compareString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Tests and returns true, if the given string representation equals to what this object represents. True is returned if both are zero length or nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareString</td><td>A std::string that is compared to this AString. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if contents of this and the given AString are equal </dd></dl>

</div>
</div>
<a class="anchor" id="a13aed62450a2ba59e097c07901cb944e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Equals </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>compareString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Tests and returns true, if the given string representation equals to what this object represents. True is returned if both are zero length or nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compareString</td><td>A pointer to a std::string that is compared to this AString. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if contents of this and the given AString are equal </dd></dl>

</div>
</div>
<a class="anchor" id="a26860f25b7ccfec04fe122dc1ccd6cde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Field </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1util_1_1AString.html#ab4fc75cf20644d0e62fb0242b3e7b401">Align</a>&#160;</td>
          <td class="paramname"><em>alignment</em> = <code><a class="el" href="classaworx_1_1util_1_1AString.html#ab4fc75cf20644d0e62fb0242b3e7b401a21507b40c80068eda19865706fdc2403">Align::RIGHT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>padChar</em> = <code>'&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fieldStart</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> If invoked without parameters, the start of a field is marked at the current end of the string. Otherwise the end of a field is set and the contents between the field start marker and the current end of the string is aligned within the field using the given pad character. Note: To implement nested fields, the outer fields have to be set by providing the start marker by using the parameter fieldStart. Hence, only the starting points of the most inner fields can be set using this method without parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The field size in relation to the starting index of the field, defined either by using Field() prior to this invocation or by providing the parameter fieldStart. The field gets filled with the given pad character to meet the size while the content gets aligned left, right or centered. If the content exceeds the size, then no alignment takes place.</td></tr>
    <tr><td class="paramname">alignment</td><td>The alignment of the contents within the field. Defaults to <a class="el" href="classaworx_1_1util_1_1AString.html#ab4fc75cf20644d0e62fb0242b3e7b401">Align::RIGHT</a> Other options are <a class="el" href="classaworx_1_1util_1_1AString.html#ab4fc75cf20644d0e62fb0242b3e7b401">Align::LEFT</a> and <a class="el" href="classaworx_1_1util_1_1AString.html#ab4fc75cf20644d0e62fb0242b3e7b401">Align::CENTER</a>.</td></tr>
    <tr><td class="paramname">padChar</td><td>The character used to fill the field up to its size. Defaults to ' ' (space).</td></tr>
    <tr><td class="paramname">fieldStart</td><td>This parameter, if given, overwrites the start index of the field. The invocation of <a class="el" href="classaworx_1_1util_1_1AString.html#a26860f25b7ccfec04fe122dc1ccd6cde">Field</a> can be omitted, when this value is explicitly provided. Defaults to std::numeric_limits&lt;int&gt;::max().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0d0db4cdb2f90b772e72bed50e0cb83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Fill </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Fills a region of this AString with the given character If out of bounds, the given region is adjusted. The length of this remains unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to set. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in this to set. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region in this to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="afbcd1bd3507cc74b5a6caf334806fc14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetAllocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> The current size of the internal buffer (this is excluding the trailing '\0'character) which is reserved to terminate the represented cstring. In other words, the internal memory allocated is the size returned here plus one.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the allocated buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ada854f4a920822f20a97149c5629afbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexOf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>haystackLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>needleLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Static version of <a class="el" href="classaworx_1_1util_1_1AString.html#ada854f4a920822f20a97149c5629afbe">IndexOf()</a> that take cstring parameters (character arrays with '\0' terminated strings) as arguments. An optional start index can restrict the search to start searching from an offset. Exact match as well as case insensitive match are supported. If the length of the strings is provided as -1, the length will be determined. The parameter is just for optimization purposes in the case the length is known.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The cstring to be searched in. </td></tr>
    <tr><td class="paramname">haystackLen</td><td>The length of haystack. If provided as -1, the length is determined at the start step. </td></tr>
    <tr><td class="paramname">needle</td><td>The cstring to be searched for. </td></tr>
    <tr><td class="paramname">needleLen</td><td>The length of the cstring that is searched for. If provided as -1, the length is determined at the start step. </td></tr>
    <tr><td class="paramname">startIdx</td><td>An optional offset that determines where in haystack the search should start. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, a case insensitive search is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the string is not found. Otherwise the index of its first occurrence. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cb4afcd9544bac1c3f0e27b547f0aa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IndexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Search the given AString in the Buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The std::string to search for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. Optional and defaults to 0. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, a case insensitive search is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the std::string is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ae5df998ac177f5adc51ba86c2618a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IndexOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Search the given std::string in the Buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The std::string to search for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. Optional and defaults to 0. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, a case insensitive search is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the std::string is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a class="anchor" id="a329b980963683dbdf11ff71482eb940a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IndexOf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Search the given string in the Buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The cstring to search for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. Optional and defaults to 0. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, a case insensitive search is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the string represented by the char* is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f588006577fd28203bbb95d6372b591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IndexOf </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Search the given char in the Buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The char to search for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. Optional and defaults to 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the char is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a class="anchor" id="aedf02927501b408253a5f0af532962b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fillChar</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Inserts a region into the Buffer. The region gets filled with the given character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionStart</td><td>The start of the region to insert. If this is out of the string bounds (hence less than 0 or greater then <a class="el" href="classaworx_1_1util_1_1AString.html#a6e891964a37680c01e21dedac6ffe670">Length</a>, nothing is done.</td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region to insert. </td></tr>
    <tr><td class="paramname">fillChar</td><td>(Optional) The character to fill the new region with. Defaults to ' ' (space).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4cb4393e5a101150a2c7573a63d66e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsNullOrEmpty </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Checks if a given pointer to a std::string is null or if the referenced std::string has a length of zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The std::string pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if given std::string is empty or nullptr. </dd></dl>

</div>
</div>
<a class="anchor" id="aee8ab00e07a50823c18a186295f5a283"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsNullOrEmpty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Checks if a given pointer to a AString is null or if the referenced AString has a length of zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>The AString pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if given AString pointer is empty or nullptr. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ded951d5392202545223646fd90cff9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsNullOrEmpty </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Checks if a given pointer to a cstring is null or or if the referenced character array has a length of zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs</td><td>The cstring pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if given AString pointer is empty or nullptr. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e891964a37680c01e21dedac6ffe670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Returns the actual length of the cstring stored in this AString. This number is smaller or equals the number returned by <a class="el" href="classaworx_1_1util_1_1AString.html#afbcd1bd3507cc74b5a6caf334806fc14">GetAllocation</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The new length of the cstring represented by this. </dd></dl>

</div>
</div>
<a class="anchor" id="a789a7d4b34077f3a9bb20b39ba8f742c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; NewLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Appends platform specific new line character(s). ( "\\r\\n", "\\r", etc.). The new length of the string is recorded as the reference position for <a class="el" href="classaworx_1_1util_1_1AString.html#ac3b7a58083b125d3be7cf20b0b1c4d1d">Tab</a>. </p><dl class="section return"><dt>Returns</dt><dd>'this' to allow concatenated calls. </dd>
<dd>
'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a46150cabe5edd80136b1a96810b5a913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b3b27705e7b29e49414ba7b22f9270b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a class="anchor" id="a56619ec9350c542bc0d640fdda9a0b6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a class="anchor" id="a96d7214d068de14e8649144ecde60c10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="ac23b14d8165276602e1b76ca5b4672fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="af812f3b6fef90d131219860cfe2e50b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="a681766fc020ab7bef222f7c03a24d4d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a class="anchor" id="a5311ebf783b15947201bfcf495079bac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a class="anchor" id="af8afb09bc6a50ce2518c82c55fe5472c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a class="anchor" id="a43bc3ac977e1c8ba19c0475c460ec605"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="afb3f04d35c1907212f6c857f64125e52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="a683a70b5179bd5637c51a7fceeb37d1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="a10397d47f5a094ca8018afc035c30a24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="a061c18f8d2f5e30e1088dcd187eb96e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="a538d3990bee493b8c62faebdc16eb603"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="ae92e63ff587cd6893c004a418f6e865c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="a524044275f7e87cc9980908320c59b61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="afbedcbae2c3355a837680aaf151759a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b034c69e8c52e49dec3a30b4b497cac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign char as string. If operand is nullptr, the string gets cleared and memory freed with 0 allocation size. This enables a reset into the null state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7b911febd80b5d625dbe84242fdab48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4c46e4a0aec9341ceba81bf024f023f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append operand as string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Itself. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0283690fa9919c63e4c83fcd05105f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a class="anchor" id="a28c4260791afffe8be786b54e0bca1ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a class="anchor" id="ab937f152301749a2d7c1f474edf20c99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1f218c870c801e17ff12709bfec8f81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a class="anchor" id="a23a7f8d9526597bfe5beccbf946b74b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a class="anchor" id="a4075cba35316c3501839e19470c20676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a class="anchor" id="aab1407c3839a00b2cfc2e8eec6197702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Replace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>searchStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>searchStringLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newStringLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxReplacements</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p>Replace one or more occurrences of one cstring by another cstring. Along with the character pointers, the correct length of the cstrings has to be provided. For convenience, a variant of this method exists, that determines the length of the strings internally. Note: To receive the number of replacements, see alternative method <a class="el" href="classaworx_1_1util_1_1AString.html#a985f6fe63a751d88d41f69753c937f75">ReplaceCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchStr</td><td>The cstring to be replaced. </td></tr>
    <tr><td class="paramname">searchStringLength</td><td>The length of searchStr. </td></tr>
    <tr><td class="paramname">newStr</td><td>The replacement cstring. </td></tr>
    <tr><td class="paramname">newStringLength</td><td>The length of newString. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index where the search starts. Optional and defaults to 0. </td></tr>
    <tr><td class="paramname">maxReplacements</td><td>The maximum number of replacements to perform. Optional and defaults to std::numeric_limits&lt;int&gt;::max(). </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, a case insensitive search is performed. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a79cd7d7cc6953c6f2ace4c0374ffd64a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Replace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>searchStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxReplacements</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p>Replace one or more occurrences of one cstring by another cstring. The length of the cstrings is determined internally. Note: If these lengths, or one of them, are already known, for efficiency reasons it is advised to use the variant of this method that offers to provide these lengths as parameters. Also, to receive the number of replacements, see alternative method <a class="el" href="classaworx_1_1util_1_1AString.html#a985f6fe63a751d88d41f69753c937f75">ReplaceCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchStr</td><td>The cstring to be replaced. </td></tr>
    <tr><td class="paramname">newStr</td><td>The replacement cstring. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index where the search starts. Optional and defaults to 0. </td></tr>
    <tr><td class="paramname">maxReplacements</td><td>The maximum number of replacements to perform. Optional and defaults to std::numeric_limits&lt;int&gt;::max() . </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, a case insensitive search is performed. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a768390df89587b0bd9fb87958a2e3249"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Replace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>searchStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxReplacements</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p>Replace one or more occurrences of a std::string by another std::string. Note: To receive the number of replacements, see alternative method <a class="el" href="classaworx_1_1util_1_1AString.html#a985f6fe63a751d88d41f69753c937f75">ReplaceCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchStr</td><td>The std::string to be replaced. </td></tr>
    <tr><td class="paramname">newStr</td><td>The replacement std::string for searchStr. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index where the search starts. Optional and defaults to 0. </td></tr>
    <tr><td class="paramname">maxReplacements</td><td>The maximum number of replacements to perform. Optional and defaults to std::numeric_limits&lt;int&gt;::max() . </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, a case insensitive search is performed. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b82fa630a7b30dbac0223788be86799"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a>&amp; Replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>searchStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxReplacements</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p>Replace one or more occurrences of one AString by another AString. Along with the character pointers, the correct length of the cstrings has to be provided. For convenience, a variant of this method exists, that determines the length of the strings internally. Note: To receive the number of replacements, see alternative method <a class="el" href="classaworx_1_1util_1_1AString.html#a985f6fe63a751d88d41f69753c937f75">ReplaceCount()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchStr</td><td>The AString to be replaced. </td></tr>
    <tr><td class="paramname">newStr</td><td>The replacement AString. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index where the search starts. Optional and defaults to 0. </td></tr>
    <tr><td class="paramname">maxReplacements</td><td>The maximum number of replacements to perform. Optional and defaults to std::numeric_limits&lt;int&gt;::max() . </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, a case insensitive search is performed. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a985f6fe63a751d88d41f69753c937f75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReplaceCount </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>searchStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>searchStringLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newStringLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxReplacements</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Replace one or more occurrences of one cstring by another cstring. Along with the character pointers, the correct length of the cstrings has to be provided. For convenience, a variant of this method exists, that determines the length of the strings internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchStr</td><td>The cstring to be replaced. </td></tr>
    <tr><td class="paramname">searchStringLength</td><td>The length of searchStr. </td></tr>
    <tr><td class="paramname">newStr</td><td>The replacement cstring. </td></tr>
    <tr><td class="paramname">newStringLength</td><td>The length of newString. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index where the search starts. Optional and defaults 0. </td></tr>
    <tr><td class="paramname">maxReplacements</td><td>The maximum number of replacements to perform. Optional and defaults to std::numeric_limits&lt;int&gt;::max(). </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, a case insensitive search is performed. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of replacements that where performed. </dd></dl>

</div>
</div>
<a class="anchor" id="a591b419cea8ed35489edad51c3c86041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReplaceCount </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>searchStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxReplacements</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p>Replace one or more occurrences of one cstring by another cstring. The length of the cstrings is determined internally. Note: If these lengths, or one of them, are already known, for efficiency reasons it is advised to use the variant of this method that offers to provide these lengths as parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchStr</td><td>The cstring to be searched for. </td></tr>
    <tr><td class="paramname">newStr</td><td>The replacement for searchStr. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index where the search and replace should start. Optional and defaults to 0. </td></tr>
    <tr><td class="paramname">maxReplacements</td><td>The maximum number of replacements to perform. Optional and defaults to std::numeric_limits&lt;int&gt;::max() . </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, a case insensitive search is performed. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of replacements that where performed. </dd></dl>

</div>
</div>
<a class="anchor" id="af8d8cdf9bfa3b55a17acf384c75b04b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReplaceCount </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>searchStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxReplacements</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p>Replace one or more occurrences of a std::string by another std::string. Returns the number of replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchStr</td><td>The std::string to be searched for. </td></tr>
    <tr><td class="paramname">newStr</td><td>The replacement std::string for searchStr. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index where the search and replace should start. Optional and defaults to 0. </td></tr>
    <tr><td class="paramname">maxReplacements</td><td>The maximum number of replacements to perform. Optional and defaults to std::numeric_limits&lt;int&gt;::max() . </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, a case insensitive search is performed. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of replacements that where performed. </dd></dl>

</div>
</div>
<a class="anchor" id="adf4687aa150903707b9b3e4b5484972b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReplaceCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>searchStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>newStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxReplacements</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p>Replace one or more occurrences of a AString by another AString. Returns the number of replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">searchStr</td><td>The AString to be searched for. </td></tr>
    <tr><td class="paramname">newStr</td><td>The replacement AString for searchStr. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index where the search and replace should start. Optional and defaults to 0. </td></tr>
    <tr><td class="paramname">maxReplacements</td><td>The maximum number of replacements to perform. Optional and defaults to std::numeric_limits&lt;int&gt;::max() . </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, a case insensitive search is performed. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of replacements that where performed. </dd></dl>

</div>
</div>
<a class="anchor" id="af3cfdcb8f47057f88570b1c6d956e86a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetAllocation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newSize</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Resizes the internal buffer to meet exactly the given size. Attn: If the current string represented by this instance is larger, the string is cut. This method is deemed for internal use or very special situations when used from outside.</p>
<p>Note: The true allocation size is + 1 of what is given here. This is to always be able to append the trailing '\0' character that makes our buffer compatible with cstring objects. If the desired new size is 0, then any allocated buffer will be released. However, the method <a class="el" href="classaworx_1_1util_1_1AString.html#a5d5ce30daece7ec96d0b70ccc5d46002">Buffer()</a> will still return a pointer to an empty constant character array (using an internal singleton).</p>
<p>Note: If the actual buffer was previously set using <a class="el" href="classaworx_1_1util_1_1AString.html#a4d9f38ad050088d77933c6fb36853cd5">SetExternalBuffer()</a>, this method will replace the buffer by a newly created, even if the same size was requested then what is in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The new size for the allocation buffer. Defaults to -1 which will shrink the buffer to fit exactly the current string length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d9f38ad050088d77933c6fb36853cd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetExternalBuffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>allocSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteOnResize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> This methods sets an external character array as the buffer to use by this AString. This is useful a) If certain operations on external strings should be performed, b) if already allocated memory should be reused or c) for using stack memory as the internal buffer to avoid heap allocations. For the latter, see class template <a class="el" href="classaworx_1_1util_1_1AStringPreAlloc.html">AStringPreAlloc</a> and corresponding easy to use type definitions, e.g. <a class="el" href="namespaceaworx_1_1util.html#ac18d63388c3762d8b2c351de96516fe0">aworx::util::AString256</a>.</p>
<p>If a nullptr is provided and the allocation size is 0, then the actual buffer is released.</p>
<p>Should the buffer's size not be sufficient for future modifications of this object, then a new buffer will be allocated internally. The parameter 'deleteOnResize' determines, if the given buffer should be deleted in this case.</p>
<p>Any Previously allocated or provided buffers will be released. Existing content will not be copied into the external buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The external buffer to use. </td></tr>
    <tr><td class="paramname">allocSize</td><td>The size of the given buffer. </td></tr>
    <tr><td class="paramname">length</td><td>The length of any content already located in the given buffer. Has to be smaller or equal to allocSize -1 to preserve space for a trailing '\0'. Defaults to 0. </td></tr>
    <tr><td class="paramname">deleteOnResize</td><td>If true, the given buffer will be deleted when a new allocation is performed for any reason. Defaults to false, which means deletion is due to caller (or buffer is a stack object). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61e8aa44b25c72e5a3f07105d2baff7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SetLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Set the actual length of the stored cstring. The string can only be shortened. To increase the length, use one of the Append methods, e.g. <a class="el" href="classaworx_1_1util_1_1AString.html#a3b2ea8b95017c040460de5fa631b6067">Append( char, int )</a>. To change the internal allocation size, see <a class="el" href="classaworx_1_1util_1_1AString.html#af3cfdcb8f47057f88570b1c6d956e86a">SetAllocation</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newLength</td><td>The new length of the AString. Must be smaller than the current length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new length of the cstring represented by this. </dd></dl>

</div>
</div>
<a class="anchor" id="a001e92d3ab44c3f7c0db68f3ca3769fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StartsWith </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>needleLen</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if this AString starts with the given cstring. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The cstring to be compared with the start of this AString. If this is null or empty, true is returned. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
    <tr><td class="paramname">needleLen</td><td>Optionally restricts the length of needle that is compared to with this AString buffer. If -1 (default), the whole string sequence will be matched, the first needleLen characters otherwise. Furthermore, if the length of needle is known, it is a good practice to provide it here to save the costs of determining it inside of this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this starts with the given cstring, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a161da473d936a003e4a1081ff7b8409e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StartsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if this AString starts with the given std::string reference. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The std::string to be compared with the start of this AString. If this is empty, true is returned. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this starts with the given std::string, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a115c26629be0d92153c1819f4d5e33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StartsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if this AString starts with the given std::string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The std::string to be compared with the start of this AString. If this is empty, true is returned. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this starts with the given std::string, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e1d05ecb89a2bc0ea46b3fcc311aaf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StartsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if this AString starts with the given AString. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The AString to be compared with the start of this AString. If this is empty, true is returned. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this starts with the given AString, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c19bf4ee063ca0ea198077f3f44f207"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StartsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Checks if this AString starts with the given AString. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The AString to be compared with the start of this AString. If this is empty, true is returned. </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>If true, the compare is case insensitive. Optional and defaults to false. false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this starts with the given AString, false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3b7a58083b125d3be7cf20b0b1c4d1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1util_1_1AString.html">AString</a> &amp; Tab </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tabSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minPad</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>tabChar</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Go to the next tab stop by filling in pad characters repeatedly. The tab position is relative to the starting of the current line (if subsequent calls to <a class="el" href="classaworx_1_1util_1_1AString.html#a789a7d4b34077f3a9bb20b39ba8f742c">NewLine</a> where performed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tabSize</td><td>The tab positions are multiples of this parameter. </td></tr>
    <tr><td class="paramname">minPad</td><td>(Optional) The minimum pad characters to add. Defaults to 1. </td></tr>
    <tr><td class="paramname">tabChar</td><td>(Optional) The character to insert to reach the tab position. Defaults to ' ' (space). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'*this' to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="af34881b165cbfda8a5b1dcca86ddf86f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ToInt </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads an integer from the AString at the given position. The given index is increased to point to first character that is not a number. If no number is found a the given index, zero is returned and the provided index is not increased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The start point from where the long value is tried to be read. This is provided as reference and will be increased if an integer is found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the input parameter startIdx is moved to point to the first character behind any found long number. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e40b1a8cc377df138549e250e4528e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ToLong </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads a long from the AString at the given position. The given index is increased to point to first character that is not a number. If no number is found a the given index, zero is returned and the provided index is not increased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The start point from where the long value is tried to be read. This is provided as reference and will be increased if an integer is found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the input parameter startIdx is moved to point to the first character behind any found long number. </dd></dl>

</div>
</div>
<a class="anchor" id="a946e9412867b046958667b21a1236eca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Creates a std::string containing a copy of the contents of this AString.</p>
<dl class="section return"><dt>Returns</dt><dd>A std::string that represents this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a84e5ecd600538ef7e228049ffe52c237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string ToString </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Creates a std::string containing a copy of a region of the contents of this AString.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionStart</td><td>The start index of the region in this to create the std::string from. </td></tr>
    <tr><td class="paramname">regionLength</td><td>(Optional) The maximum length of the region to create the std::string from. Defaults to std::numeric_limits&lt;int&gt;::max().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the specified sub region of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a972441ff0a13b2cae8b1ac3476173642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; ToString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendMode</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Copies the contents of this AString into the given std::string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A result std::string to copy the contents of this AString into. </td></tr>
    <tr><td class="paramname">appendMode</td><td>Optional: If true, any contents in the result is preserved. Otherwise such content gets replaced (default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (modified) result that was provided (for concatenation of calls). </dd></dl>

</div>
</div>
<a class="anchor" id="a3eb445aaafba45d61d62221986193048"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string &amp; ToString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code>MAX_INT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendMode</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Copies a region of the contents of this AString into the given std::string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A result std::string to copy the specified region into. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start index of the region to be copied. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The maximum length of the region to be copied. Defaults to std::numeric_limits&lt;int&gt;::max(). </td></tr>
    <tr><td class="paramname">appendMode</td><td>Optional: If true, any contents in the result is preserved. Otherwise such content gets replaced (default).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (modified) std::string&amp; result that was provided (for concatenation of calls). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a3f102a2f87691fd6584e24ae6e620cc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int allocSize =0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current size of the buffer excluding the trailing '\0'. If no buffer is allocated, this is is 0. If an external Buffer is used and if this buffer is not under our control (we must not delete it), then the size of such buffer is stored as a negative value. </p>

</div>
</div>
<a class="anchor" id="aff2566f4c366b48d73479bef43ee4d2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* buffer =nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Buffer array. This may but should not be accessed directly. In case of external modifications the field hash has to be set to dirty (0). </p>

</div>
</div>
<a class="anchor" id="a3f9db4d35ad598af0040026b2b59afa4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int fieldReference =0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A marker for the start of the actual field. </p>

</div>
</div>
<a class="anchor" id="a9f59b34b1f25fe00023291b678246bcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int length =0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The actual length of the string stored in the Buffer. In case of external modifications the field hash has to be set to dirty (0). </p>

</div>
</div>
<a class="anchor" id="a7ca9ca0520c9c1cbfca8ca50ad5d161d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string NEWLINE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">                            <span class="stringliteral">&quot;\r\n&quot;</span></div>
</div><!-- fragment --><p>The system depended new line character code(s) retrieved statically (once) when the library is initialized.</p>
<p>An empty const character array that we will bend to be our non-const buffer if we are initialized to 0 size! </p>

</div>
</div>
<a class="anchor" id="ad464d10c2231d8bbfa23f5dcaa15af92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tabReference =0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The tab reference position. This is set when <a class="el" href="classaworx_1_1util_1_1AString.html#a789a7d4b34077f3a9bb20b39ba8f742c">NewLine</a> is invoked. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="astring_8hpp_source.html">astring.hpp</a></li>
<li>astring.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
