<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALox: String Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1712 R. 1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--ALox Main Menu-->
<div style="background: #2f3a48; " >
<table  class="aworx-menutable"  >
 <tbody>
 <tr style="height: 36px;">
  <td> <a class="aworx-menu"    href="../index.html"                                   >Home</a>                     </td>
  <td> <a class="aworx-menu_hl" href="../cpp_ref/alox_cpp_mainpage.html"                >ALox for C++</a>             </td>
  <td> <a class="aworx-menu"    href="../cs_ref/alox_cs_mainpage.html"                  >ALox for C#</a>              </td>
  <td> <a class="aworx-menu"    href="../java_ref/alox_java_mainpage.html"              >ALox for Java</a>            </td>
  <td> <a class="aworx-menu"    href="https://github.com/AlexWorx/ALox-Logging-Library">Download</a></td>
 </tr>
 </tbody>
</table>
</div>
<!--end ALox Main Menu-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html">strings</a></li><li class="navelem"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Inner Classes</a> &#124;
<a href="#pro-attribs">Protected Fields</a> &#124;
<a href="classaworx_1_1lib_1_1strings_1_1String-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">String Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="string_8hpp_source.html">string.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for String:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1strings_1_1String__inherit__graph.svg" width="646" height="139"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><hr/>
<p> This class is the base class of all <b>ALib</b> string classes. It represents a character string whose data is allocated outside the scope of objects of this class.</p>
<p>Once constructed, objects of this class are immutable. This means, there is no interface to change their buffer or length during their lifetime, which normally is rather volatile.</p>
<p>The buffer represented might be zero-terminated or not. This is dependent on the data it was constructed from. The buffer must not be changed and might even reside in read-only memory.</p>
<p><b>Templated Construction</b><br />
 What makes this class very flexible, is the constructor variant <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a77570e9a3594a1e01a53da92a5f64c40">String(const TStringLike&amp;)</a>. This template method internally uses so called <em>template meta programming</em> to detect known types and, and to convert them to constant references of those. They are then passed to template methods <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a> that simply return a pointer to the external types' buffer and length. This way, objects of this class can be implicitly constructed from just anything that 'smells' like a string.<br />
 For more information on how to make String support to implicitly construct from user defined types, see namespace template function <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a>.</p>
<p>This class provides compiler defined copy and move constructors and assignment operators. Once and object is constructed, methods <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8e9993430d0c6b4f328b2884216ef87a">Buffer</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a> allow read access to the contents.</p>
<p><b>Null-State</b><br />
<a class="anchor" id="CPP_STRINGS_AS_NULLSTATE"></a>Objects of this class can be <em>nulled</em> which means that it is a difference whether they are representing an empty string or a <code>nullptr</code>. As objects are immutable, this is decided on construction: once a String is nulled, it will remain nulled. In other words, it makes a difference if an String is constructed using</p><ul>
<li><em>String()</em>, which creates a <em>nulled</em> object, method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ac4d637a0dec45d546495c1660c9f6047">IsNull</a> will give <code>true</code>, or</li>
<li><em>String("")</em>, which creates an empty object. Method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ac4d637a0dec45d546495c1660c9f6047">IsNull</a> will give <code>false</code> while method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8e12342fc420701fbffd97025421575a">IsEmpty</a> will give <code>true</code> </li>
</ul>
<p><b>Non-checking Method Variants</b><br />
<a class="anchor" id="CPP_STRINGS_AS_NC"></a>Some of the provided methods are templated with boolean parameter <em>TCheck</em> which allow to invoke a faster and shorter version of the same method. For more information see <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_namespace_strings_nonchecking">'Non-Checking' Methods of ALib String Classes</a> in the namespace documentation.</p>
<dl class="section note"><dt>Note</dt><dd>Almost all methods of this class are declared <em>inline</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The immutable nature of String is lifted by derived types. While class <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a> allows to change the start and length of the string represented, class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> holds a copy of the data and allows to modify the contents. Field <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a> of this class is declared as an anonymous union of a <em>const char*</em> and a <em>char*</em> but the latter is not exposed. It might be exposed by derived classes (and is by class <code>AString</code>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For an introduction into the <b>ALib</b> string classes see <a class="el" href="namespaceaworx_1_1lib_1_1strings.html">namespace strings</a> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Inner Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String_1_1RandomAccessIteratorBase.html">RandomAccessIteratorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:adcffeb665e497d8c0909063e4b5df871"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adcffeb665e497d8c0909063e4b5df871">String</a> ()</td></tr>
<tr class="separator:adcffeb665e497d8c0909063e4b5df871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1301d3ebeba443fd830a9617a15aac0b"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a1301d3ebeba443fd830a9617a15aac0b">String</a> (const char *<a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a>, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> contentLength)</td></tr>
<tr class="separator:a1301d3ebeba443fd830a9617a15aac0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ab988e17c0a5a6255827eee4a8028a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#af0ab988e17c0a5a6255827eee4a8028a">String</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;src, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>)</td></tr>
<tr class="separator:af0ab988e17c0a5a6255827eee4a8028a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77570e9a3594a1e01a53da92a5f64c40"><td class="memTemplParams" colspan="2">template&lt;typename TStringLike &gt; </td></tr>
<tr class="memitem:a77570e9a3594a1e01a53da92a5f64c40"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a77570e9a3594a1e01a53da92a5f64c40">String</a> (const TStringLike &amp;src)</td></tr>
<tr class="separator:a77570e9a3594a1e01a53da92a5f64c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Buffer Access, Length and State</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a8e9993430d0c6b4f328b2884216ef87a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8e9993430d0c6b4f328b2884216ef87a">Buffer</a> () const</td></tr>
<tr class="separator:a8e9993430d0c6b4f328b2884216ef87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a515bdd031a8d3b713bb05edcf126c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a> () const</td></tr>
<tr class="separator:a78a515bdd031a8d3b713bb05edcf126c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d637a0dec45d546495c1660c9f6047"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ac4d637a0dec45d546495c1660c9f6047">IsNull</a> () const</td></tr>
<tr class="separator:ac4d637a0dec45d546495c1660c9f6047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1975261f9100a453259d7df75ad4080d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a1975261f9100a453259d7df75ad4080d">IsNotNull</a> () const</td></tr>
<tr class="separator:a1975261f9100a453259d7df75ad4080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e12342fc420701fbffd97025421575a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8e12342fc420701fbffd97025421575a">IsEmpty</a> () const</td></tr>
<tr class="separator:a8e12342fc420701fbffd97025421575a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c546c3e5ed2e243ae839807fe633140"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a6c546c3e5ed2e243ae839807fe633140">IsNotEmpty</a> () const</td></tr>
<tr class="separator:a6c546c3e5ed2e243ae839807fe633140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Character access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a7024029ef608b45471c5f31cb381f596"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a7024029ef608b45471c5f31cb381f596"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a7024029ef608b45471c5f31cb381f596">CharAt</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> idx) const</td></tr>
<tr class="separator:a7024029ef608b45471c5f31cb381f596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b840e37d6ab8f0b56075c8de82b4152"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a4b840e37d6ab8f0b56075c8de82b4152"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a4b840e37d6ab8f0b56075c8de82b4152">CharAtStart</a> () const</td></tr>
<tr class="separator:a4b840e37d6ab8f0b56075c8de82b4152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5adea1923df366e896af251757b3528"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:ad5adea1923df366e896af251757b3528"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ad5adea1923df366e896af251757b3528">CharAtEnd</a> () const</td></tr>
<tr class="separator:ad5adea1923df366e896af251757b3528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e5bdf7a6d162da1ba47c39063b417"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a227e5bdf7a6d162da1ba47c39063b417">operator[]</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> idx) const</td></tr>
<tr class="separator:a227e5bdf7a6d162da1ba47c39063b417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a80f54c9dc7947aa731b93bf3217e93f2"><td class="memTemplParams" colspan="2">template&lt;lang::Case TSensitivity = lang::Case::Sensitive&gt; </td></tr>
<tr class="memitem:a80f54c9dc7947aa731b93bf3217e93f2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a80f54c9dc7947aa731b93bf3217e93f2">Equals</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle) const</td></tr>
<tr class="separator:a80f54c9dc7947aa731b93bf3217e93f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf92645fa8c4cc894d35fd4df0e635f8"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, lang::Case TSensitivity = lang::Case::Sensitive&gt; </td></tr>
<tr class="memitem:acf92645fa8c4cc894d35fd4df0e635f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#acf92645fa8c4cc894d35fd4df0e635f8">ContainsAt</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> pos) const</td></tr>
<tr class="separator:acf92645fa8c4cc894d35fd4df0e635f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a93ef6cd1a8deaacbb3ab99c07eb80"><td class="memTemplParams" colspan="2">template&lt;lang::Case TSensitivity = lang::Case::Sensitive, bool TCheck = true&gt; </td></tr>
<tr class="memitem:a50a93ef6cd1a8deaacbb3ab99c07eb80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a50a93ef6cd1a8deaacbb3ab99c07eb80">StartsWith</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle) const</td></tr>
<tr class="separator:a50a93ef6cd1a8deaacbb3ab99c07eb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3d473da02ff2622d1a90928c506876"><td class="memTemplParams" colspan="2">template&lt;lang::Case TSensitivity = lang::Case::Sensitive&gt; </td></tr>
<tr class="memitem:a6b3d473da02ff2622d1a90928c506876"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a6b3d473da02ff2622d1a90928c506876">EndsWith</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle) const</td></tr>
<tr class="separator:a6b3d473da02ff2622d1a90928c506876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804faaeae51297434cd4b197353134d9"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, Case TSensitivity = Case::Sensitive&gt; </td></tr>
<tr class="memitem:a804faaeae51297434cd4b197353134d9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a804faaeae51297434cd4b197353134d9">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle) const</td></tr>
<tr class="separator:a804faaeae51297434cd4b197353134d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cf3199b988a6675df81ab1e4e72fda"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, Case TSensitivity = Case::Sensitive&gt; </td></tr>
<tr class="memitem:aa8cf3199b988a6675df81ab1e4e72fda"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa8cf3199b988a6675df81ab1e4e72fda">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> needleRegionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> needleRegionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>) const</td></tr>
<tr class="separator:aa8cf3199b988a6675df81ab1e4e72fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641cc875334801db2605fc7e55c656c7"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, Case TSensitivity = Case::Sensitive&gt; </td></tr>
<tr class="memitem:a641cc875334801db2605fc7e55c656c7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a641cc875334801db2605fc7e55c656c7">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> cmpRegionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> cmpRegionLength, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>) const</td></tr>
<tr class="separator:a641cc875334801db2605fc7e55c656c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64e70a5dacaf96051001c5ac1ba42d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ab64e70a5dacaf96051001c5ac1ba42d4">operator&lt;</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const</td></tr>
<tr class="separator:ab64e70a5dacaf96051001c5ac1ba42d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad898a3ce164c9108bc941ee7ba17c79c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ad898a3ce164c9108bc941ee7ba17c79c">operator&lt;=</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const</td></tr>
<tr class="separator:ad898a3ce164c9108bc941ee7ba17c79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02f8b4c5f15456011760d3690065335"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ac02f8b4c5f15456011760d3690065335">operator&gt;</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const</td></tr>
<tr class="separator:ac02f8b4c5f15456011760d3690065335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27d29bb45f71f78f23cf9f13b1f363a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa27d29bb45f71f78f23cf9f13b1f363a">operator&gt;=</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const</td></tr>
<tr class="separator:aa27d29bb45f71f78f23cf9f13b1f363a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace88722db3a272610fbc7f8fccd9e258"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ace88722db3a272610fbc7f8fccd9e258">operator==</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const</td></tr>
<tr class="separator:ace88722db3a272610fbc7f8fccd9e258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b94d6b436e0098cf9d92ba846c02e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a22b94d6b436e0098cf9d92ba846c02e9">operator!=</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const</td></tr>
<tr class="separator:a22b94d6b436e0098cf9d92ba846c02e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Search</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a7365672c3c963ba88de5612e38e704bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a7365672c3c963ba88de5612e38e704bd">IndexOf</a> (char needle) const</td></tr>
<tr class="separator:a7365672c3c963ba88de5612e38e704bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05a3241d30fde1e58d95ba1f44ee72d"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:ac05a3241d30fde1e58d95ba1f44ee72d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ac05a3241d30fde1e58d95ba1f44ee72d">IndexOf</a> (char needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx) const</td></tr>
<tr class="separator:ac05a3241d30fde1e58d95ba1f44ee72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacc41ba7e94890340a82233f2538ecc"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:abacc41ba7e94890340a82233f2538ecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#abacc41ba7e94890340a82233f2538ecc">IndexOf</a> (char needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionLength) const</td></tr>
<tr class="separator:abacc41ba7e94890340a82233f2538ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7d75de817ac17c9104f47991cc0ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#abe7d75de817ac17c9104f47991cc0ae6">IndexOfOrLength</a> (char needle) const</td></tr>
<tr class="separator:abe7d75de817ac17c9104f47991cc0ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0a1951d59db9306be459bddf0b4fbb"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:acc0a1951d59db9306be459bddf0b4fbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#acc0a1951d59db9306be459bddf0b4fbb">IndexOfOrLength</a> (char needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx) const</td></tr>
<tr class="separator:acc0a1951d59db9306be459bddf0b4fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb8c82267bbb72239c9d6559cdfbf24"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a8bb8c82267bbb72239c9d6559cdfbf24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8bb8c82267bbb72239c9d6559cdfbf24">LastIndexOf</a> (char needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIndex=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>) const</td></tr>
<tr class="separator:a8bb8c82267bbb72239c9d6559cdfbf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66424c3dfeba3c25b75df951147067d3"><td class="memTemplParams" colspan="2">template&lt;lang::Inclusion TInclusion, bool TCheck = true&gt; </td></tr>
<tr class="memitem:a66424c3dfeba3c25b75df951147067d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a66424c3dfeba3c25b75df951147067d3">IndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needles, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0) const</td></tr>
<tr class="separator:a66424c3dfeba3c25b75df951147067d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3869a6fbaf8ca6e478cd119c540dffbf"><td class="memTemplParams" colspan="2">template&lt;lang::Inclusion TInclusion, bool TCheck = true&gt; </td></tr>
<tr class="memitem:a3869a6fbaf8ca6e478cd119c540dffbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a3869a6fbaf8ca6e478cd119c540dffbf">LastIndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needles, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>) const</td></tr>
<tr class="separator:a3869a6fbaf8ca6e478cd119c540dffbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d261d680a9f9036a43cb7a6a4baa268"><td class="memTemplParams" colspan="2">template&lt;lang::Case TSensitivity = lang::Case::Sensitive, bool TCheck = true&gt; </td></tr>
<tr class="memitem:a0d261d680a9f9036a43cb7a6a4baa268"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a0d261d680a9f9036a43cb7a6a4baa268">IndexOfSubstring</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0) const</td></tr>
<tr class="separator:a0d261d680a9f9036a43cb7a6a4baa268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38812ea513734bb82f5eba9a87eedc3"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:aa38812ea513734bb82f5eba9a87eedc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa38812ea513734bb82f5eba9a87eedc3">IndexOfFirstDifference</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a>, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> idx=0) const</td></tr>
<tr class="separator:aa38812ea513734bb82f5eba9a87eedc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06a9c8f9bb2ba88baee904f7510042e"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:ac06a9c8f9bb2ba88baee904f7510042e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ac06a9c8f9bb2ba88baee904f7510042e">CountChar</a> (char needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startPos=0) const</td></tr>
<tr class="separator:ac06a9c8f9bb2ba88baee904f7510042e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2881dc9600967935c5a39536782ad818"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a2881dc9600967935c5a39536782ad818"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a2881dc9600967935c5a39536782ad818">CountChar</a> (char needle, char omit, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startPos=0) const</td></tr>
<tr class="separator:a2881dc9600967935c5a39536782ad818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2055642e2ff907fa45012dc825a705"><td class="memTemplParams" colspan="2">template&lt;lang::Case TSensitivity = lang::Case::Sensitive, bool TCheck = true&gt; </td></tr>
<tr class="memitem:a4c2055642e2ff907fa45012dc825a705"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a4c2055642e2ff907fa45012dc825a705">Count</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startPos=0) const</td></tr>
<tr class="separator:a4c2055642e2ff907fa45012dc825a705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151ecb5e80af54ad4f84f6f49af4d3c9"><td class="memTemplParams" colspan="2">template&lt;lang::Case sensitivity = lang::Case::Sensitive, bool TCheck = true&gt; </td></tr>
<tr class="memitem:a151ecb5e80af54ad4f84f6f49af4d3c9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a151ecb5e80af54ad4f84f6f49af4d3c9">Count</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;omit, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startPos=0) const</td></tr>
<tr class="separator:a151ecb5e80af54ad4f84f6f49af4d3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:ac3e160a8b59fc366a756f4b9e5aba7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ac3e160a8b59fc366a756f4b9e5aba7b2">CopyTo</a> (char *dest) const</td></tr>
<tr class="separator:ac3e160a8b59fc366a756f4b9e5aba7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad765c530b9d43175f20bdcf968451a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#afad765c530b9d43175f20bdcf968451a">ToWString</a> (wchar_t *dest, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> destCapacity, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionStart=0, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>) const</td></tr>
<tr class="separator:afad765c530b9d43175f20bdcf968451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Helper methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:abbbca75c8d760ba66c441e9f67273a7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#abbbca75c8d760ba66c441e9f67273a7f">AdjustRegion</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> &amp;regionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> &amp;regionLength) const</td></tr>
<tr class="separator:abbbca75c8d760ba66c441e9f67273a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Fields</h2></td></tr>
<tr class="memitem:adae84acc92cd77a04f6aaf533643a33a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a></td></tr>
<tr class="separator:adae84acc92cd77a04f6aaf533643a33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af940c51e198511031f839dec6e7f1b71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#af940c51e198511031f839dec6e7f1b71">length</a></td></tr>
<tr class="separator:af940c51e198511031f839dec6e7f1b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab060ffba71bd8a3d7067a38950b39a82"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ab060ffba71bd8a3d7067a38950b39a82">vbuffer</a></td></tr>
<tr class="separator:ab060ffba71bd8a3d7067a38950b39a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
std::iterator</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp152bdea49501981808ffd45d7c70c609"></a></p><h6></h6>
<h2></h2>
</td></tr>
<tr class="memitem:a64c43de3fe68d6cfacf763b946b97adb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a64c43de3fe68d6cfacf763b946b97adb">ConstIterator</a> = <a class="el" href="classaworx_1_1lib_1_1strings_1_1String_1_1RandomAccessIteratorBase.html">RandomAccessIteratorBase</a>&lt; const char *, const char &amp; &gt;</td></tr>
<tr class="separator:a64c43de3fe68d6cfacf763b946b97adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fee900c7aee90671038c79225bf8ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a64c43de3fe68d6cfacf763b946b97adb">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ad5fee900c7aee90671038c79225bf8ec">begin</a> () const</td></tr>
<tr class="separator:ad5fee900c7aee90671038c79225bf8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b6e2a03c835ca5d658a1f16acbaa9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a64c43de3fe68d6cfacf763b946b97adb">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a69b6e2a03c835ca5d658a1f16acbaa9c">end</a> () const</td></tr>
<tr class="separator:a69b6e2a03c835ca5d658a1f16acbaa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1154b4ef248c992e73c28a2783830e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a2b1154b4ef248c992e73c28a2783830e">String</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a64c43de3fe68d6cfacf763b946b97adb">ConstIterator</a> &amp;start, <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a64c43de3fe68d6cfacf763b946b97adb">ConstIterator</a> &amp;<a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a69b6e2a03c835ca5d658a1f16acbaa9c">end</a>)</td></tr>
<tr class="separator:a2b1154b4ef248c992e73c28a2783830e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a64c43de3fe68d6cfacf763b946b97adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c43de3fe68d6cfacf763b946b97adb">&#9670;&nbsp;</a></span>ConstIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a64c43de3fe68d6cfacf763b946b97adb">ConstIterator</a> =  <a class="el" href="classaworx_1_1lib_1_1strings_1_1String_1_1RandomAccessIteratorBase.html">RandomAccessIteratorBase</a>&lt;const char*, const char&amp;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The constant iterator exposed by this character container. A Mutable version is found only in descendent classes (e.g. <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>). </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adcffeb665e497d8c0909063e4b5df871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcffeb665e497d8c0909063e4b5df871">&#9670;&nbsp;</a></span>String() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructs a <em>nulled</em> String </p>

</div>
</div>
<a id="a1301d3ebeba443fd830a9617a15aac0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1301d3ebeba443fd830a9617a15aac0b">&#9670;&nbsp;</a></span>String() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>contentLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructs this object using the given external buffer and length of content.</p>
<dl class="section note"><dt>Note</dt><dd>The provided buffer does not need to be zero-terminated. However, there must not be any '\0' characters within the start and the given <code>contentLength</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to use. </td></tr>
    <tr><td class="paramname">contentLength</td><td>The length of the content in the given buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0ab988e17c0a5a6255827eee4a8028a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ab988e17c0a5a6255827eee4a8028a">&#9670;&nbsp;</a></span>String() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructs this object to represent a region of another String (respectively a region of any string object whose type implicitly constructs a temporary String).<br />
 The region is adjusted to [0 ... <em>as.Length()</em>].</p>
<dl class="section note"><dt>Note</dt><dd>When constructing an <a class="el" href="namespaceaworx.html#ad13481d84c6e592a41d07c64f747c95d">aworx::String</a> from a region of another <a class="el" href="namespaceaworx.html#ad13481d84c6e592a41d07c64f747c95d">aworx::String</a>, this constructor is preferable over the overloaded <b>String(const char*, size_t)</b> (although often the same calculation of parameters has to be performed), because this constructor checks the bounds!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The src from that we will represent a region. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region within the given String. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region within the given String. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77570e9a3594a1e01a53da92a5f64c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77570e9a3594a1e01a53da92a5f64c40">&#9670;&nbsp;</a></span>String() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> </td>
          <td>(</td>
          <td class="paramtype">const TStringLike &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Templated constructor for different types. This constructor uses some template meta programming to provide maximum flexibility to implicitly embed the data of any string type in an object of type String.</p>
<p>This constructor accepts the following types:</p><ul>
<li><em>nullptr</em> (creates a <em>nulled</em> String).</li>
<li><em>[const] char*</em></li>
<li>Classes derived from String.</li>
<li>User defined (external) types. See documentation of <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a> on how to add support for implicit construction of <b>ALib</b> strings from custom string types.</li>
<li>User defined literal types. See documentation of <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__StringLiteral.html">T_StringLiteral</a>.</li>
</ul>
<p>When a non-supported type is passed, a compile-time error (<code>static_assert</code>) is raised. In some rare cases, dependent on the compiler and platform, some false alarms may be given for types that are not even passed to the constructor, but the compiler wrongly "thinks" that such type is passed. For example, with advanced use of <code>std::tuple</code> template class, such errors might occur. To suppress a "false" error, use macro <a class="el" href="group__GrpALibStringsMacros.html#ga58ee5d0225baf5d3ad3d3592cb6a7a4e">ALIB_STRING_CONSTRUCTOR_FIX</a> for the type in question.</p>
<dl class="section note"><dt>Note</dt><dd>Other than the type of parameter <code>src</code> (<em>const TStringLike&amp;</em>) may indicate, objects of the class types named above may be provided as pointer or reference. The TMP will detect <code>nullptr</code> and otherwise convert pointers to references.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>For more information, see <a class="el" href="namespaceaworx_1_1lib_1_1strings.html">namespace documentation</a> and template function <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__String.html">T_String</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TStringLike</td><td>Type that allows to construct <a class="el" href="classaworx_1_1lib_1_1strings_1_1Strings.html">Strings</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source of template type T to take the buffer and length from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b1154b4ef248c992e73c28a2783830e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1154b4ef248c992e73c28a2783830e">&#9670;&nbsp;</a></span>String() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a64c43de3fe68d6cfacf763b946b97adb">ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a64c43de3fe68d6cfacf763b946b97adb">ConstIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructs this string using start and end iterators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>An iterator referencing the start of the string. </td></tr>
    <tr><td class="paramname">end</td><td>An iterator referencing the end of the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abbbca75c8d760ba66c441e9f67273a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbbca75c8d760ba66c441e9f67273a7f">&#9670;&nbsp;</a></span>AdjustRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AdjustRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> &amp;&#160;</td>
          <td class="paramname"><em>regionLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This is a helper method that adjusts a given region (in/out parameters) to fit to this objects' buffer range [0..length].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionStart</td><td>The proposed region start which might get adjusted to fit to span 0 to referenceLength. (In/out parameter.) </td></tr>
    <tr><td class="paramname">regionLength</td><td>The proposed region length which might get adjusted to fit to span 0 to referenceLength. (In/out parameter.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code>, if the adjusted region is empty. </dd></dl>

</div>
</div>
<a id="ad5fee900c7aee90671038c79225bf8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fee900c7aee90671038c79225bf8ec">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a64c43de3fe68d6cfacf763b946b97adb">ConstIterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the start of this string. </p><dl class="section return"><dt>Returns</dt><dd>The start of this string. </dd></dl>

</div>
</div>
<a id="a8e9993430d0c6b4f328b2884216ef87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9993430d0c6b4f328b2884216ef87a">&#9670;&nbsp;</a></span>Buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* Buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns a pointer to the first character of the string we are representing. </p><dl class="section note"><dt>Note</dt><dd>The string is not guaranteed to be zero terminated.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The internal buffer array. </dd></dl>

</div>
</div>
<a id="a7024029ef608b45471c5f31cb381f596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7024029ef608b45471c5f31cb381f596">&#9670;&nbsp;</a></span>CharAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char CharAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Retrieves the character at the given index. A range check is performed. If this fails, '\0' is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the character to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character at the given index, or '\0' if index out of range. </dd></dl>

</div>
</div>
<a id="ad5adea1923df366e896af251757b3528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5adea1923df366e896af251757b3528">&#9670;&nbsp;</a></span>CharAtEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char CharAtEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Retrieves the last character. In case of an empty or <em>nulled</em> string, '\0' is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no check for an empty or <em>nulled</em> object is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last character in the String. If this instance's length is zero, '\0' is returned. </dd></dl>

</div>
</div>
<a id="a4b840e37d6ab8f0b56075c8de82b4152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b840e37d6ab8f0b56075c8de82b4152">&#9670;&nbsp;</a></span>CharAtStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char CharAtStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Retrieves the first character. In case of an empty or <em>nulled</em> string, '\0' is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no check for an empty or <em>nulled</em> object is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first character in the String. If this instance's length is zero, '\0' is returned. </dd></dl>

</div>
</div>
<a id="a804faaeae51297434cd4b197353134d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804faaeae51297434cd4b197353134d9">&#9670;&nbsp;</a></span>CompareTo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CompareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Compares this with another String.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no check for a <em>nulled</em> object (this) performed and this string must not be of zero length (while <code>needle</code> might be of zero length). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if this and <code>needle</code> are <em>nulled</em> or if both have a length of 0 or if both share the same content</li>
<li>&lt;0 if this is <em>nulled</em> and <code>needle</code> is not or if this is smaller than <code>needle</code>.</li>
<li>&gt;0 if this is not <em>nulled</em> but <code>needle</code> is or if this is greater than <code>needle</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa8cf3199b988a6675df81ab1e4e72fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cf3199b988a6675df81ab1e4e72fda">&#9670;&nbsp;</a></span>CompareTo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CompareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>needleRegionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>needleRegionLength</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Compares this with a region of another String.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to compare this string with. </td></tr>
    <tr><td class="paramname">needleRegionStart</td><td>The start of the region in <code>needle</code> to compare this object with. </td></tr>
    <tr><td class="paramname">needleRegionLength</td><td>The length of the region in <code>needle</code> to compare this object with. Defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>; </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no check for a <em>nulled</em> comparison object is performed and this string must not be empty. Furthermore, no check is performed whether the given region fits to parameter <code>needle</code>. This also means that the default value must not be used with <em>TCheck==&lt;<code>false&gt;</em></code>. </td></tr>
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if this and <code>needle</code> are <em>nulled</em> or if both have a length of 0 or if both share the same content</li>
<li>&lt;0 if this is <em>nulled</em> and <code>needle</code> is not or if this is smaller than <code>needle</code>.</li>
<li>&gt;0 if this is not <em>nulled</em> but <code>needle</code> is or if this is greater than <code>needle</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a641cc875334801db2605fc7e55c656c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641cc875334801db2605fc7e55c656c7">&#9670;&nbsp;</a></span>CompareTo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CompareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>cmpRegionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>cmpRegionLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Compares a region of this object with a region of another String.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to compare this string with. </td></tr>
    <tr><td class="paramname">cmpRegionStart</td><td>The start of the region in <code>needle</code> to compare this object with. </td></tr>
    <tr><td class="paramname">cmpRegionLength</td><td>The length of the region in <code>needle</code> to compare this object with. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in this object to compare with </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region in this object to compare with. Defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>; </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no check for a <em>nulled</em> comparison object is performed and this string must not be empty. Furthermore, no check is performed whether the given regions fit to this object respectively the other region to the object given with parameter <code>needle</code>. This also means that the default value must not be used with <em>TCheck==&lt;<code>false&gt;</em></code>. </td></tr>
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if this and <code>needle</code> are <em>nulled</em> or if both have a length of 0 or if both share the same content</li>
<li>&lt;0 if this is <em>nulled</em> and <code>needle</code> is not or if this is smaller than <code>needle</code>.</li>
<li>&gt;0 if this is not <em>nulled</em> but <code>needle</code> is or if this is greater than <code>needle</code>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acf92645fa8c4cc894d35fd4df0e635f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf92645fa8c4cc894d35fd4df0e635f8">&#9670;&nbsp;</a></span>ContainsAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ContainsAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code>, if the given String is found at the given position.</p>
<dl class="section note"><dt>Note</dt><dd>The following rules apply<ul>
<li>If <code>pos</code> is out of range or <code>needle</code> is <em>nulled</em>, <code>false</code> is returned. (This check only done if <code>TCheck</code> equals <code>true</code>.)</li>
<li>Otherwise, if the length of <code>needle</code> is 0, <code>true</code> is returned.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to compare with. If is <em>nulled</em> or empty, <code>true</code> is returned. </td></tr>
    <tr><td class="paramname">pos</td><td>The position to search for needle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is given, no check on parameter <code>pos</code> is performed and <code>needle</code> must not be <em>nulled</em>. </td></tr>
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>needle</code> is found at the given position. False otherwise. * </dd></dl>

</div>
</div>
<a id="ac3e160a8b59fc366a756f4b9e5aba7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e160a8b59fc366a756f4b9e5aba7b2">&#9670;&nbsp;</a></span>CopyTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> CopyTo </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Copies the strings contents into a given character buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of this string. </dd></dl>

</div>
</div>
<a id="a4c2055642e2ff907fa45012dc825a705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2055642e2ff907fa45012dc825a705">&#9670;&nbsp;</a></span>Count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startPos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Counts all occurrences of <code>needle</code> from <code>startPos</code> to the end of the string.</p>
<p>For empty strings <code>needle</code>, <code>0</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">startPos</td><td>The index to start the counting. Optional and defaults to <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>Case sensitivity of the comparison. Optional and defaults to <b>Case::Sensitive</b>. </td></tr>
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, parameter <code>startIdx</code> must be valid and <code>needle</code> must not be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first difference in <code>needle</code>. </dd></dl>

</div>
</div>
<a id="a151ecb5e80af54ad4f84f6f49af4d3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151ecb5e80af54ad4f84f6f49af4d3c9">&#9670;&nbsp;</a></span>Count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>omit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startPos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Counts all occurrences of <code>needle</code>, unless followed by <code>omit</code>, starting at <code>startPos</code> to the end of the string.</p>
<p>For empty strings <code>needle</code>, <code>0</code> is returned. Also, for empty strings <code>omit</code>, <code>0</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">omit</td><td>Omit occurrence if the given string follows. </td></tr>
    <tr><td class="paramname">startPos</td><td>The index to start the counting. Optional and defaults to <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">sensitivity</td><td>Case sensitivity of the comparison. Optional and defaults to <b>Case::Sensitive</b>. </td></tr>
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, parameter <code>startIdx</code> must be valid and <code>needle</code> must not be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first difference in <code>needle</code>. </dd></dl>

</div>
</div>
<a id="ac06a9c8f9bb2ba88baee904f7510042e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06a9c8f9bb2ba88baee904f7510042e">&#9670;&nbsp;</a></span>CountChar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CountChar </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startPos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Counts all occurrences of <code>needle</code> from <code>startPos</code> to the end of the string.</p>
<p>For empty strings <code>needle</code>, <code>0</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">startPos</td><td>The index to start the counting. Optional and defaults to <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first difference in <code>needle</code>. </dd></dl>

</div>
</div>
<a id="a2881dc9600967935c5a39536782ad818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2881dc9600967935c5a39536782ad818">&#9670;&nbsp;</a></span>CountChar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CountChar </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>omit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startPos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Counts all occurrences of <code>needle</code>, unless followed by <code>omit</code>, starting at <code>startPos</code> to the end of the string.</p>
<p>For empty strings <code>needle</code>, <code>0</code> is returned. Also, for empty strings <code>omit</code>, <code>0</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">omit</td><td>Omit occurrence if the given character follows. </td></tr>
    <tr><td class="paramname">startPos</td><td>The index to start the counting. Optional and defaults to <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first difference in <code>needle</code>. </dd></dl>

</div>
</div>
<a id="a69b6e2a03c835ca5d658a1f16acbaa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b6e2a03c835ca5d658a1f16acbaa9c">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a64c43de3fe68d6cfacf763b946b97adb">ConstIterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the first character behind this string. </p><dl class="section return"><dt>Returns</dt><dd>The end of this string. </dd></dl>

</div>
</div>
<a id="a6b3d473da02ff2622d1a90928c506876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3d473da02ff2622d1a90928c506876">&#9670;&nbsp;</a></span>EndsWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EndsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code>, if this string ends with the string found in parameter <code>needle</code>. If <code>needle</code> is <em>nulled</em> or empty, <code>true</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to compare the end of this string with. If <em>nulled</em> or empty, <code>true</code> is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>needle</code> is found at the end of this, <code>false</code> otherwise. * </dd></dl>

</div>
</div>
<a id="a80f54c9dc7947aa731b93bf3217e93f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f54c9dc7947aa731b93bf3217e93f2">&#9670;&nbsp;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Compares this with given String. <code>true</code> is returned if both are <em>nulled</em> or empty. If only one is <em>nulled</em>, <code>false</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>An String that is compared to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>, if contents of this and the given String are equal. </dd></dl>

</div>
</div>
<a id="a7365672c3c963ba88de5612e38e704bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7365672c3c963ba88de5612e38e704bd">&#9670;&nbsp;</a></span>IndexOf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOf </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches a character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the character <code>needle</code> is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a id="ac05a3241d30fde1e58d95ba1f44ee72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05a3241d30fde1e58d95ba1f44ee72d">&#9670;&nbsp;</a></span>IndexOf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOf </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches a character starting from a given position.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index in this to start searching the character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the character <code>needle</code> is not found. Otherwise the index of its first occurrence. </dd></dl>

</div>
</div>
<a id="abacc41ba7e94890340a82233f2538ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacc41ba7e94890340a82233f2538ecc">&#9670;&nbsp;</a></span>IndexOf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOf </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches a character within a region of this.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region to search the character in. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region to search the character in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the character <code>needle</code> is not found. Otherwise the index of its first occurrence. </dd></dl>

</div>
</div>
<a id="a66424c3dfeba3c25b75df951147067d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66424c3dfeba3c25b75df951147067d3">&#9670;&nbsp;</a></span>IndexOfAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOfAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the index of the first character which is included, respectively <em>not</em> included in a given set of characters.</p>
<dl class="section note"><dt>Note</dt><dd>In derived class <b>TString</b>, a faster version (using <em>std::strpbrk()</em> respectively <em>std::strspn()</em>) is available. So, if performance is important, it might be advisable to copy this <b>String</b> (and the needles) to a terminatable buffer.</dd></dl>
<p>This method searches forwards. For backwards search, see <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8bb8c82267bbb72239c9d6559cdfbf24">LastIndexOf</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needles</td><td>Pointer to a zero terminated set of characters to be taken into account. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. If the given value is less than 0, it is set to 0. If it exceeds the length of the string, the length of the string is returned. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInclusion</td><td>Denotes whether the search returns the first index that holds a value that is included or that is not excluded in the set of needle characters. </td></tr>
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is given, no parameter checks are performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character found which is included, respectively not included, in the given set of characters. If nothing is found, -1 is returned. </dd></dl>

</div>
</div>
<a id="aa38812ea513734bb82f5eba9a87eedc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38812ea513734bb82f5eba9a87eedc3">&#9670;&nbsp;</a></span>IndexOfFirstDifference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOfFirstDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a>&#160;</td>
          <td class="paramname"><em>sensitivity</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches the first difference with given string. If this string starts with <code>needle</code>, then the length of <code>needle</code> is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">sensitivity</td><td>Case sensitivity of the comparison. Optional and defaults to <b>Case::Sensitive</b>. </td></tr>
    <tr><td class="paramname">idx</td><td>The index in this to start comparing with <code>needle</code>. Optional and defaults to <code>0</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first difference found in <code>needle</code> or the neele's length. </dd></dl>

</div>
</div>
<a id="abe7d75de817ac17c9104f47991cc0ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7d75de817ac17c9104f47991cc0ae6">&#9670;&nbsp;</a></span>IndexOfOrLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOfOrLength </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Like <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a7365672c3c963ba88de5612e38e704bd">IndexOf</a> but in case the character is not found, this method returns the length of this string instead of <code>-1</code>. Depending on the invocation context, the choice for the right version of this method may lead to shorter and more efficient code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This strings <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a> if the character <code>needle</code> is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a id="acc0a1951d59db9306be459bddf0b4fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0a1951d59db9306be459bddf0b4fbb">&#9670;&nbsp;</a></span>IndexOfOrLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOfOrLength </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Like <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a7365672c3c963ba88de5612e38e704bd">IndexOf</a> but in case the character is not found, this method returns the length of this string instead of <code>-1</code>. Depending on the invocation context, the choice for the right version of this method may lead to shorter and more efficient code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index in this to start searching the character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This strings <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a> if the character <code>needle</code> is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a id="a0d261d680a9f9036a43cb7a6a4baa268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d261d680a9f9036a43cb7a6a4baa268">&#9670;&nbsp;</a></span>IndexOfSubstring()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOfSubstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches the given (unterminated) String in the Buffer.</p>
<p>If this string and string <code>needle</code> <code>needle</code> are known to be zero-terminated, it is advisable to use the faster implementation of this method, <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a7c6e1eba65efe930eedd3f64d8e70540">TString::IndexOf</a>.<br />
 This method is useful for example to search needles of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a> (which are not terminatable).</p>
<p>If <code>needle</code> is empty, <code>startIdx</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. Optional and defaults to <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>Case sensitivity of the comparison. Optional and defaults to <b>Case::Sensitive</b>. </td></tr>
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, parameter <code>startIdx</code> must be valid and <code>needle</code> must not be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the string is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a id="a8e12342fc420701fbffd97025421575a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e12342fc420701fbffd97025421575a">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code> if this string is of zero length. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the actual length equals zero. </dd></dl>

</div>
</div>
<a id="a6c546c3e5ed2e243ae839807fe633140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c546c3e5ed2e243ae839807fe633140">&#9670;&nbsp;</a></span>IsNotEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsNotEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code> if this string has a length of 1 or more. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the actual length does not equal zero. </dd></dl>

</div>
</div>
<a id="a1975261f9100a453259d7df75ad4080d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1975261f9100a453259d7df75ad4080d">&#9670;&nbsp;</a></span>IsNotNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsNotNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code> if field <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a> does not equal nullptr, <code>false</code> otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if no buffer is allocated. </dd></dl>

</div>
</div>
<a id="ac4d637a0dec45d546495c1660c9f6047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d637a0dec45d546495c1660c9f6047">&#9670;&nbsp;</a></span>IsNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code> if field <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a> equals nullptr, <code>false</code> otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if no buffer is allocated. </dd></dl>

</div>
</div>
<a id="a8bb8c82267bbb72239c9d6559cdfbf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb8c82267bbb72239c9d6559cdfbf24">&#9670;&nbsp;</a></span>LastIndexOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> LastIndexOf </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches a character starting backwards from the end or a given start index.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>false</code> is given, no range check is performed. Also, in this case, parameter startIndex must be provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The character to search for. </td></tr>
    <tr><td class="paramname">startIndex</td><td>The index in this to start searching the character. Defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the character <code>needle</code> is not found. Otherwise the index of its last occurrence relative to the start index. </dd></dl>

</div>
</div>
<a id="a3869a6fbaf8ca6e478cd119c540dffbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3869a6fbaf8ca6e478cd119c540dffbf">&#9670;&nbsp;</a></span>LastIndexOfAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> LastIndexOfAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the index of the last character which is included, respectively <em>not</em> included in a given set of characters.</p>
<p>This method searches backwards starting at the given index. For forwards search, see <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a7365672c3c963ba88de5612e38e704bd">IndexOf</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needles</td><td>Pointer to a zero terminated set of characters to be searched for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. The value is cropped to be in the bounds of 0 and the length of this object minus one. Defaults to maximum integer value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInclusion</td><td>Denotes whether the search returns the first index that holds a value that is included or that is not excluded in the set of needle characters. </td></tr>
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is given, no parameter checks are performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character found which is included, respectively not included, in the given set of characters. If nothing is found, -1 is returned. </dd></dl>

</div>
</div>
<a id="a78a515bdd031a8d3b713bb05edcf126c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a515bdd031a8d3b713bb05edcf126c">&#9670;&nbsp;</a></span>Length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> Length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the length of the string we are representing.</p>
<dl class="section return"><dt>Returns</dt><dd>The length of the string represented by this. </dd></dl>

</div>
</div>
<a id="a22b94d6b436e0098cf9d92ba846c02e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b94d6b436e0098cf9d92ba846c02e9">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a80f54c9dc7947aa731b93bf3217e93f2">Equals</a> with parameter <code>op</code> to test on equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the strings are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab64e70a5dacaf96051001c5ac1ba42d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64e70a5dacaf96051001c5ac1ba42d4">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a804faaeae51297434cd4b197353134d9">CompareTo</a> with parameter <code>op</code> to perform a lexical comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is lexically smaller then <code>op</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad898a3ce164c9108bc941ee7ba17c79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad898a3ce164c9108bc941ee7ba17c79c">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a804faaeae51297434cd4b197353134d9">CompareTo</a> with parameter <code>op</code> to perform a lexical comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is lexically smaller or equal then <code>op</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ace88722db3a272610fbc7f8fccd9e258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace88722db3a272610fbc7f8fccd9e258">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a80f54c9dc7947aa731b93bf3217e93f2">Equals</a> with parameter <code>op</code> to test on equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the strings are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac02f8b4c5f15456011760d3690065335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02f8b4c5f15456011760d3690065335">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a804faaeae51297434cd4b197353134d9">CompareTo</a> with parameter <code>op</code> to perform a lexical comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is lexically greater then <code>op</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aa27d29bb45f71f78f23cf9f13b1f363a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27d29bb45f71f78f23cf9f13b1f363a">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a804faaeae51297434cd4b197353134d9">CompareTo</a> with parameter <code>op</code> to perform a lexical comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The string to compare this string with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is lexically greater or equal then <code>op</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a227e5bdf7a6d162da1ba47c39063b417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227e5bdf7a6d162da1ba47c39063b417">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Reads a character at a given index.</p>
<dl class="section attention"><dt>Attention</dt><dd>Unlike other operator methods in the family of of <b>ALib</b> string classes, which are performing parameter checks (in this case a range check), this operator does <em>not</em> do a check!<br />
 The rationale is that in derived class AString, which overrides this operator returning, a reference to the character to provide write access, no reference to a character can be given if the index is out of range. This way, this method is equivalent to method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a7024029ef608b45471c5f31cb381f596">CharAt</a>&lt;<code>false&gt;</code>.<br />
 For safe access to characters in the buffer use <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a7024029ef608b45471c5f31cb381f596">CharAt</a> (with template parameter <code>TCheck</code> being <code>true</code>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the character within this objects' buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the character contained at index <code>op</code>. </dd></dl>

</div>
</div>
<a id="a50a93ef6cd1a8deaacbb3ab99c07eb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a93ef6cd1a8deaacbb3ab99c07eb80">&#9670;&nbsp;</a></span>StartsWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StartsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code>, if this string starts with the string found in parameter <code>needle</code>. If <code>needle</code> is <em>nulled</em> or empty, <code>true</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The string to compare the start of this string with. If <em>nulled</em> or empty, <code>true</code> is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSensitivity</td><td>Determines if comparison is case sensitive (the default) or not. </td></tr>
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is given, the given needle must not be empty and must not be longer than this string! <code>pos</code> is performed and <code>needle</code> must not be <em>nulled</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>needle</code> is found at the start of this, <code>false</code> otherwise. * </dd></dl>

</div>
</div>
<a id="afad765c530b9d43175f20bdcf968451a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad765c530b9d43175f20bdcf968451a">&#9670;&nbsp;</a></span>ToWString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> ToWString </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Converts a region of this string into a wide character string. The conversion is done using</p><ul>
<li><em>mbsnrtowcs()</em> on glibc platforms (e.g. Linux)</li>
<li><em>MultiByteToWideChar(CP_UTF8,...)</em> on the Windows platform.</li>
</ul>
<p>The destination string will be zero terminated.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For the reverse action, namely to convert wide characters to multi-byte characters, use class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> with template method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ab6c3f64bbc79da9399975d250584f428">AString::Apply</a> e.g. by using operator <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ac243bc3f2d0f61eb45d49f488ddbcb63">AString::operator&lt;&lt;(const T&amp;)</a> with T being <em>[const] wchar_t*</em>.</li>
<li>On Linux, it might be necessary to invoke std function <em>setlocale()</em> once, prior to using this method. This, by default, is done in <a class="el" href="classaworx_1_1lib_1_1lang_1_1Library.html#abad644913fc967938ede0607a353e29c">ALib::Init</a>.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer. </td></tr>
    <tr><td class="paramname">destCapacity</td><td>The size of the destination buffer. Has to be equal or greater than the provided region length plus one for termination. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in this to convert. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The maximum length of the region in this to convert. Optional and defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the length of converted destination string. -1 for conversion failure, -2 if destination buffer was too small. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="adae84acc92cd77a04f6aaf533643a33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae84acc92cd77a04f6aaf533643a33a">&#9670;&nbsp;</a></span>buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to an array of characters that holds the string we are representing. Read access to this field is granted with method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8e9993430d0c6b4f328b2884216ef87a">Buffer</a>. </p>

</div>
</div>
<a id="af940c51e198511031f839dec6e7f1b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af940c51e198511031f839dec6e7f1b71">&#9670;&nbsp;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The length of the string represented by us. Read access to this field is granted with method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a>. </p>

</div>
</div>
<a id="ab060ffba71bd8a3d7067a38950b39a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab060ffba71bd8a3d7067a38950b39a82">&#9670;&nbsp;</a></span>vbuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* vbuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Non-constant version of field <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a>. This field is not used in this class, but has to be declared here, because it constitutes an anonymous union with field <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a>. Derived classes might use and expose this field, like e.g. class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> does. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="string_8hpp_source.html">string.hpp</a></li>
<li>stringlib.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 28 2018 20:08:33 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
<!-- Start of StatCounter Code e -->
<script type="text/javascript">
var sc_project=11242602;
var sc_invisible=1;
var sc_security="5ac13373";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web statistics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11242602/0/5ac13373/1/" alt="web
statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
