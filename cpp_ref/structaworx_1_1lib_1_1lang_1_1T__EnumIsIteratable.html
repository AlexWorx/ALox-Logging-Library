<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALox: T_EnumIsIteratable&lt; TEnum, TCheckEnum &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1712 R. 1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--ALox Main Menu-->
<div style="background: #2f3a48; " >
<table  class="aworx-menutable"  >
 <tbody>
 <tr style="height: 36px;">
  <td> <a class="aworx-menu"    href="../index.html"                                   >Home</a>                     </td>
  <td> <a class="aworx-menu_hl" href="../cpp_ref/alox_cpp_mainpage.html"                >ALox for C++</a>             </td>
  <td> <a class="aworx-menu"    href="../cs_ref/alox_cs_mainpage.html"                  >ALox for C#</a>              </td>
  <td> <a class="aworx-menu"    href="../java_ref/alox_java_mainpage.html"              >ALox for Java</a>            </td>
  <td> <a class="aworx-menu"    href="https://github.com/AlexWorx/ALox-Logging-Library">Download</a></td>
 </tr>
 </tbody>
</table>
</div>
<!--end ALox Main Menu-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html">lang</a></li><li class="navelem"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsIteratable.html">T_EnumIsIteratable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-attribs">Public Static Fields</a> &#124;
<a href="structaworx_1_1lib_1_1lang_1_1T__EnumIsIteratable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">T_EnumIsIteratable&lt; TEnum, TCheckEnum &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="enumiterators_8hpp_source.html">enumiterators.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for T_EnumIsIteratable&lt; TEnum, TCheckEnum &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structaworx_1_1lib_1_1lang_1_1T__EnumIsIteratable__inherit__graph.svg" width="292" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for T_EnumIsIteratable&lt; TEnum, TCheckEnum &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structaworx_1_1lib_1_1lang_1_1T__EnumIsIteratable__coll__graph.svg" width="292" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><h3>template&lt;typename TEnum, typename TCheckEnum = typename std::enable_if&lt;std::is_enum&lt;TEnum&gt;::value&gt;::type&gt;<br />
struct aworx::lib::lang::T_EnumIsIteratable&lt; TEnum, TCheckEnum &gt;</h3>

<h1>Introduction</h1>
<p>Standard iterator functionality <code>std::iterator</code> and C++ 11 keyword <code>for( : )</code> are not supported with C++ enumerations - and this is obvious because enumerations are types and not containers or other iteratable objects.<br />
</p>
<p>Nevertheless it would still be nice if they were!</p>
<h1>ALib Enum Iteration</h1>
<p>To have an easy mechanism for iterating over enum types, this TMP struct may be specialized. The restriction for doing this for template type <code>TEnum</code> needs to fulfill the following constraint:<br />
</p>
<p><b><em> TEnum is "sparsely" defined, which means the difference of the integer value which is underlying each of its elements, is always <code>+1</code>, starting from the first to the last element.<br />
 (While the first element does not necessarily need to start with integer value <code>0</code>.) </em></b></p>
<dl class="section attention"><dt>Attention</dt><dd><b>ALib</b> is not able to check if this requirement is met for a given type. It is the users responsibility do ensure this and specialize this TMP struct only for such types.</dd></dl>
<p>As a sample, let us look at the simple enum type introduced in documentation of <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">T_EnumMetaDataDecl</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>MyNamespace</div><div class="line">{</div><div class="line">    <span class="keyword">enum class</span> Pets</div><div class="line">    {</div><div class="line">        Cat,</div><div class="line">        Dog,</div><div class="line">        Bird,</div><div class="line">        Snake,</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p> It is obvious that this enum fulfills the requirements. In that same sample, a code iterating over all enumerations was presented:</p>
<div class="fragment"><div class="line"><span class="comment">// A vector of pets</span></div><div class="line">std::vector&lt;Pets&gt; pets= { Pets::Cat, Pets::Dog, Pets::Bird, Pets::Snake };</div><div class="line"></div><div class="line"><span class="comment">// loop over them</span></div><div class="line"><span class="keyword">auto</span>&amp; enumMetaData= *<a class="code" href="classaworx_1_1lib_1_1lang_1_1Singleton.html#aacc819bf0193ea5e1185fc98291b03aa">aworx::EnumMetaData&lt;Pets&gt;::GetSingleton</a>();</div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span> pet : pets )</div><div class="line">{</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A &quot;</span>     &lt;&lt; <a class="code" href="structaworx_1_1lib_1_1lang_1_1EnumReadWriteInfo.html#a3a4f86d809607a8ad171af4f2b86afc9">aworx::EnumReadWriteInfo&lt;Pets&gt;::Name</a>( enumMetaData, pet )</div><div class="line">         &lt;&lt; <span class="stringliteral">&quot; has &quot;</span>  &lt;&lt; enumMetaData.Value&lt;1&gt;( pet ) &lt;&lt; <span class="stringliteral">&quot; legs&quot;</span></div><div class="line">         &lt;&lt; <span class="stringliteral">&quot; and &quot;</span>  &lt;&lt; enumMetaData.Value&lt;2&gt;( pet ) &lt;&lt; <span class="stringliteral">&quot; wings!&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p> Here, the enums are stuffed in a <code>std::vector</code> to be iteratable. This is inefficient and duplicate code in respect to naming all enums in two places.</p>
<p>So let us specialize this struct for <code>MyNamespace::Pets</code>. We use helper macro <a class="el" href="group__GrpALibMacros.html#ga89d74128f653f1aaf15a9889b37460ab">ALIB_LANG_ENUM_IS_ITERATABLE</a> to do so:</p>
<div class="fragment"><div class="line"><a class="code" href="group__GrpALibMacros.html#ga89d74128f653f1aaf15a9889b37460ab">ALIB_LANG_ENUM_IS_ITERATABLE</a>(MyNamespace::Pets, MyNamespace::Pets::Snake + 1 )</div></div><!-- fragment --><p> Now, we do not need the vector any more. Instead we use template class <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumIterator.html">EnumIterator</a>, which is provided exactly for this reason, in the <code>for</code> statement. The code can be rewritten as follows: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; enumMetaData= *<a class="code" href="classaworx_1_1lib_1_1lang_1_1Singleton.html#aacc819bf0193ea5e1185fc98291b03aa">aworx::EnumMetaData&lt;Pets&gt;::GetSingleton</a>();</div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span> pet : <a class="code" href="structaworx_1_1lib_1_1lang_1_1EnumIterator.html">aworx::EnumIterator&lt;Pets&gt;</a>() )</div><div class="line">{</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A &quot;</span>     &lt;&lt; <a class="code" href="structaworx_1_1lib_1_1lang_1_1EnumReadWriteInfo.html#a3a4f86d809607a8ad171af4f2b86afc9">aworx::EnumReadWriteInfo&lt;Pets&gt;::Name</a>( enumMetaData, pet )</div><div class="line">         &lt;&lt; <span class="stringliteral">&quot; has &quot;</span>  &lt;&lt; enumMetaData.Value&lt;1&gt;( pet ) &lt;&lt; <span class="stringliteral">&quot; legs&quot;</span></div><div class="line">         &lt;&lt; <span class="stringliteral">&quot; and &quot;</span>  &lt;&lt; enumMetaData.Value&lt;2&gt;( pet ) &lt;&lt; <span class="stringliteral">&quot; wings!&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><h1>Details</h1>
<h3>Enum Types Use "Underlying" Integer Types</h3>
<p>Above we used </p><div class="fragment"><div class="line"><a class="code" href="group__GrpALibMacros.html#ga89d74128f653f1aaf15a9889b37460ab">ALIB_LANG_ENUM_IS_ITERATABLE</a>(MyNamespace::Pets, MyNamespace::Pets::Snake + 1 )</div></div><!-- fragment --><p>to announce enum <code>Pets</code> to <b>ALib</b>. Besides the enum type, the macro expects the "value of the enum element behind the last one". Well, if you find this phrasing irritating or even wrong, then look at the following correct C++ code:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> Numbers</div><div class="line">{</div><div class="line">    zero,   <span class="comment">// underlying int value: 0</span></div><div class="line">    one,    <span class="comment">// underlying int value: 1</span></div><div class="line">    two,    <span class="comment">// underlying int value: 2</span></div><div class="line">};</div></div><!-- fragment --> <div class="fragment"><div class="line">Numbers aThree= Numbers(3);</div></div><!-- fragment --><p> Well, that enough to say: It is not our fault, it no ones fault, C++ is just an effective language.</p>
<h3>Add and Subtract Operators</h3>
<p>We look at the same code once more: </p><div class="fragment"><div class="line"><a class="code" href="group__GrpALibMacros.html#ga89d74128f653f1aaf15a9889b37460ab">ALIB_LANG_ENUM_IS_ITERATABLE</a>(MyNamespace::Pets, MyNamespace::Pets::Snake + 1 )</div></div><!-- fragment --><p>You might have noticed that the term <code>MyNamespace::Pets::Snake + 1</code> usually is not valid C++ code, as we are adding an integer value to a C++ 11 scoped enum type.</p>
<p>The reason why this still compiles is that <b>ALib</b> provides operators</p><ul>
<li><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9b25f4952e506a7a23659009e64d3787">operator+</a>&lt;TEnum, int&gt;</li>
<li><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a36dbf1c0dea06c0523493060c2be305c">operator-</a>&lt;TEnum, int&gt; which accepts an <code>TEnum</code> at the left hand side and an <code>int</code> on the right.</li>
</ul>
<p>Similar to various operator functions provided with <b>ALib</b> that are only applicable to types that have a specialization of TMP struct <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> in place, these operators are only applicable to types that have a specialization of this TMP struct, <b>T_EnumIsIteratable</b> in place, what is just happening within that code line!</p>
<h3>Stop Enums</h3>
<p>In the sample discussed, <code>Pets::Snake + 1</code> was used as the "end value" of an iteration. This is error prone in the respect that if the enumeration type gets extended, our macro invocation might be changes, as <code>Pets::Snake</code> then is not the last in the list.</p>
<p>A way out, is to add a "stopper" element to the enumeration and name it special, e.g. in upper case <code>"END_OF_ENUM"</code>. It is then rather unlikely, that some programmer would put a new element behind this one. The macro invocation would never be needed to changed: </p><pre class="fragment"> ALIB_LANG_ENUM_IS_ITERATABLE(MyEnum, MyEnum::END_OF_ENUM )
</pre><p>A next advantage is that within the enum declaration itself it becomes obvious that this is an iteratable enum type and somewhere the specialization for <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsIteratable.html">T_EnumIsIteratable</a> is found.<br />
 Of-course, the drawback is that an enum element is presented to the C++ compiler that is not an element like the other ones...</p>
<p>In consideration to <b>ALib</b> <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">enum meta data feature</a>, adding such a stopper is no problem. At least for the built-in mechanisms. When custom meta data types are used, then the programmer may judge which way to go.</p>
<h3>Start Enums</h3>
<p>So far, all our samples used macro</p><ul>
<li><a class="el" href="group__GrpALibMacros.html#ga89d74128f653f1aaf15a9889b37460ab">ALIB_LANG_ENUM_IS_ITERATABLE</a></li>
</ul>
<p>to specialize this struct. In fact, this macro is just a shortcut to macro</p><ul>
<li><a class="el" href="group__GrpALibMacros.html#ga2a3bf668cc9a30831855929ab14e0e3c">ALIB_LANG_ENUM_IS_ITERATABLE_BEGIN_END</a></li>
</ul>
<p>passing <code>TEnum(0)</code> as a start value.</p>
<p>This lifts the restriction of having integer <code>0</code> underlying the first enum element. To do might be useful when different types scoped enum values passed around as values (which can be done in a type safe way using <b>ALib</b> <a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a>). Of-course, this is never recommended, but there are situations where it is just a must, i.e. if result codes have to be passed to libraries of different programming languages. It is still better to use scope enums internally in the C++ code and "export" their values as needed than using non-scoped enums internally.</p>
<h3>Iterator Type</h3>
<p>The <code>std::iterator</code> returned with methods <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumIterator.html#ad5fee900c7aee90671038c79225bf8ec">EnumIterator::begin</a> and <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumIterator.html#ad5fee900c7aee90671038c79225bf8ec">EnumIterator::begin</a> implements the standard library concept of "RandomAccessIterator". Hence, it has various operators, including subscript <code>operator</code>[].</p>
<h2>Bitwise Enums And Iteration</h2>
<p>Iteration works well, if an enumeration is declared <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">bitwise</a>. The restriction described in the introduction above, that the enum must not be "sparsely" defined, in this case means that, every next enum element has the next bit set, hence its internal value is doubled.</p>
<p>If this struct is specialized for a bitwise enum type using shortcut macro <a class="el" href="group__GrpALibMacros.html#ga89d74128f653f1aaf15a9889b37460ab">ALIB_LANG_ENUM_IS_ITERATABLE</a>, the start element with integer value <code>1</code> is chosen. If <a class="el" href="group__GrpALibMacros.html#ga2a3bf668cc9a30831855929ab14e0e3c">ALIB_LANG_ENUM_IS_ITERATABLE_BEGIN_END</a> is used, iteration might start on higher values.</p>
<p>In short: everything said above, equally applies to bitwise enumerations.</p>
<h2>Performance Considerations</h2>
<p>Class <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumIterator.html">EnumIterator</a> is empty in respect to fields. Created on the stack there is no performance penalty. The same is true for the internal iterator type, which is returned with class <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumIterator.html#ad5fee900c7aee90671038c79225bf8ec">EnumIterator::begin</a> and class <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumIterator.html#a69b6e2a03c835ca5d658a1f16acbaa9c">EnumIterator::end</a>. This iterator class uses an <code>TEnum</code> element as its only field member. While the code with operators, casting and conversion seems quite complex, at least with compiler optimizations turned on (release builds), the loop will perform the same as an integer while loop: </p><pre class="fragment"> int i= 0; int stop= 5;
 while( i++ &lt; stop) { ... }
</pre><p>This is a matter of the magic of C++ templates!</p>
<h1>Reference Documentation</h1>
<dl class="section note"><dt>Note</dt><dd>The methods of the base version of this TMP struct are <b>not</b> defined, but rather "tricked" into this documentation. Only if specialized with corresponding macros <a class="el" href="group__GrpALibMacros.html#ga89d74128f653f1aaf15a9889b37460ab">ALIB_LANG_ENUM_IS_ITERATABLE</a> and <a class="el" href="group__GrpALibMacros.html#ga2a3bf668cc9a30831855929ab14e0e3c">ALIB_LANG_ENUM_IS_ITERATABLE_BEGIN_END</a> they will be implemented.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>The enum type to provide information for. </td></tr>
    <tr><td class="paramname">TCheckEnum</td><td>This parameter has a default expressions and <b>must not</b> be provided with specializations of this struct. It is used internally to ensure that only enum types are to be used with the first template parameter <code>TEnum</code>. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Public Static Fields</h2></td></tr>
<tr class="memitem:a65226c6f9f3f79a49956165dd72b2b5c"><td class="memItemLeft" align="right" valign="top">static constexpr TEnum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsIteratable.html#a65226c6f9f3f79a49956165dd72b2b5c">Begin</a></td></tr>
<tr class="separator:a65226c6f9f3f79a49956165dd72b2b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08bfb8055a6a09ad8cbe1f7466a73a1"><td class="memItemLeft" align="right" valign="top">static constexpr TEnum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsIteratable.html#aa08bfb8055a6a09ad8cbe1f7466a73a1">End</a></td></tr>
<tr class="separator:aa08bfb8055a6a09ad8cbe1f7466a73a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a65226c6f9f3f79a49956165dd72b2b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65226c6f9f3f79a49956165dd72b2b5c">&#9670;&nbsp;</a></span>Begin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TEnum Begin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specializations have to return the first enum element of the iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>The first enumeration element. </dd></dl>

</div>
</div>
<a id="aa08bfb8055a6a09ad8cbe1f7466a73a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08bfb8055a6a09ad8cbe1f7466a73a1">&#9670;&nbsp;</a></span>End</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TEnum End</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specializations have to return the element value after the last enum element of the iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>The element after the last enumeration element. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="enumiterators_8hpp_source.html">enumiterators.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 28 2018 20:08:33 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
<!-- Start of StatCounter Code e -->
<script type="text/javascript">
var sc_project=11242602;
var sc_invisible=1;
var sc_security="5ac13373";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web statistics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11242602/0/5ac13373/1/" alt="web
statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
