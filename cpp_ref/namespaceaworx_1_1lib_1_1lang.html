<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALox: aworx::lib::lang Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1712 R. 1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--ALox Main Menu-->
<div style="background: #2f3a48; " >
<table  class="aworx-menutable"  >
 <tbody>
 <tr style="height: 36px;">
  <td> <a class="aworx-menu"    href="../index.html"                                   >Home</a>                     </td>
  <td> <a class="aworx-menu_hl" href="../cpp_ref/alox_cpp_mainpage.html"                >ALox for C++</a>             </td>
  <td> <a class="aworx-menu"    href="../cs_ref/alox_cs_mainpage.html"                  >ALox for C#</a>              </td>
  <td> <a class="aworx-menu"    href="../java_ref/alox_java_mainpage.html"              >ALox for Java</a>            </td>
  <td> <a class="aworx-menu"    href="https://github.com/AlexWorx/ALox-Logging-Library">Download</a></td>
 </tr>
 </tbody>
</table>
</div>
<!--end ALox Main Menu-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html">lang</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Nested namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">aworx::lib::lang Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Namespace Description</h2>
<div class="textblock"><hr/>
<p> This namespace collects very basic utilities for <a class="el" href="namespaceaworx_1_1lib.html">ALib</a>, close to the C++ language.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Within the source folder of this namespace, also file <code><a class="el" href="prepro_8hpp.html">prepro.hpp</a></code> is found, which sets up all basic <b>ALib</b> preprocessor definitions. Further preprocessor macros are defined in various places (where they belong to). An overview of all preprocessor symbols of this and other namespaces of <b>ALib</b> is given with <a class="el" href="group__GrpALibMacros.html">ALib Macros</a>.</li>
<li>A list of <b>general enumerations</b> is found in this namespace. It is arguable and a matter of taste, whether enumerations should be declared near or inside the class which is using it, or in a separated place like this namespace introduced here.<br />
 <b>ALib</b> follows the second approach (not strictly, domain specific enums might appear also inside classes) and this has the following reasons:<ul>
<li>To shorten the code when using the enums.</li>
<li>To reach a maximum degree of source compatibility between the different programming language versions of <b>ALib</b>.</li>
<li>To make the enums reusable with different classes. </li>
</ul>
</li>
</ul>
</dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Nested namespaces</h2></td></tr>
<tr class="memitem:namespaceaworx_1_1lib_1_1lang_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumIterator.html">EnumIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html">EnumMetaData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumReadWriteInfo.html">EnumReadWriteInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1lang_1_1Exception.html">Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1lang_1_1Lang.html">Lang</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1lang_1_1Library.html">Library</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1lang_1_1Ownable.html">Ownable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Owner.html">Owner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1lang_1_1Report.html">Report</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1lang_1_1ReportWriter.html">ReportWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1lang_1_1ReportWriterStdIO.html">ReportWriterStdIO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1lang_1_1ResourcedTupleLoader.html">ResourcedTupleLoader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1lang_1_1Resources.html">Resources</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1lang_1_1Singleton.html">Singleton</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1std__EnumEquals.html">std_EnumEquals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1std__EnumHash.html">std_EnumHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsIteratable.html">T_EnumIsIteratable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">T_EnumMetaDataDecl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDeclReadWrite.html">T_EnumMetaDataDeclReadWrite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataPreAndPostFix.html">T_EnumMetaDataPreAndPostFix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataSpecification.html">T_EnumMetaDataSpecification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__Resourced.html">T_Resourced</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a050df5b24462b4a6256f2ed69c6b50ae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a050df5b24462b4a6256f2ed69c6b50ae">integer</a> = platform_specific</td></tr>
<tr class="separator:a050df5b24462b4a6256f2ed69c6b50ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9eb8b6fb1aab7d526e9419b10fd5363"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af9eb8b6fb1aab7d526e9419b10fd5363">intGap_t</a> = platform_specific</td></tr>
<tr class="separator:af9eb8b6fb1aab7d526e9419b10fd5363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b8595314b87c0141d68dc0c312f30e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a03b8595314b87c0141d68dc0c312f30e">uinteger</a> = platform_specific</td></tr>
<tr class="separator:a03b8595314b87c0141d68dc0c312f30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89f60b8bbbc054d70fa7c5b19627b93"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ae89f60b8bbbc054d70fa7c5b19627b93">uintGap_t</a> = platform_specific</td></tr>
<tr class="separator:ae89f60b8bbbc054d70fa7c5b19627b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acdfaca60ec19c0265bac2692d7982726"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#acdfaca60ec19c0265bac2692d7982726">Alignment</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#acdfaca60ec19c0265bac2692d7982726a945d5e233cf7d6240f6b783b36a374ff">Left</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#acdfaca60ec19c0265bac2692d7982726a92b09c7c48c520c3c55e497875da437c">Right</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#acdfaca60ec19c0265bac2692d7982726a4f1f6016fc9f3f2353c0cc7c67b292bd">Center</a>
 }</td></tr>
<tr class="memdesc:acdfaca60ec19c0265bac2692d7982726"><td class="mdescLeft">&#160;</td><td class="mdescRight">[DOX_ALIB_LANG_ENUMS_PARSABLE_1]  <a href="namespaceaworx_1_1lib_1_1lang.html#acdfaca60ec19c0265bac2692d7982726">More...</a><br /></td></tr>
<tr class="separator:acdfaca60ec19c0265bac2692d7982726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39db6982619d623273fad8a383489309"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a39db6982619d623273fad8a383489309">Bool</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a39db6982619d623273fad8a383489309af8320b26d30ab433c5a54546d21f414c">False</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a39db6982619d623273fad8a383489309af827cf462f62848df37c5e1e94a4da74">True</a>
 }</td></tr>
<tr class="separator:a39db6982619d623273fad8a383489309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9aab17a5e54a8bae6915bc24db13a17"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">Case</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">Sensitive</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17afd038fc7f319e48f3115d92bf5bdbef9">Ignore</a>
 }</td></tr>
<tr class="memdesc:ab9aab17a5e54a8bae6915bc24db13a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">[DOX_ALIB_LANG_ENUMS_PARSABLE_1]  <a href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">More...</a><br /></td></tr>
<tr class="separator:ab9aab17a5e54a8bae6915bc24db13a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d9cc1e6686eca6e60d57d959cf57fb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af6d9cc1e6686eca6e60d57d959cf57fb">ContainerOp</a> { <br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af6d9cc1e6686eca6e60d57d959cf57fbaa458be0f08b7e4ff3c0f633c100176c0">Insert</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af6d9cc1e6686eca6e60d57d959cf57fba1063e38cb53d94d386f21227fcd84717">Remove</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af6d9cc1e6686eca6e60d57d959cf57fbac55582518cba2c464f29f5bae1c68def">Get</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af6d9cc1e6686eca6e60d57d959cf57fba1d5c1a7fde77e84c993d6fea61f88c2a">GetCreate</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af6d9cc1e6686eca6e60d57d959cf57fba686e697538050e4664636337cc3b834f">Create</a>
<br />
 }</td></tr>
<tr class="separator:af6d9cc1e6686eca6e60d57d959cf57fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55781bd0c78c4e5d47ce433f4eeeee85"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a55781bd0c78c4e5d47ce433f4eeeee85">Create</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a55781bd0c78c4e5d47ce433f4eeeee85a6e7b34fa59e1bd229b207892956dc41c">Never</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a55781bd0c78c4e5d47ce433f4eeeee85a44c32ea9ad0b836b68c25fdb717fa4b7">IfNotExistent</a>
 }</td></tr>
<tr class="separator:a55781bd0c78c4e5d47ce433f4eeeee85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9345007d67faa05253932092d54d10d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9345007d67faa05253932092d54d10d4">CurrentData</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9345007d67faa05253932092d54d10d4a02bce93bff905887ad2233110bf9c49e">Keep</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9345007d67faa05253932092d54d10d4adc30bc0c7914db5918da4263fce93ad2">Clear</a>
 }</td></tr>
<tr class="separator:a9345007d67faa05253932092d54d10d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d828d7f6e0c02a7815c7e1308d3b06e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a8d828d7f6e0c02a7815c7e1308d3b06e">Exceptions</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a8d828d7f6e0c02a7815c7e1308d3b06ea7946215ab743bd9d347d313643ca72dd">ErrorWritingReport</a> = 1
 }</td></tr>
<tr class="separator:a8d828d7f6e0c02a7815c7e1308d3b06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217539925b78b2eed40ae7817d5bee52"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a217539925b78b2eed40ae7817d5bee52">Inclusion</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a217539925b78b2eed40ae7817d5bee52af4d72a64acd8929c0cc9ed96a7a336cc">Include</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a217539925b78b2eed40ae7817d5bee52a843f2812f595e7ec7c5036e89fde02d6">Exclude</a>
 }</td></tr>
<tr class="separator:a217539925b78b2eed40ae7817d5bee52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fc859257c8f09ff9198dde28121961"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a00fc859257c8f09ff9198dde28121961">LockMode</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a00fc859257c8f09ff9198dde28121961a556c3dd912453ae5cb3095cd5054e6f4">Recursive</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a00fc859257c8f09ff9198dde28121961a67b491789a29d0c717a2b4ebe369a936">SingleLocks</a>
 }</td></tr>
<tr class="separator:a00fc859257c8f09ff9198dde28121961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c5184dc404edf057ed537bcfddef84"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84">Phase</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84a1a06729125544cab7cee73195fc044f0">Begin</a> = (1 &lt;&lt; 0), 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84a87557f11575c0ad78e4e28abedc13b6e">End</a> = (1 &lt;&lt; 1)
 }</td></tr>
<tr class="separator:ae1c5184dc404edf057ed537bcfddef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae0c2d4659a32ef54bd221d1a3da4e6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#aeae0c2d4659a32ef54bd221d1a3da4e6">Propagation</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#aeae0c2d4659a32ef54bd221d1a3da4e6a3f9823fc8c5bf8d5efbb0ad3be5f16c9">Omit</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#aeae0c2d4659a32ef54bd221d1a3da4e6aa9857b4deb35c57d5753f94fa00a028e">ToDescendants</a>
 }</td></tr>
<tr class="separator:aeae0c2d4659a32ef54bd221d1a3da4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9537c0a8df05f0a728b6e2a89c7f3a1b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9537c0a8df05f0a728b6e2a89c7f3a1b">Reach</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9537c0a8df05f0a728b6e2a89c7f3a1ba4cc6684df7b4a92b1dec6fce3264fac8">Global</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9537c0a8df05f0a728b6e2a89c7f3a1ba509820290d57f333403f490dde7316f4">Local</a>
 }</td></tr>
<tr class="separator:a9537c0a8df05f0a728b6e2a89c7f3a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5305b978950ba3946cf79a4bccbf7af"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab5305b978950ba3946cf79a4bccbf7af">Responsibility</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab5305b978950ba3946cf79a4bccbf7afa2540530a938da82bfe62957f4aff599b">KeepWithSender</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab5305b978950ba3946cf79a4bccbf7afa6950810f0d2bba97a6f710c7b965b84e">Transfer</a>
 }</td></tr>
<tr class="separator:ab5305b978950ba3946cf79a4bccbf7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c800527afe0a8a6c71ae4cceda6bf9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a8c800527afe0a8a6c71ae4cceda6bf9d">Safeness</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a8c800527afe0a8a6c71ae4cceda6bf9dac6eea0560cd6f377e78dff2c85cc9122">Safe</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a8c800527afe0a8a6c71ae4cceda6bf9dad3d57868b6ff9839eff631d2cc8acbce">Unsafe</a>
 }</td></tr>
<tr class="separator:a8c800527afe0a8a6c71ae4cceda6bf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9be72f666a31b4318bbc8e8a16a9472"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ad9be72f666a31b4318bbc8e8a16a9472">SortOrder</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ad9be72f666a31b4318bbc8e8a16a9472acf3fb1ff52ea1eed3347ac5401ee7f0c">Ascending</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ad9be72f666a31b4318bbc8e8a16a9472ae3cf5ac19407b1a62c6fccaff675a53b">Descending</a>
 }</td></tr>
<tr class="separator:ad9be72f666a31b4318bbc8e8a16a9472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0acd6daf9443d8b997f1035cfe08dd8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab0acd6daf9443d8b997f1035cfe08dd8">SourceData</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab0acd6daf9443d8b997f1035cfe08dd8a5fb63579fc981698f97d55bfecb213ea">Copy</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab0acd6daf9443d8b997f1035cfe08dd8a6bc362dbf494c61ea117fe3c71ca48a5">Move</a>
 }</td></tr>
<tr class="separator:ab0acd6daf9443d8b997f1035cfe08dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3c28a2cb05bdcc618b542e49bfda3f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9f3c28a2cb05bdcc618b542e49bfda3f">Switch</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9f3c28a2cb05bdcc618b542e49bfda3fad15305d7a4e34e02489c74a5ef542f36">Off</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9f3c28a2cb05bdcc618b542e49bfda3fa521c36a31c2762741cf0f8890cbe05e3">On</a>
 }</td></tr>
<tr class="separator:a9f3c28a2cb05bdcc618b542e49bfda3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1d8f31e178e17a8fef3a9e94bc4b2c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9b1d8f31e178e17a8fef3a9e94bc4b2c">Timezone</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9b1d8f31e178e17a8fef3a9e94bc4b2ca509820290d57f333403f490dde7316f4">Local</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9b1d8f31e178e17a8fef3a9e94bc4b2ca9234324ddf6b4176b57d803a925b7961">UTC</a>
 }</td></tr>
<tr class="separator:a9b1d8f31e178e17a8fef3a9e94bc4b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a46f9fb632511f6be7c53e05f330f7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ad4a46f9fb632511f6be7c53e05f330f7">Whitespaces</a> { <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ad4a46f9fb632511f6be7c53e05f330f7a1fc5884251ca9f20a4fd5f79a458f94f">Trim</a>, 
<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ad4a46f9fb632511f6be7c53e05f330f7a02bce93bff905887ad2233110bf9c49e">Keep</a>
 }</td></tr>
<tr class="separator:ad4a46f9fb632511f6be7c53e05f330f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a20cbd716cfc046a49f72978689279f29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a20cbd716cfc046a49f72978689279f29">DeleteSingletons</a> ()</td></tr>
<tr class="separator:a20cbd716cfc046a49f72978689279f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd18b7e35e747c3e86275c57311cb1b"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a2fd18b7e35e747c3e86275c57311cb1b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt; TEnum &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a2fd18b7e35e747c3e86275c57311cb1b">EnumContains</a> (TEnum tested, TEnum testFor) noexcept(true)</td></tr>
<tr class="separator:a2fd18b7e35e747c3e86275c57311cb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84494f1a492417b7b96bb8dfcd9c4c02"><td class="memTemplParams" colspan="2">template&lt;typename TEnum , typename TEnableIf  = typename std::enable_if&lt;std::is_enum&lt;TEnum&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a84494f1a492417b7b96bb8dfcd9c4c02"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::underlying_type&lt; TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a> (TEnum element) noexcept(true)</td></tr>
<tr class="separator:a84494f1a492417b7b96bb8dfcd9c4c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ecab83cce9a39585a8db8fdf597ee7"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:ac5ecab83cce9a39585a8db8fdf597ee7"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ac5ecab83cce9a39585a8db8fdf597ee7">operator &amp;</a> (TEnum lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:ac5ecab83cce9a39585a8db8fdf597ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09304aaeeffaac2fb8693a970692a534"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a09304aaeeffaac2fb8693a970692a534"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a09304aaeeffaac2fb8693a970692a534">operator &amp;=</a> (TEnum &amp;lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:a09304aaeeffaac2fb8693a970692a534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cf70cfe5f4471794b397e3473ea31a"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:ad1cf70cfe5f4471794b397e3473ea31a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ad1cf70cfe5f4471794b397e3473ea31a">operator%</a> (TEnum lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:ad1cf70cfe5f4471794b397e3473ea31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3776e6341f16463e8154e3e4bb49d90e"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a3776e6341f16463e8154e3e4bb49d90e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a3776e6341f16463e8154e3e4bb49d90e">operator%=</a> (TEnum &amp;lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a3776e6341f16463e8154e3e4bb49d90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22529a96c90fd221db0757ff6f1da0c6"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a22529a96c90fd221db0757ff6f1da0c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a22529a96c90fd221db0757ff6f1da0c6">operator*</a> (TEnum lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a22529a96c90fd221db0757ff6f1da0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae717c60deb187f11b600578ed2fb76"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a2ae717c60deb187f11b600578ed2fb76"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a2ae717c60deb187f11b600578ed2fb76">operator*=</a> (TEnum &amp;lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a2ae717c60deb187f11b600578ed2fb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b687109ec6e967dab9485ea66e65851"><td class="memTemplParams" colspan="2">template&lt;typename TEnum , typename TEnableIf  = typename std::enable_if&lt;aworx::lib::lang::T_EnumIsIteratable&lt;TEnum&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a6b687109ec6e967dab9485ea66e65851"><td class="memTemplItemLeft" align="right" valign="top">constexpr TEnum&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a6b687109ec6e967dab9485ea66e65851">operator+</a> (TEnum element, int addend) noexcept(true)</td></tr>
<tr class="separator:a6b687109ec6e967dab9485ea66e65851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b25f4952e506a7a23659009e64d3787"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a9b25f4952e506a7a23659009e64d3787"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9b25f4952e506a7a23659009e64d3787">operator+</a> (TEnum lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:a9b25f4952e506a7a23659009e64d3787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d68573ef09952c2ad3e8eeceb32e7a9"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a5d68573ef09952c2ad3e8eeceb32e7a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a5d68573ef09952c2ad3e8eeceb32e7a9">operator+</a> (TEnum lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a5d68573ef09952c2ad3e8eeceb32e7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17ed463cef631626f78bbae105cf0d8"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:ae17ed463cef631626f78bbae105cf0d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt; TEnum &gt;::value &amp;&amp;!<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ae17ed463cef631626f78bbae105cf0d8">operator+</a> (TEnum lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:ae17ed463cef631626f78bbae105cf0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f9804e48d2483958929e636a69b1e8"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a37f9804e48d2483958929e636a69b1e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a37f9804e48d2483958929e636a69b1e8">operator+</a> (TEnum arg) noexcept(true)</td></tr>
<tr class="separator:a37f9804e48d2483958929e636a69b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23993ba9ff498cc51bdf924c73d73553"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a23993ba9ff498cc51bdf924c73d73553"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a23993ba9ff498cc51bdf924c73d73553">operator++</a> (TEnum &amp;arg) noexcept(true)</td></tr>
<tr class="separator:a23993ba9ff498cc51bdf924c73d73553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d3d05518cdf54a93bfdbec7e452162"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a00d3d05518cdf54a93bfdbec7e452162"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga90927aab45cbfd0e0bd84649d45ec929">ALIB_CPP14_CONSTEXPR</a> std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a00d3d05518cdf54a93bfdbec7e452162">operator++</a> (TEnum &amp;arg, int) noexcept(true)</td></tr>
<tr class="separator:a00d3d05518cdf54a93bfdbec7e452162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ce792ab1cdcb6a782c8d32e041f718"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:ac3ce792ab1cdcb6a782c8d32e041f718"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ac3ce792ab1cdcb6a782c8d32e041f718">operator+=</a> (TEnum &amp;lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:ac3ce792ab1cdcb6a782c8d32e041f718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3f38a3a56cd3f23c18e8137e884d6d"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a2b3f38a3a56cd3f23c18e8137e884d6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt; TEnum &gt;::value &amp;&amp;!<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a2b3f38a3a56cd3f23c18e8137e884d6d">operator+=</a> (TEnum &amp;lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:a2b3f38a3a56cd3f23c18e8137e884d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c72c2a642aa360bb45eb7496417263b"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a6c72c2a642aa360bb45eb7496417263b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a6c72c2a642aa360bb45eb7496417263b">operator+=</a> (TEnum &amp;lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a6c72c2a642aa360bb45eb7496417263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd89e3596c9591d366884c3e9fe07455"><td class="memTemplParams" colspan="2">template&lt;typename TEnum , typename TEnableIf  = typename std::enable_if&lt;aworx::lib::lang::T_EnumIsIteratable&lt;TEnum&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:afd89e3596c9591d366884c3e9fe07455"><td class="memTemplItemLeft" align="right" valign="top">constexpr TEnum&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#afd89e3596c9591d366884c3e9fe07455">operator-</a> (TEnum element, int subtrahend) noexcept(true)</td></tr>
<tr class="separator:afd89e3596c9591d366884c3e9fe07455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5d93e359fc2b82bda8b7b5d49a0855"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a9d5d93e359fc2b82bda8b7b5d49a0855"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt; TEnum &gt;::value &amp;&amp;!<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9d5d93e359fc2b82bda8b7b5d49a0855">operator-</a> (TEnum lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:a9d5d93e359fc2b82bda8b7b5d49a0855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dbf1c0dea06c0523493060c2be305c"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a36dbf1c0dea06c0523493060c2be305c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a36dbf1c0dea06c0523493060c2be305c">operator-</a> (TEnum lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:a36dbf1c0dea06c0523493060c2be305c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dace49d871148630290dcd0ff019970"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a6dace49d871148630290dcd0ff019970"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a6dace49d871148630290dcd0ff019970">operator-</a> (TEnum lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a6dace49d871148630290dcd0ff019970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade362ac2fa5c55771e240054557ff6fc"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:ade362ac2fa5c55771e240054557ff6fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ade362ac2fa5c55771e240054557ff6fc">operator-</a> (TEnum arg) noexcept(true)</td></tr>
<tr class="separator:ade362ac2fa5c55771e240054557ff6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad133733b416d9c0a357677d733d75efb"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:ad133733b416d9c0a357677d733d75efb"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ad133733b416d9c0a357677d733d75efb">operator--</a> (TEnum &amp;arg) noexcept(true)</td></tr>
<tr class="separator:ad133733b416d9c0a357677d733d75efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216e8964bc009c056929ebfef61d7c3a"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a216e8964bc009c056929ebfef61d7c3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga90927aab45cbfd0e0bd84649d45ec929">ALIB_CPP14_CONSTEXPR</a> std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a216e8964bc009c056929ebfef61d7c3a">operator--</a> (TEnum &amp;arg, int) noexcept(true)</td></tr>
<tr class="separator:a216e8964bc009c056929ebfef61d7c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab959cc47883bb9d44a072bc0a5abf2a3"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:ab959cc47883bb9d44a072bc0a5abf2a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt; TEnum &gt;::value &amp;&amp;!<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab959cc47883bb9d44a072bc0a5abf2a3">operator-=</a> (TEnum &amp;lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:ab959cc47883bb9d44a072bc0a5abf2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751225eb2bd89d126ba103c5373e79fc"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a751225eb2bd89d126ba103c5373e79fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a751225eb2bd89d126ba103c5373e79fc">operator-=</a> (TEnum &amp;lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:a751225eb2bd89d126ba103c5373e79fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36b6421e55a78b3bec5c2777484385e"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:ab36b6421e55a78b3bec5c2777484385e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab36b6421e55a78b3bec5c2777484385e">operator-=</a> (TEnum &amp;lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:ab36b6421e55a78b3bec5c2777484385e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baa9d54bb09dfb051a2bedf202abbef"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a0baa9d54bb09dfb051a2bedf202abbef"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a0baa9d54bb09dfb051a2bedf202abbef">operator/</a> (TEnum lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a0baa9d54bb09dfb051a2bedf202abbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04830557731433e477bece1bb6bca6d6"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a04830557731433e477bece1bb6bca6d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a04830557731433e477bece1bb6bca6d6">operator/=</a> (TEnum &amp;lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a04830557731433e477bece1bb6bca6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194fdac61dda4e48112f0011b6363868"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a194fdac61dda4e48112f0011b6363868"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a194fdac61dda4e48112f0011b6363868">operator&lt;</a> (TEnum lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:a194fdac61dda4e48112f0011b6363868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a08108c9e8b46e7866f982e27a66c4"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a15a08108c9e8b46e7866f982e27a66c4"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a15a08108c9e8b46e7866f982e27a66c4">operator&lt;</a> (TEnum lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a15a08108c9e8b46e7866f982e27a66c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0333be044acb1d4c23f3e23af128567e"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a0333be044acb1d4c23f3e23af128567e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a0333be044acb1d4c23f3e23af128567e">operator&lt;&lt;</a> (TEnum lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a0333be044acb1d4c23f3e23af128567e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c81b8d1ba93ed9685b51f16f8154aec"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a0c81b8d1ba93ed9685b51f16f8154aec"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a0c81b8d1ba93ed9685b51f16f8154aec">operator&lt;&lt;=</a> (TEnum &amp;lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a0c81b8d1ba93ed9685b51f16f8154aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68786356e3bb630988f5b49668225e0d"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a68786356e3bb630988f5b49668225e0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a68786356e3bb630988f5b49668225e0d">operator&lt;=</a> (TEnum lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:a68786356e3bb630988f5b49668225e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb64d82dc01fdb606a6d640446681dd9"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:aeb64d82dc01fdb606a6d640446681dd9"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#aeb64d82dc01fdb606a6d640446681dd9">operator&lt;=</a> (TEnum lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:aeb64d82dc01fdb606a6d640446681dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb24e92e506e634cf3d1e786e10e9f3"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a7cb24e92e506e634cf3d1e786e10e9f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a7cb24e92e506e634cf3d1e786e10e9f3">operator&gt;</a> (TEnum lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:a7cb24e92e506e634cf3d1e786e10e9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70de84a9014a8dacd466468bf3af35d"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:af70de84a9014a8dacd466468bf3af35d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af70de84a9014a8dacd466468bf3af35d">operator&gt;</a> (TEnum lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:af70de84a9014a8dacd466468bf3af35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9bc2e7fba44ada6045f8ce66bb5e64"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a6b9bc2e7fba44ada6045f8ce66bb5e64"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a6b9bc2e7fba44ada6045f8ce66bb5e64">operator&gt;=</a> (TEnum lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:a6b9bc2e7fba44ada6045f8ce66bb5e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177206ad92f6fbc7ab655263bb5071c6"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a177206ad92f6fbc7ab655263bb5071c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a177206ad92f6fbc7ab655263bb5071c6">operator&gt;=</a> (TEnum lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a177206ad92f6fbc7ab655263bb5071c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15f1bc9ddf65ef4fc971f6f648cc77a"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:ab15f1bc9ddf65ef4fc971f6f648cc77a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab15f1bc9ddf65ef4fc971f6f648cc77a">operator&gt;&gt;</a> (TEnum lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:ab15f1bc9ddf65ef4fc971f6f648cc77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9445a8612f2cd0d6ef2a8c594fc158"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a7f9445a8612f2cd0d6ef2a8c594fc158"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a7f9445a8612f2cd0d6ef2a8c594fc158">operator&gt;&gt;=</a> (TEnum &amp;lhs, typename std::underlying_type&lt; TEnum &gt;::type rhs) noexcept(true)</td></tr>
<tr class="separator:a7f9445a8612f2cd0d6ef2a8c594fc158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b389332b4d0d5ed1f7118f173685d0e"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a5b389332b4d0d5ed1f7118f173685d0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a5b389332b4d0d5ed1f7118f173685d0e">operator^</a> (TEnum lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:a5b389332b4d0d5ed1f7118f173685d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae596498f62f2978ab6cdcb97d61cfc83"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:ae596498f62f2978ab6cdcb97d61cfc83"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ae596498f62f2978ab6cdcb97d61cfc83">operator^=</a> (TEnum &amp;lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:ae596498f62f2978ab6cdcb97d61cfc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce7a398d6d214cd36c3a28a2d868519"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:afce7a398d6d214cd36c3a28a2d868519"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#afce7a398d6d214cd36c3a28a2d868519">operator|</a> (TEnum lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:afce7a398d6d214cd36c3a28a2d868519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17407b3624b5cc4be4476378d4193082"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:a17407b3624b5cc4be4476378d4193082"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a17407b3624b5cc4be4476378d4193082">operator|=</a> (TEnum &amp;lhs, TEnum rhs) noexcept(true)</td></tr>
<tr class="separator:a17407b3624b5cc4be4476378d4193082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d1471f39a2064b7495ed403c43e247"><td class="memTemplParams" colspan="2">template&lt;typename TEnum &gt; </td></tr>
<tr class="memitem:ab0d1471f39a2064b7495ed403c43e247"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt; TEnum &gt;::value, TEnum &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab0d1471f39a2064b7495ed403c43e247">operator~</a> (TEnum op) noexcept(true)</td></tr>
<tr class="separator:ab0d1471f39a2064b7495ed403c43e247"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a050df5b24462b4a6256f2ed69c6b50ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050df5b24462b4a6256f2ed69c6b50ae">&#9670;&nbsp;</a></span>integer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a050df5b24462b4a6256f2ed69c6b50ae">integer</a> =  platform_specific</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type specifies platform independent integer values of the 'natural' bit-size of the underlying platform. In general, on 32-bit systems this will be 32-bit wide, on 64-bit systems, 64-bits. Hence, on standard architectures, it has the same bit-size and signedness as <b>std::ptrdiff_t</b>.</p>
<p>To declare constants of this type, a user defined literal is provided with <a class="el" href="namespaceaworx_1_1literals.html#a4f8aca3025f70df27df088c7fc5b0ee7">_integer</a>.</p>
<p>The type can be considered as a signed version of <code>std::size_t</code>. It is needed because standard type <code>'int'</code> is not specified in respect to its size. E.g. GNU C++ and Clang compiler use 32-Bit integers for type <code>int</code>, even on 64-Bit platforms.</p>
<p>See also <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a03b8595314b87c0141d68dc0c312f30e">aworx::uinteger</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This documentation is generated using the 64-Bit version of the library. In fact, the definition as <code>int64_t</code> is not guaranteed platform specific. </dd></dl>

</div>
</div>
<a id="af9eb8b6fb1aab7d526e9419b10fd5363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9eb8b6fb1aab7d526e9419b10fd5363">&#9670;&nbsp;</a></span>intGap_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af9eb8b6fb1aab7d526e9419b10fd5363">intGap_t</a> =  platform_specific</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type, together with its counterpart <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ae89f60b8bbbc054d70fa7c5b19627b93">aworx::uintGap_t</a> is used to fill a gap that occurs when method overloads or template specialization is needed for integer types. The rational behind and use of this pair of types is best explained with a sample.</p>
<p>Consider the following code:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">// Template function</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInteger&gt; <span class="keyword">const</span> <span class="keywordtype">char</span>* MyFunc(TInteger val) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;NOT IMPLEMENTED&quot;</span>; }</div><div class="line"></div><div class="line"><span class="comment">// Specializations for integer types</span></div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">const</span> <span class="keywordtype">char</span>* MyFunc(  int8_t  ) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Type=  int8_t &quot;</span>; }</div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">const</span> <span class="keywordtype">char</span>* MyFunc( uint8_t  ) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Type= uint8_t &quot;</span>; }</div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">const</span> <span class="keywordtype">char</span>* MyFunc(  int16_t ) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Type=  int16_t&quot;</span>; }</div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">const</span> <span class="keywordtype">char</span>* MyFunc( uint16_t ) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Type= uint16_t&quot;</span>; }</div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">const</span> <span class="keywordtype">char</span>* MyFunc(  int32_t ) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Type=  int32_t&quot;</span>; }</div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">const</span> <span class="keywordtype">char</span>* MyFunc( uint32_t ) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Type= uint32_t&quot;</span>; }</div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">const</span> <span class="keywordtype">char</span>* MyFunc(  int64_t ) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Type=  int64_t&quot;</span>; }</div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">const</span> <span class="keywordtype">char</span>* MyFunc( uint64_t ) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Type= uint64_t&quot;</span>; }</div><div class="line"></div><div class="line"><span class="comment">// TestMethod</span></div><div class="line"><span class="keywordtype">void</span> test()</div><div class="line">{</div><div class="line">    <span class="comment">// test std int types</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot; int8_t           : &quot;</span> &lt;&lt; MyFunc( ( int8_t )           0 ) &lt;&lt; endl; <span class="comment">// OK</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;uint8_t           : &quot;</span> &lt;&lt; MyFunc( (uint8_t )           0 ) &lt;&lt; endl; <span class="comment">// OK</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot; int16_t          : &quot;</span> &lt;&lt; MyFunc( ( int16_t)           0 ) &lt;&lt; endl; <span class="comment">// OK</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;uint16_t          : &quot;</span> &lt;&lt; MyFunc( (uint16_t)           0 ) &lt;&lt; endl; <span class="comment">// OK</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot; int32_t          : &quot;</span> &lt;&lt; MyFunc( ( int32_t)           0 ) &lt;&lt; endl; <span class="comment">// OK</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;uint32_t          : &quot;</span> &lt;&lt; MyFunc( (uint32_t)           0 ) &lt;&lt; endl; <span class="comment">// OK</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot; int64_t          : &quot;</span> &lt;&lt; MyFunc( ( int64_t)           0 ) &lt;&lt; endl; <span class="comment">// OK</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;uint64_t          : &quot;</span> &lt;&lt; MyFunc( (uint64_t)           0 ) &lt;&lt; endl; <span class="comment">// OK</span></div><div class="line">    cout &lt;&lt; endl;</div><div class="line"></div><div class="line">    <span class="comment">// test &#39;language&#39; types</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;         long     : &quot;</span> &lt;&lt; MyFunc( (         <span class="keywordtype">long</span>     ) 0 ) &lt;&lt; endl; <span class="comment">// Gap on common 32-bit platforms and 64-bit MSVC</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;unsigned long     : &quot;</span> &lt;&lt; MyFunc( (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     ) 0 ) &lt;&lt; endl; <span class="comment">// Gap on common 32-bit platforms and 64-bit MSVC</span></div><div class="line">    cout &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;         long long: &quot;</span> &lt;&lt; MyFunc( (         <span class="keywordtype">long</span> <span class="keywordtype">long</span>) 0 ) &lt;&lt; endl; <span class="comment">// Gap on 64-Bit GNU C++</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;unsigned long long: &quot;</span> &lt;&lt; MyFunc( (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>) 0 ) &lt;&lt; endl; <span class="comment">// Gap on 64-Bit GNU C++</span></div><div class="line">    cout &lt;&lt; endl;</div><div class="line"></div><div class="line">    <span class="comment">// further info</span></div><div class="line">    cout &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;sizeof(         long     )= &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(         long     ) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;sizeof(unsigned long     )= &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> long     ) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;sizeof(         long long)= &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(         <span class="keywordtype">long</span> long) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;sizeof(unsigned long long)= &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long) &lt;&lt; endl;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> When this is run under 64 Bit - Linux, GNU compiler, the following output is produced: </p><div class="fragment"><div class="line">The result is:                ***42***</div><div class="line"> int8_t           : Type=  int8_t </div><div class="line">uint8_t           : Type= uint8_t </div><div class="line"> int16_t          : Type=  int16_t</div><div class="line">uint16_t          : Type= uint16_t</div><div class="line"> int32_t          : Type=  int32_t</div><div class="line">uint32_t          : Type= uint32_t</div><div class="line"> int64_t          : Type=  int64_t</div><div class="line">uint64_t          : Type= uint64_t</div><div class="line"></div><div class="line">         long     : Type=  int64_t</div><div class="line"><span class="keywordtype">unsigned</span> long     : Type= uint64_t</div><div class="line"></div><div class="line">         <span class="keywordtype">long</span> long: NOT IMPLEMENTED</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long: NOT IMPLEMENTED</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">sizeof</span>(         long     )= 8</div><div class="line"><span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>     )= 8</div><div class="line"></div><div class="line"><span class="keyword">sizeof</span>(         <span class="keywordtype">long</span> long)= 8</div><div class="line"><span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)= 8</div></div><!-- fragment --><p> This is not what many C++ programmers would expect: Although type <code>long long</code> is the same 64-bit type as <code>long</code>, the template method is not seen as specialized by the compiler. Therefore, we have a "gap" in the definition of specializations for types <code>long long</code> and <code>unsigned long long</code>.</p>
<p>When compiling and running the same sample code under GNU compiler 32-bit or under MSVC (Microsoft compiler), 32 or 64-bit, then the gap "moves" to be with types <code>long</code> and <code>unsigned long</code> instead. Here, this hurts a lot, because code that uses a simple integer constant <code>1L</code> is not fetched by the template specializations!</p>
<p>The lesson learned is that two more specializations are needed and that their types are dependent on the compiler and library used. Because it is not allowed to specialize simply with all possible extra variants (this would lead to doubly defined methods), a preprocessor switch that chooses the right types to fill the gap is needed.</p>
<p>This type, together with <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ae89f60b8bbbc054d70fa7c5b19627b93">uintGap_t</a>, does exactly this: using the preprocessor to select the right "missing" type.</p>
<p>To fix the sample above, the following two specializations of the template method need to be added:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">const</span> <span class="keywordtype">char</span>* MyFunc( <a class="code" href="namespaceaworx.html#adea1bda61bf659bfe398c7f2f13242df">aworx:: intGap_t</a> ) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Type=  intGap_t&quot;</span>; }</div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">const</span> <span class="keywordtype">char</span>* MyFunc( <a class="code" href="namespaceaworx.html#a34d1e1a0600952dbf9f562aed36b873f">aworx::uintGap_t</a> ) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Type= uintGap_t&quot;</span>; }</div></div><!-- fragment --><p> When overloading functions with integer types, similar rules apply: To have the complete set of integer types covered, 10 overloads are needed: from type <b>int8_t</b> to type <b>int64_t</b>, type <b>intGap_t</b> and then those five types in two versions, signed and unsigned. Only with all overloads in place, compiler warnings (on high warning levels) and/or the necessity of explicit type conversions are avoided. </p>

</div>
</div>
<a id="a03b8595314b87c0141d68dc0c312f30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b8595314b87c0141d68dc0c312f30e">&#9670;&nbsp;</a></span>uinteger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a03b8595314b87c0141d68dc0c312f30e">uinteger</a> =  platform_specific</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unsigned version of <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a050df5b24462b4a6256f2ed69c6b50ae">aworx::integer</a>. This type should be the same as <code>std::size_t</code> on all platforms. </p>

</div>
</div>
<a id="ae89f60b8bbbc054d70fa7c5b19627b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89f60b8bbbc054d70fa7c5b19627b93">&#9670;&nbsp;</a></span>uintGap_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ae89f60b8bbbc054d70fa7c5b19627b93">uintGap_t</a> =  platform_specific</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to complete overwriting methods and template specializations.<br />
 See signed sibling type <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af9eb8b6fb1aab7d526e9419b10fd5363">aworx::intGap_t</a> for more information. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acdfaca60ec19c0265bac2692d7982726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfaca60ec19c0265bac2692d7982726">&#9670;&nbsp;</a></span>Alignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#acdfaca60ec19c0265bac2692d7982726">Alignment</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[DOX_ALIB_LANG_ENUMS_PARSABLE_1] </p>
<hr/>
<p> Denotes Alignments. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acdfaca60ec19c0265bac2692d7982726a945d5e233cf7d6240f6b783b36a374ff"></a>Left&#160;</td><td class="fielddoc"><p>Chooses left alignment. </p>
</td></tr>
<tr><td class="fieldname"><a id="acdfaca60ec19c0265bac2692d7982726a92b09c7c48c520c3c55e497875da437c"></a>Right&#160;</td><td class="fielddoc"><p>Chooses right alignment. </p>
</td></tr>
<tr><td class="fieldname"><a id="acdfaca60ec19c0265bac2692d7982726a4f1f6016fc9f3f2353c0cc7c67b292bd"></a>Center&#160;</td><td class="fielddoc"><p>Chooses centered alignment. </p>
</td></tr>
</table>

</div>
</div>
<a id="a39db6982619d623273fad8a383489309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39db6982619d623273fad8a383489309">&#9670;&nbsp;</a></span>Bool</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a39db6982619d623273fad8a383489309">Bool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Enumeration representing a boolean value. While the use of this enumeration type seems senseless at the first sight (as the C++ has keywords <code>bool</code>, <code>false</code> and <code>true</code>), the reason for its existence is to have write and parse methods in place using the concept of <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">ALib Enum Meta Information</a>.</p>
<p>The default name translation table is equipped with various 'overloaded' element entries like "yes", "no", "on", "off", "1" or "0". Furthermore, if other languages should be supported, this can even be extended at runtime. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a39db6982619d623273fad8a383489309af8320b26d30ab433c5a54546d21f414c"></a>False&#160;</td><td class="fielddoc"><p>False value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a39db6982619d623273fad8a383489309af827cf462f62848df37c5e1e94a4da74"></a>True&#160;</td><td class="fielddoc"><p>True value. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab9aab17a5e54a8bae6915bc24db13a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9aab17a5e54a8bae6915bc24db13a17">&#9670;&nbsp;</a></span>Case</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">Case</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[DOX_ALIB_LANG_ENUMS_PARSABLE_1] </p>
<hr/>
<p> Denotes upper and lower case character treatment. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b"></a>Sensitive&#160;</td><td class="fielddoc"><p>Chooses an operation mode which differs between lower and upper case letters (usually the default). </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9aab17a5e54a8bae6915bc24db13a17afd038fc7f319e48f3115d92bf5bdbef9"></a>Ignore&#160;</td><td class="fielddoc"><p>Chooses an operation mode which does not differ between between lower and upper case letters. </p>
</td></tr>
</table>

</div>
</div>
<a id="af6d9cc1e6686eca6e60d57d959cf57fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d9cc1e6686eca6e60d57d959cf57fb">&#9670;&nbsp;</a></span>ContainerOp</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af6d9cc1e6686eca6e60d57d959cf57fb">ContainerOp</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes standard container operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af6d9cc1e6686eca6e60d57d959cf57fbaa458be0f08b7e4ff3c0f633c100176c0"></a>Insert&#160;</td><td class="fielddoc"><p>Denotes insertions. </p>
</td></tr>
<tr><td class="fieldname"><a id="af6d9cc1e6686eca6e60d57d959cf57fba1063e38cb53d94d386f21227fcd84717"></a>Remove&#160;</td><td class="fielddoc"><p>Denotes removals. </p>
</td></tr>
<tr><td class="fieldname"><a id="af6d9cc1e6686eca6e60d57d959cf57fbac55582518cba2c464f29f5bae1c68def"></a>Get&#160;</td><td class="fielddoc"><p>Denotes to search data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af6d9cc1e6686eca6e60d57d959cf57fba1d5c1a7fde77e84c993d6fea61f88c2a"></a>GetCreate&#160;</td><td class="fielddoc"><p>Denotes to create data if not found. </p>
</td></tr>
<tr><td class="fieldname"><a id="af6d9cc1e6686eca6e60d57d959cf57fba686e697538050e4664636337cc3b834f"></a>Create&#160;</td><td class="fielddoc"><p>Denotes to create data. </p>
</td></tr>
</table>

</div>
</div>
<a id="a55781bd0c78c4e5d47ce433f4eeeee85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55781bd0c78c4e5d47ce433f4eeeee85">&#9670;&nbsp;</a></span>Create</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a55781bd0c78c4e5d47ce433f4eeeee85">Create</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes whether something should be created if it does not exist. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a55781bd0c78c4e5d47ce433f4eeeee85a6e7b34fa59e1bd229b207892956dc41c"></a>Never&#160;</td><td class="fielddoc"><p>Do not create. </p>
</td></tr>
<tr><td class="fieldname"><a id="a55781bd0c78c4e5d47ce433f4eeeee85a44c32ea9ad0b836b68c25fdb717fa4b7"></a>IfNotExistent&#160;</td><td class="fielddoc"><p>Create if something does not exist. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9345007d67faa05253932092d54d10d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9345007d67faa05253932092d54d10d4">&#9670;&nbsp;</a></span>CurrentData</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9345007d67faa05253932092d54d10d4">CurrentData</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes if current, existing data should be cleared or if new data should be appended or otherwise added. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9345007d67faa05253932092d54d10d4a02bce93bff905887ad2233110bf9c49e"></a>Keep&#160;</td><td class="fielddoc"><p>Chooses not no clear existing data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9345007d67faa05253932092d54d10d4adc30bc0c7914db5918da4263fce93ad2"></a>Clear&#160;</td><td class="fielddoc"><p>Chooses to clear existing data. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8d828d7f6e0c02a7815c7e1308d3b06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d828d7f6e0c02a7815c7e1308d3b06e">&#9670;&nbsp;</a></span>Exceptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a8d828d7f6e0c02a7815c7e1308d3b06e">Exceptions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> <a class="el" href="classaworx_1_1lib_1_1lang_1_1Exception.html">Exception</a> codes of namespace <a class="el" href="namespaceaworx_1_1lib_1_1lang.html">aworx::lib::lang</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8d828d7f6e0c02a7815c7e1308d3b06ea7946215ab743bd9d347d313643ca72dd"></a>ErrorWritingReport&#160;</td><td class="fielddoc"><p>Error when writing a report. This typically indicates an erroneous format string in an <a class="el" href="assert_8hpp.html#ab70bcc134c68f96d8b68cf75a12db185">ALIB_ASSERT_ERROR</a> or related macro. </p>
</td></tr>
</table>

</div>
</div>
<a id="a217539925b78b2eed40ae7817d5bee52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217539925b78b2eed40ae7817d5bee52">&#9670;&nbsp;</a></span>Inclusion</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a217539925b78b2eed40ae7817d5bee52">Inclusion</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes how members of a set something should be taken into account. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a217539925b78b2eed40ae7817d5bee52af4d72a64acd8929c0cc9ed96a7a336cc"></a>Include&#160;</td><td class="fielddoc"><p>Chooses inclusion. </p>
</td></tr>
<tr><td class="fieldname"><a id="a217539925b78b2eed40ae7817d5bee52a843f2812f595e7ec7c5036e89fde02d6"></a>Exclude&#160;</td><td class="fielddoc"><p>Chooses exclusion. </p>
</td></tr>
</table>

</div>
</div>
<a id="a00fc859257c8f09ff9198dde28121961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00fc859257c8f09ff9198dde28121961">&#9670;&nbsp;</a></span>LockMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a00fc859257c8f09ff9198dde28121961">LockMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes whether a lock should allow recursive locks (count them) or not. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a00fc859257c8f09ff9198dde28121961a556c3dd912453ae5cb3095cd5054e6f4"></a>Recursive&#160;</td><td class="fielddoc"><p>Allow nested locks. </p>
</td></tr>
<tr><td class="fieldname"><a id="a00fc859257c8f09ff9198dde28121961a67b491789a29d0c717a2b4ebe369a936"></a>SingleLocks&#160;</td><td class="fielddoc"><p>Nested locks are ignored. First unlock, unlocks. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae1c5184dc404edf057ed537bcfddef84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c5184dc404edf057ed537bcfddef84">&#9670;&nbsp;</a></span>Phase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ae1c5184dc404edf057ed537bcfddef84">Phase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes a phase, e.g. of a transaction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae1c5184dc404edf057ed537bcfddef84a1a06729125544cab7cee73195fc044f0"></a>Begin&#160;</td><td class="fielddoc"><p>The start of a transaction. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae1c5184dc404edf057ed537bcfddef84a87557f11575c0ad78e4e28abedc13b6e"></a>End&#160;</td><td class="fielddoc"><p>The end of a transaction. </p>
</td></tr>
</table>

</div>
</div>
<a id="aeae0c2d4659a32ef54bd221d1a3da4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae0c2d4659a32ef54bd221d1a3da4e6">&#9670;&nbsp;</a></span>Propagation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#aeae0c2d4659a32ef54bd221d1a3da4e6">Propagation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes whether a e.g a setting should be propagated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aeae0c2d4659a32ef54bd221d1a3da4e6a3f9823fc8c5bf8d5efbb0ad3be5f16c9"></a>Omit&#160;</td><td class="fielddoc"><p>Do not propagate changes. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeae0c2d4659a32ef54bd221d1a3da4e6aa9857b4deb35c57d5753f94fa00a028e"></a>ToDescendants&#160;</td><td class="fielddoc"><p>Propagate changes to descendants/children/sub-components. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9537c0a8df05f0a728b6e2a89c7f3a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9537c0a8df05f0a728b6e2a89c7f3a1b">&#9670;&nbsp;</a></span>Reach</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9537c0a8df05f0a728b6e2a89c7f3a1b">Reach</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes the reach of something. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9537c0a8df05f0a728b6e2a89c7f3a1ba4cc6684df7b4a92b1dec6fce3264fac8"></a>Global&#160;</td><td class="fielddoc"><p>Denotes global reach. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9537c0a8df05f0a728b6e2a89c7f3a1ba509820290d57f333403f490dde7316f4"></a>Local&#160;</td><td class="fielddoc"><p>Denotes local reach. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab5305b978950ba3946cf79a4bccbf7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5305b978950ba3946cf79a4bccbf7af">&#9670;&nbsp;</a></span>Responsibility</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab5305b978950ba3946cf79a4bccbf7af">Responsibility</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes whether the responsibility for something is kept or passed. This is useful, e.g. in situations where objects are shared to determine if the responsibility for the deletion of object is transferred over to the receiver or kept by the sender of the object. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab5305b978950ba3946cf79a4bccbf7afa2540530a938da82bfe62957f4aff599b"></a>KeepWithSender&#160;</td><td class="fielddoc"><p>Keeps responsibility, e.g. when passing an object. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab5305b978950ba3946cf79a4bccbf7afa6950810f0d2bba97a6f710c7b965b84e"></a>Transfer&#160;</td><td class="fielddoc"><p>Transfers responsibility to the receiving party. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8c800527afe0a8a6c71ae4cceda6bf9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c800527afe0a8a6c71ae4cceda6bf9d">&#9670;&nbsp;</a></span>Safeness</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a8c800527afe0a8a6c71ae4cceda6bf9d">Safeness</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes whether something should be performed in a safe or unsafe fashion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8c800527afe0a8a6c71ae4cceda6bf9dac6eea0560cd6f377e78dff2c85cc9122"></a>Safe&#160;</td><td class="fielddoc"><p>Do it or treat it with safety. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c800527afe0a8a6c71ae4cceda6bf9dad3d57868b6ff9839eff631d2cc8acbce"></a>Unsafe&#160;</td><td class="fielddoc"><p>Omit checks or perform unsafe operations. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad9be72f666a31b4318bbc8e8a16a9472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9be72f666a31b4318bbc8e8a16a9472">&#9670;&nbsp;</a></span>SortOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ad9be72f666a31b4318bbc8e8a16a9472">SortOrder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes sort order. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad9be72f666a31b4318bbc8e8a16a9472acf3fb1ff52ea1eed3347ac5401ee7f0c"></a>Ascending&#160;</td><td class="fielddoc"><p>Chooses ascending sort oder. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad9be72f666a31b4318bbc8e8a16a9472ae3cf5ac19407b1a62c6fccaff675a53b"></a>Descending&#160;</td><td class="fielddoc"><p>Chooses descending sort oder. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab0acd6daf9443d8b997f1035cfe08dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0acd6daf9443d8b997f1035cfe08dd8">&#9670;&nbsp;</a></span>SourceData</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab0acd6daf9443d8b997f1035cfe08dd8">SourceData</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes if the source data should be moved or copied. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab0acd6daf9443d8b997f1035cfe08dd8a5fb63579fc981698f97d55bfecb213ea"></a>Copy&#160;</td><td class="fielddoc"><p>Chooses not to clear existing data. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab0acd6daf9443d8b997f1035cfe08dd8a6bc362dbf494c61ea117fe3c71ca48a5"></a>Move&#160;</td><td class="fielddoc"><p>Chooses to clear existing data. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9f3c28a2cb05bdcc618b542e49bfda3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3c28a2cb05bdcc618b542e49bfda3f">&#9670;&nbsp;</a></span>Switch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9f3c28a2cb05bdcc618b542e49bfda3f">Switch</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes if sth. is switched on or off. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9f3c28a2cb05bdcc618b542e49bfda3fad15305d7a4e34e02489c74a5ef542f36"></a>Off&#160;</td><td class="fielddoc"><p>Switch it off, switched off, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9f3c28a2cb05bdcc618b542e49bfda3fa521c36a31c2762741cf0f8890cbe05e3"></a>On&#160;</td><td class="fielddoc"><p>Switch it on, switched on, etc. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9b1d8f31e178e17a8fef3a9e94bc4b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1d8f31e178e17a8fef3a9e94bc4b2c">&#9670;&nbsp;</a></span>Timezone</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a9b1d8f31e178e17a8fef3a9e94bc4b2c">Timezone</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes whether a time value represents local time or UTC. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9b1d8f31e178e17a8fef3a9e94bc4b2ca509820290d57f333403f490dde7316f4"></a>Local&#160;</td><td class="fielddoc"><p>Denotes local time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9b1d8f31e178e17a8fef3a9e94bc4b2ca9234324ddf6b4176b57d803a925b7961"></a>UTC&#160;</td><td class="fielddoc"><p>Denotes UTC (coordinated universal time). </p>
</td></tr>
</table>

</div>
</div>
<a id="ad4a46f9fb632511f6be7c53e05f330f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a46f9fb632511f6be7c53e05f330f7">&#9670;&nbsp;</a></span>Whitespaces</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ad4a46f9fb632511f6be7c53e05f330f7">Whitespaces</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Denotes whether a string is trimmed or not </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad4a46f9fb632511f6be7c53e05f330f7a1fc5884251ca9f20a4fd5f79a458f94f"></a>Trim&#160;</td><td class="fielddoc"><p>Trim whitespaces away. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad4a46f9fb632511f6be7c53e05f330f7a02bce93bff905887ad2233110bf9c49e"></a>Keep&#160;</td><td class="fielddoc"><p>Keep whitespaces in string. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a20cbd716cfc046a49f72978689279f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20cbd716cfc046a49f72978689279f29">&#9670;&nbsp;</a></span>DeleteSingletons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> void aworx::lib::lang::DeleteSingletons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Deletes the singletons. Upon exit of the process, programmers might want to explicitly free the hash table to avoid the detection of memory leaks by metrics tools like <a href="http://valgrind.org/">Valgrind</a>. (Otherwise this can be omitted, as the memory is cleaned by the OS probably much faster when a process exits).</p>
<p>When using singletons with the full implementation of <b>ALib</b> (in contrast in using just the module <b>ALib Singleton</b>), then <a class="el" href="classaworx_1_1lib_1_1lang_1_1Library.html">aworx::lib::lang::Library</a>library termination"" on singleton <a class="el" href="namespaceaworx_1_1lib.html#a82d1f1a7a150abed28776bc5c8df9fa0">aworx::lib::ALIB</a> invokes this method already.</p>
<dl class="section note"><dt>Note</dt><dd>This method is not thread-safe and hence must be called only on termination of the process when all threads which are using singletons are terminated. </dd></dl>

</div>
</div>
<a id="a2fd18b7e35e747c3e86275c57311cb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd18b7e35e747c3e86275c57311cb1b">&#9670;&nbsp;</a></span>EnumContains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt;TEnum&gt;::value, bool&gt;::type aworx::lib::lang::EnumContains </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>tested</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>testFor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests if given scoped enum value <code>tested</code> <b>xor assignment</b> contains (all) bit(s) set in scoped enum value <code>testFor</code>. In other words, returns result of: </p><pre class="fragment">  ( tested &amp; testFor ) == testFor
</pre><p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tested</td><td>Bitset to be tested. </td></tr>
    <tr><td class="paramname">testFor</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all bits of <code>testFor</code> are set in <code>tested</code>. </dd></dl>

</div>
</div>
<a id="a84494f1a492417b7b96bb8dfcd9c4c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84494f1a492417b7b96bb8dfcd9c4c02">&#9670;&nbsp;</a></span>EnumValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::underlying_type&lt;TEnum&gt;::type aworx::lib::lang::EnumValue </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the "internal" integer type value of an enumeration value. This is useful for example, to return result codes to callers of different programming languages or command line programs.</p>
<p>Selected by the compiler only if template parameter <code>TEnum</code> represents an enum type.</p>
<dl class="section note"><dt>Note</dt><dd>While documented in namespace <code>aworx::lib::lang</code> in fact this function resides in namespace <a class="el" href="namespaceaworx.html">aworx</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>A different, and much more far-reaching approach is implemented with class <a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The enumeration element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
    <tr><td class="paramname">TEnableIf</td><td>Internal. Do <b>not</b> specify!<br />
 (Defaults to <code>std::enable_if</code> type, to enable the compiler to select this operator only for types that have <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> set.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all bits of <code>testFor</code> are set in <code>tested</code>. </dd></dl>

</div>
</div>
<a id="ac5ecab83cce9a39585a8db8fdf597ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ecab83cce9a39585a8db8fdf597ee7">&#9670;&nbsp;</a></span>operator &amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bitwise <b>and</b> operator useable with scoped enum types.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of a bitwise and operation of the underlying enum values. </dd></dl>

</div>
</div>
<a id="a09304aaeeffaac2fb8693a970692a534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09304aaeeffaac2fb8693a970692a534">&#9670;&nbsp;</a></span>operator &amp;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bitwise assignment operator useable with scoped enum types.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value of <code>lhs</code> which is set to <code>lhs &amp; rhs</code>. </dd></dl>

</div>
</div>
<a id="ad1cf70cfe5f4471794b397e3473ea31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cf70cfe5f4471794b397e3473ea31a">&#9670;&nbsp;</a></span>operator%()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator% </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modulo operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="a3776e6341f16463e8154e3e4bb49d90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3776e6341f16463e8154e3e4bb49d90e">&#9670;&nbsp;</a></span>operator%=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator%= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modulo assignment operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="a22529a96c90fd221db0757ff6f1da0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22529a96c90fd221db0757ff6f1da0c6">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator* </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="a2ae717c60deb187f11b600578ed2fb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae717c60deb187f11b600578ed2fb76">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator*= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication assignment operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="a6b687109ec6e967dab9485ea66e65851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b687109ec6e967dab9485ea66e65851">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TEnum aworx::lib::lang::operator+ </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add operator useable with scoped enum types and integer values.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>First operand of <code>TEnum</code> type. </td></tr>
    <tr><td class="paramname">addend</td><td>The addend as of <code>int</code> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
    <tr><td class="paramname">TEnableIf</td><td>Internal. Do <b>not</b> specify!<br />
 (Defaults to <code>std::enable_if</code> type, to enable the compiler to select this operator only for types that have <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsIteratable.html">T_EnumIsIteratable</a> set.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>"addend-th"</em> enum element after <code>element</code> . </dd></dl>

</div>
</div>
<a id="a9b25f4952e506a7a23659009e64d3787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b25f4952e506a7a23659009e64d3787">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator+ </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add operator between two enum elements.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="a5d68573ef09952c2ad3e8eeceb32e7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d68573ef09952c2ad3e8eeceb32e7a9">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator+ </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="ae17ed463cef631626f78bbae105cf0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17ed463cef631626f78bbae105cf0d8">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a> &lt;TEnum&gt;::value &amp;&amp; !<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator+ </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias to bitwise <b>or</b> operator useable with scoped enum types.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code> and if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is <b>not</b> specialized to inherit <code>std::true_type</code>. The latter is to avoid ambiguities in situations where an enum is both, arithmetical and bitwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of a bitwise or operation of the underlying enum values. </dd></dl>

</div>
</div>
<a id="a37f9804e48d2483958929e636a69b1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f9804e48d2483958929e636a69b1e8">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator+ </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unary plus operator for enum elements.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Parameter <code>arg</code> (identical value). </dd></dl>

</div>
</div>
<a id="a23993ba9ff498cc51bdf924c73d73553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23993ba9ff498cc51bdf924c73d73553">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator++ </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prefix increment operator.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arg</td><td>Reference to the enum value to be incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value of <code>lhs</code> which is set the resulting enum element. </dd></dl>

</div>
</div>
<a id="a00d3d05518cdf54a93bfdbec7e452162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d3d05518cdf54a93bfdbec7e452162">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga90927aab45cbfd0e0bd84649d45ec929">ALIB_CPP14_CONSTEXPR</a> std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator++ </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Postfix increment operator.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arg</td><td>Reference to the enum value to be incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of <code>arg</code>. </dd></dl>

</div>
</div>
<a id="ac3ce792ab1cdcb6a782c8d32e041f718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ce792ab1cdcb6a782c8d32e041f718">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator+= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add assignment operator between two enum elements.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value of <code>lhs</code> which is set the resulting enum element. </dd></dl>

</div>
</div>
<a id="a2b3f38a3a56cd3f23c18e8137e884d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3f38a3a56cd3f23c18e8137e884d6d">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a> &lt;TEnum&gt;::value &amp;&amp; !<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator+= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for bitwise <b>or assignment</b> operator useable with scoped enum types.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code> and if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is <b>not</b> specialized to inherit <code>std::true_type</code>. The latter is to avoid ambiguities in situations where an enum is both, arithmetical and bitwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value of <code>lhs</code> which is set to <code>lhs | rhs</code>. </dd></dl>

</div>
</div>
<a id="a6c72c2a642aa360bb45eb7496417263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c72c2a642aa360bb45eb7496417263b">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator+= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add assignment operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value of <code>lhs</code> which is set the resulting enum element. </dd></dl>

</div>
</div>
<a id="afd89e3596c9591d366884c3e9fe07455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd89e3596c9591d366884c3e9fe07455">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TEnum aworx::lib::lang::operator- </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subtrahend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract operator useable with scoped enum types and integer values.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>First operand of <code>TEnum</code> type. </td></tr>
    <tr><td class="paramname">subtrahend</td><td>The subtrahend as of <code>int</code> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
    <tr><td class="paramname">TEnableIf</td><td>Internal. Do <b>not</b> specify!<br />
 (Defaults to <code>std::enable_if</code> type, to enable the compiler to select this operator only for types that have <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsIteratable.html">T_EnumIsIteratable</a> set.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>"subtrahend-th"</em> enum element before <code>element</code> . </dd></dl>

</div>
</div>
<a id="a9d5d93e359fc2b82bda8b7b5d49a0855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5d93e359fc2b82bda8b7b5d49a0855">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a> &lt;TEnum&gt;::value &amp;&amp; !<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator- </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes bit(s) found in <code>rhs</code> from <code>lhs</code> an returns result. This is a shortcut to: </p><pre class="fragment"> lhs &amp; !rhs
</pre><p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code> and if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is <b>not</b> specialized to inherit <code>std::true_type</code>. The latter is to avoid ambiguities in situations where an enum is both, arithmetical and bitwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of <code>lhs &amp; !rhs</code>. </dd></dl>

</div>
</div>
<a id="a36dbf1c0dea06c0523493060c2be305c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36dbf1c0dea06c0523493060c2be305c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator- </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract operator between two enum elements.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="a6dace49d871148630290dcd0ff019970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dace49d871148630290dcd0ff019970">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator- </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="ade362ac2fa5c55771e240054557ff6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade362ac2fa5c55771e240054557ff6fc">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator- </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unary minus operator for enum elements.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="ad133733b416d9c0a357677d733d75efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad133733b416d9c0a357677d733d75efb">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator-- </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prefix decrement operator.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arg</td><td>Reference to the enum value to be decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value of <code>lhs</code> which is set the resulting enum element. </dd></dl>

</div>
</div>
<a id="a216e8964bc009c056929ebfef61d7c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216e8964bc009c056929ebfef61d7c3a">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga90927aab45cbfd0e0bd84649d45ec929">ALIB_CPP14_CONSTEXPR</a> std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator-- </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Postfix decrement operator.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arg</td><td>Reference to the enum value to be decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old value of <code>arg</code>. </dd></dl>

</div>
</div>
<a id="ab959cc47883bb9d44a072bc0a5abf2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab959cc47883bb9d44a072bc0a5abf2a3">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt; <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a> &lt;TEnum&gt;::value &amp;&amp; !<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator-= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes bit(s) found in <code>rhs</code> from <code>lhs</code>. This is a shortcut to: </p><pre class="fragment"> lhs &amp;= !rhs
</pre><p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code> and if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is <b>not</b> specialized to inherit <code>std::true_type</code>. The latter is to avoid ambiguities in situations where an enum is both, arithmetical and bitwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value of <code>lhs</code> which is set to <code>lhs &amp; ( ~rhs )</code>. </dd></dl>

</div>
</div>
<a id="a751225eb2bd89d126ba103c5373e79fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751225eb2bd89d126ba103c5373e79fc">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator-= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract assignment operator between two enum elements.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value of <code>lhs</code> which is set the resulting enum element. </dd></dl>

</div>
</div>
<a id="ab36b6421e55a78b3bec5c2777484385e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36b6421e55a78b3bec5c2777484385e">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator-= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract assignment operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value of <code>lhs</code> which is set the resulting enum element. </dd></dl>

</div>
</div>
<a id="a0baa9d54bb09dfb051a2bedf202abbef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0baa9d54bb09dfb051a2bedf202abbef">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator/ </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="a04830557731433e477bece1bb6bca6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04830557731433e477bece1bb6bca6d6">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator/= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division assignment operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="a194fdac61dda4e48112f0011b6363868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194fdac61dda4e48112f0011b6363868">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, bool &gt;::type aworx::lib::lang::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator <em>less</em>.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a id="a15a08108c9e8b46e7866f982e27a66c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a08108c9e8b46e7866f982e27a66c4">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, bool&gt;::type aworx::lib::lang::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator <em>less</em> between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a id="a0333be044acb1d4c23f3e23af128567e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0333be044acb1d4c23f3e23af128567e">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shift-left operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="a0c81b8d1ba93ed9685b51f16f8154aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c81b8d1ba93ed9685b51f16f8154aec">&#9670;&nbsp;</a></span>operator&lt;&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shift-left assignment operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="a68786356e3bb630988f5b49668225e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68786356e3bb630988f5b49668225e0d">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, bool&gt;::type aworx::lib::lang::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator <em>less or equal</em> between two enum elements.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a id="aeb64d82dc01fdb606a6d640446681dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb64d82dc01fdb606a6d640446681dd9">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, bool&gt;::type aworx::lib::lang::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator <em>less or equal</em> between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a id="a7cb24e92e506e634cf3d1e786e10e9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb24e92e506e634cf3d1e786e10e9f3">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, bool&gt;::type aworx::lib::lang::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator <em>greater</em> between two enum elements.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a id="af70de84a9014a8dacd466468bf3af35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70de84a9014a8dacd466468bf3af35d">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, bool&gt;::type aworx::lib::lang::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator <em>greater</em> between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a id="a6b9bc2e7fba44ada6045f8ce66bb5e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9bc2e7fba44ada6045f8ce66bb5e64">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, bool&gt;::type aworx::lib::lang::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator <em>greater or equal</em> between two enum elements.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a id="a177206ad92f6fbc7ab655263bb5071c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177206ad92f6fbc7ab655263bb5071c6">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, bool&gt;::type aworx::lib::lang::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator <em>greater or equal</em> between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the comparison. </dd></dl>

</div>
</div>
<a id="ab15f1bc9ddf65ef4fc971f6f648cc77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15f1bc9ddf65ef4fc971f6f648cc77a">&#9670;&nbsp;</a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shift-right operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="a7f9445a8612f2cd0d6ef2a8c594fc158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9445a8612f2cd0d6ef2a8c594fc158">&#9670;&nbsp;</a></span>operator&gt;&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">aworx::lib::lang::T_EnumIsArithmetical</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::underlying_type&lt; TEnum &gt;::type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shift-right assignment operator between an enum element and an integer value of underlying type.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsArithmetical.html">T_EnumIsArithmetical</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting enum element. </dd></dl>

</div>
</div>
<a id="a5b389332b4d0d5ed1f7118f173685d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b389332b4d0d5ed1f7118f173685d0e">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator^ </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bitwise <b>xor</b> operator useable with scoped enum types.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of a bitwise xor operation of the underlying enum values. </dd></dl>

</div>
</div>
<a id="ae596498f62f2978ab6cdcb97d61cfc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae596498f62f2978ab6cdcb97d61cfc83">&#9670;&nbsp;</a></span>operator^=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator^= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bitwise <b>xor assignment</b> operator useable with scoped enum types.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value of <code>lhs</code> which is set to <code>lhs ^ rhs</code>. </dd></dl>

</div>
</div>
<a id="afce7a398d6d214cd36c3a28a2d868519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce7a398d6d214cd36c3a28a2d868519">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator| </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bitwise <b>or</b> operator useable with scoped enum types.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of a bitwise or operation of the underlying enum values. </dd></dl>

</div>
</div>
<a id="a17407b3624b5cc4be4476378d4193082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17407b3624b5cc4be4476378d4193082">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator|= </td>
          <td>(</td>
          <td class="paramtype">TEnum &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bitwise <b>or assignment</b> operator useable with scoped enum types.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>Reference to the first operand. Receives the result. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rhs</td><td>Second operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new value of <code>lhs</code> which is set to <code>lhs | rhs</code>. </dd></dl>

</div>
</div>
<a id="ab0d1471f39a2064b7495ed403c43e247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d1471f39a2064b7495ed403c43e247">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;<a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">aworx::lib::lang::T_EnumIsBitwise</a>&lt;TEnum&gt;::value, TEnum&gt;::type aworx::lib::lang::operator~ </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bitwise <b>not</b> operator useable with scoped enum types.</p>
<p>Selected by the compiler only if <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for template enum type <code>TEnum</code> to inherit <code>std::true_type</code>.</p>
<dl class="section note"><dt>Note</dt><dd>To remove one or more bits from a scoped enum value, operator <b>&amp;=</b> with this operator applied to <code>op</code> can be used. A shortcut to this is given with <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a751225eb2bd89d126ba103c5373e79fc">operator-=</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operand to be negated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enumeration type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of a bitwise negation of <code>op</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 28 2018 20:08:33 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
<!-- Start of StatCounter Code e -->
<script type="text/javascript">
var sc_project=11242602;
var sc_invisible=1;
var sc_security="5ac13373";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web statistics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11242602/0/5ac13373/1/" alt="web
statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
