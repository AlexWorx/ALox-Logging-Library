<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ALox: AString Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!-- so strange, that doxgen does not highlight each menu item. Just some... -->
<script>
  $(document).ready(function() {     
    fnameStart= window.location.href.lastIndexOf('/')
    fnameEnd=   window.location.href.indexOf('_', fnameStart )
    if( fnameEnd < 0 ) {
        fnameEnd=   window.location.href.indexOf('.', fnameStart )
    }
    if( fnameEnd > -1 ) {
        subString= window.location.href.substring( fnameStart, fnameEnd )
        $('li').toArray().forEach(function(li){
            if(     typeof li.firstChild.href != 'undefined'
                &&  li.firstChild.href.indexOf(subString) > 0 
                ){
               li.classList.add('current');
            }
        });
    }
  });
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1604 R. 2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../index.html"><span>ALox&#160;Home</span></a></li>
      <li><a href="../faq.html"><span>FAQ</span></a></li>
      <li><a href="../manual.html"><span>Manual</span></a></li>
      <li class="current"><a href="cppmainpage.html"><span>ALox&#160;for&#160;C++</span></a></li>
      <li><a href="../cs_ref/csmainpage.html"><span>ALox&#160;for&#160;C#</span></a></li>
      <li><a href="../java_ref/javamainpage.html"><span>ALox&#160;for&#160;Java</span></a></li>
      <li><a href="../tools.html"><span>Tools</span></a></li>
      <li><a href="https://github.com/AlexWorx/ALox-Logging-Library"><span>Download</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="cppmainpage.html"><span>Overview</span></a></li>
      <li><a href="cpptutorial.html"><span>Tutorial</span></a></li>
      <li><a href="cppsetup.html"><span>IDE/Build&#160;system&#160;setup</span></a></li>
      <li><a href="cppprepro.html"><span>ALox&#160;Preprocessor&#160;Symbols</span></a></li>
      <li class="current"><a href="annotated.html"><span>Class&#160;Reference</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="classes.html"><span>Alphabetical&#160;Index</span></a></li>
      <li><a href="annotated.html"><span>Namespace&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html">strings</a></li><li class="navelem"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#friends">Friends</a> &#124;
<a href="classaworx_1_1lib_1_1strings_1_1AString-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AString Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="astring_8hpp_source.html">astring.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AString:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1strings_1_1AString__inherit__graph.svg" width="544" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for AString:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1strings_1_1AString__coll__graph.svg" width="76" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><hr/>
<p> Specializes class <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> to implement mutable, non-constant strings using writable buffer memory.</p>
<p>There are two possible types of buffers:</p><ul>
<li><b>Internal buffers</b><br />
 This is the standard case and implements a buffer that is allocated from <em>free memory</em> (aka 'the heap') that eventually grows over time and never shrinks, unless explicitly demanded by the user of the class. Those buffers are deleted when objects of this type are deleted.</li>
<li><b>External buffers</b><br />
 Set with method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0bdd4581fc80e9bba8ceb46e030c75ac">SetBuffer</a>. These buffers don't get deleted. However, if their capacity is exceeded, they will get automatically replaced by an internal buffer. (See field <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ae6e756e6f5ccc142f9fc3ceb6ba18cf0">ReplaceExternalBuffer</a> to control warnings on that in debug compilation).</li>
</ul>
<p><b>Construction/Destruction</b></p>
<p>The following ways of construction are provided:</p><ul>
<li><b>Default construction</b><br />
 Does not allocate a character buffer. The allocation is this way deferred to the first operation that writes data into the object. Alternatively, an external buffer can be set before such operation is invoked.</li>
<li><b>Construction with initial capacity</b><br />
 With constructor <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a8d15090f040cca48bcb7f1875de0fe3e">AString(int)</a>, an initial length can be provided. This construction variant should be used, if the maximum length the object that will be reached during its lifetime is predictable, because it avoids iterative, increasing buffer allocations that otherwise would be performed until that size is reached once. Furthermore there are constructors</li>
<li><b>Construction with external buffers</b><br />
 With constructor <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a56a710a7a5bc7604ce80ae47265f5835">AString(char*, int)</a>, an external buffer is set. This constructor is protected and therefore accessible by derived classes' constructors only. This is to avoid an otherwise likely common misunderstanding that this constructor would copy the contents of a provided cstring. For users of this class, the alternative to this constructor is using a combination of the default constructor and method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0bdd4581fc80e9bba8ceb46e030c75ac">SetBuffer</a> which has exactly the same effect.</li>
<li><b>Construction with strings</b><br />
 Constructors <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#aebc985ab1428055a05aee879e173910a">AString(const T&amp;)</a>, <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>(const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a>&amp;, int, int=) and copy constructor <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4f3aebb5fc9bc80c4f569df5d6450025">AString(const AString&amp;)</a> will allocate an internal buffer of the capacity needed and copy the contents of the given string type.</li>
</ul>
<p>Destruction will free internally allocated buffers. </p><dl class="section note"><dt>Note</dt><dd>Method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0bdd4581fc80e9bba8ceb46e030c75ac">SetBuffer</a> provides a boolean parameter that also allows to let an object of this class take control on the provided buffer, namely delete it in the destructor. In this case, a buffer set with this method is considered an internal buffer, rather than an external one.</dd></dl>
<p><a class="anchor" id="alib_namespace_strings_astring_move"></a><b>Move constructor and move assignment</b></p>
<p>This class provides a (noexcept) move constructor which grabs the buffer of a given movable <b>AString</b>, as long as this given object does not use an external buffer. In the latter case, the contents is copied like in the copy constructor.<br />
 This class does not provide a move assignment operator. The rational for this is that normally a "more temporary" <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> would be assigned to a "less temporary" one. In this case, it would be not helpful to replace the allocated storage, each time. </p><dl class="section note"><dt>Note</dt><dd>In general, while assignment of other objects of type <b>AString</b> is possible through <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ab5e4f0275095724f12cb477527d2f33b">operator=(const AString&amp;)</a>, the advised code style is to use a combination of <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ae4d5af65574550e39830297e4496f81b">Clear</a> and append <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a05403e545a0fa8171456199085790c1c">_()</a> (e.g. <em>myString._()._(otherString)</em>) to do the assignment instead. This leads to exactly the same result as long as the <b>AString</b> that is assigned is not <em>nulled</em>.<br />
 </dd>
<dd>
In the case that it is <em>nulled</em>, using the assignment operator will set this object also to <em>nulled</em> state, hence dispose any currently allocated buffer. This, for most cases is not what is wanted.</dd></dl>
<p><a class="anchor" id="alib_namespace_strings_astring_write_access"></a> <b>Write Access to the Buffer</b></p>
<p>Parent class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> holds its protected field <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">String::buffer</a> in an anonymous C++ union of two pointers, one typed <em>const char*</em> and the other <em>char*</em>. This class exposes the non-constant buffer pointer of that union with method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a39184b93936d495a501cbea28e12495e">VBuffer</a>. This allows users of this class to <em>freely</em> operate on the buffer with any <em>C</em> or <em>C++</em> algorithm available. Of-course, it is up to the programmer doing this to keep invariants that this class naturally constitutes intact.</p>
<p>In addition to this, a bunch of methods allow the modification of characters. <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a8068d1bbfd60c6cb178bdc0b2084ab9b">operator[]</a> is returning a reference to a char in contrast to the same operator defined in class <b>String</b>. This allows assignments of values when using an object with this operator as an lvalue.</p>
<p><a class="anchor" id="alib_namespace_strings_astring_nullable"></a> <b>Nullable AStrings</b></p>
<p>As discussed in the namespace documentation (<a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_namespace_strings_nullable">alib_namespace_strings_nullable</a>) parent class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> provides an interface to detect <em><em>nulled</em></em> objects. This concept is duly implemented in this class. An object of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a56a710a7a5bc7604ce80ae47265f5835">AString</a> is <em><em>nulled</em></em> when no internal buffer is allocated or external buffer is set.</p>
<p>If default constructed, constructed with zero size, a null pointer, or any other string type object which is <em>nulled</em>, no buffer is created and hence the new object is in <em><em>nulled</em></em> state and inherited method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a055d87b78f69c9d039b7e12ead7aa6b6">aworx::lib::strings::String::IsNull</a> "IsNull" will return <code>true</code> for that object. Consequently, it makes a difference if an <b>AString</b> is constructed using <em><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a135d849a18470b04a1f4cf761de3a17c">AString()</a></em> or <em><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>("")</em>. This allows to differentiate between <em>nulled</em> AStrings and empty <b>AStrings</b>, which is quite handy in certain situations. An object that was filled already can be reset to represent null by either assigning a nullptr, by invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0bdd4581fc80e9bba8ceb46e030c75ac">SetBuffer(0)</a> or by invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a787c9800970197d19a5452ac456d64f1">SetNull</a> on the instance. (See also methods <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a055d87b78f69c9d039b7e12ead7aa6b6">IsNull</a>, <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aaaf24e0ec4b4b51df542cd654230c3da">IsNotNull</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ad07c7e740f0be42afb0c1eda25361864">Capacity</a>.) The methods <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa30b895dcfaf0574aca843b212ee2602">Equals</a>, <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa9596ce7ca16857d887ae619a42d231c">CompareTo</a> and the overloaded comparison <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a5458d43552b4f83c721cc967f091cc4c">operator==</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a9582e8e8e4b37606065566ec88f9626d">operator!=</a> allow nullptr comparisons. e.g. a <em><em>nulled</em></em> <b>AString</b> equals to another <em><em>nulled</em></em> <b>AString</b> but not to an empty but not <em><em>nulled</em></em> <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>.</p>
<p>To make this more clear, note the following <b>sample code</b> which does not throw an assertion: </p><div class="fragment"><div class="line">    <span class="comment">// Default constructor does not allocate space, yet.</span></div><div class="line">    <span class="comment">// The instance is &quot;nulled&quot;.</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html#a135d849a18470b04a1f4cf761de3a17c">AString</a> aString;</div><div class="line">    assert(  aString.IsNull()                 );</div><div class="line">    assert(  aString.Equals( <a class="code" href="namespaceaworx.html#ab1ed6dcfbe4628dccefbdb5633b1bf01">NullString</a> )     );</div><div class="line">    assert(  aString == <span class="keyword">nullptr</span> );</div><div class="line"></div><div class="line">    <span class="comment">// Assign an empty string. Now the AString is not nullptr any more</span></div><div class="line">    aString= <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">    assert(  aString.IsNotNull()              );</div><div class="line">    assert( !aString.Equals   ( <a class="code" href="namespaceaworx.html#ab1ed6dcfbe4628dccefbdb5633b1bf01">NullString</a> )  );</div><div class="line">    assert(  aString != <span class="keyword">nullptr</span> );</div><div class="line"></div><div class="line">    <span class="comment">// Assign nullptr</span></div><div class="line">    aString= <span class="keyword">nullptr</span>;</div><div class="line">    assert(  aString.IsNull()                 );</div><div class="line">    assert(  aString.Equals   ( <a class="code" href="namespaceaworx.html#ab1ed6dcfbe4628dccefbdb5633b1bf01">NullString</a> )  );</div><div class="line">    assert(  aString == <span class="keyword">nullptr</span> );</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><ul>
<li>As mentioned above, to avoid loosing an allocated buffer, use a combination of <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ae4d5af65574550e39830297e4496f81b">Clear</a> and append <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a05403e545a0fa8171456199085790c1c">_()</a> to perform assignments with other string types instead of using one of the assignment operators (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ab5e4f0275095724f12cb477527d2f33b">operator=</a>). No check for <em><em>nulled</em></em> string is needed when appending them to an object of this type.</li>
<li>Even if an <b>AString</b> object is <em>nulled</em>, inherited method <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#af283db5a533654cb8a0fa2e110d4b20f">ToCString</a> will return a (zero terminated) valid empty <em>char*</em>. This has the advantage that in many situations the null-state is not needed to be handled (for those cases where the difference between a <em>nulled</em> and an empty string is irrelevant).</li>
</ul>
</dd></dl>
<p><a class="anchor" id="alib_namespace_strings_astring_applyto"></a> <b>Applying Objects to AStrings</b></p>
<p>The concept of appending things to a string is generalized in the C++ implementation of this class and named <em>applying</em> instead. While applying string types is the same as appending string types in other language versions of ALib, the '<em>application</em>' of non-string types allows flexible and well readable code design.</p>
<p>The central mechanism used to apply arbitrary types is similar to what is used by class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> and the partially specialized template function <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7cfd45024bf9222b42febac98fdcc146">ToString</a>. By implementing a new specialization of partially specialized template</p><ul>
<li>function <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aa8fb47b820e77796083d2c3eb13d56b2">ApplyTo</a> and</li>
<li>class <a class="el" href="structaworx_1_1lib_1_1strings_1_1IsApplicable.html">IsApplicable</a></li>
</ul>
<p>it is possible to apply objects of 'external', user defined types to objects of this class.</p>
<p>These partly specialized templates are used by this classes' method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4dbe5fba1e5c5ed69d12d57b3eb49ef7">Apply</a>. Because this method, although declared <em>public</em>, has a more internal character, in standard situations its invocation is performed indirectly through methods:</p><ul>
<li>Constructor <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#aebc985ab1428055a05aee879e173910a">AString(const T&amp;)</a></li>
<li>Operator <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ac243bc3f2d0f61eb45d49f488ddbcb63">operator &lt;&lt;(const T&amp;)</a></li>
<li>Method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a635ad749475cecd00e3ec3603327d78c">_(const T&amp;)</a> (which is a synonym for <em>operator &lt;&lt; </em> but allowing non-checked invocations)</li>
<li>Operator <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a6cfb898b4e0d87d08b6c0b115b690239">operator=(const T&amp;)</a></li>
</ul>
<p>Easy declaration and definition of method <b>ApplyTo</b> (and template class <b>IsApplicable</b>) is supported with macros <a class="el" href="group__GrpALibMacros.html#ga7ef8eaf71cad1c7be73ef8e61dc65177">ALIB_STRINGS_APPLYTO_DECLARATION</a>, <a class="el" href="group__GrpALibMacros.html#ga87261d3411f0175bbc3efab49720023f">ALIB_STRINGS_APPLYTO_DEFINITION</a> and <a class="el" href="group__GrpALibMacros.html#gaf3673497e1c2e5436ad2b369c135658f">ALIB_STRINGS_APPLYTO_INLINE</a>.</p>
<p>For more information refer to documentation of partially specialized template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aa8fb47b820e77796083d2c3eb13d56b2">ApplyTo</a> and</p>
<p><a class="anchor" id="alib_namespace_strings_astring_application_vs_interface"></a> <b>Application Instead of Explicit Interface Methods</b></p>
<p>Various methods that exist in the implementations of class <b>AString</b> in different programming languages versions of ALib, are missing in this C++ implementation. Here, they have been replaced by the concept of <em>applying</em> types. The following provides a list of predefined applicable types found in ALib:</p>
<ul>
<li>Characters (<em>char</em>) and character string <em>([const] char*)</em> types will be appended.</li>
<li>Wide characters (<em>wchar_t</em>) and wide character strings <em>([const] wchar_t*)</em> types. They will be converted to encoded multi-byte character strings according to the currently set locale and appended. (See <a class="el" href="classaworx_1_1lib_1_1ALIB.html#a368faebfbb1d770d76d5e073266a3deb">ALIB::Init</a> for more information about setting locale and <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a73cfa0a1eb5f3c47cb633967c8b22333">String::ToWString</a> for converting in the other direction.)</li>
<li>Plain types <em>int32_t</em>, <em>uint32_t</em>, <em>int64_t</em>, <em>uint64_t</em>, <em>float</em> and <em>double</em>. Their value will be converted to string representations using static object <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#a9c9a27c7479023730cc33644fc6c9164">NumberFormat::Global</a> and appended.</li>
<li>Plain type <em>bool</em> appending the string literal '<code>true'</code> respectively '<code>false'</code> </li>
<li>Class <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format.html">Format</a>, with public inner classes<ul>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Field.html">Format::Field</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Tab.html">Format::Tab</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int32.html">Format::Int32</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt32.html">Format::UInt32</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int64.html">Format::Int64</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt64.html">Format::UInt64</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Double.html">Format::Double</a></li>
</ul>
</li>
</ul>
<p><b>Insert, Replace and Delete</b></p>
<p>The following insert, delete and replace operations are provided:</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a8b5159f28435000513953d4b28b98c6d">InsertAt</a> To insert a string at an arbitrary position.</li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#abf74925ba2fc5109db3c8be01c962e4e">InsertChars</a> To insert a quantity of characters at an arbitrary position.</li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a17e140dfb247b527da7f6e253601e6b3">ReplaceSubstring</a> To replace a substring with a new string .</li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ab7e984ef7acfdeb4d63b572c6f2dca70">ReplaceRegion</a> To replace a substring with a given character.</li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a5bf64f32d0163186492461fb2c3e4300">SearchAndReplace</a> to search all occurrences of a substring and replace by a different string.</li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a7d7ec24a8f70ba85b88032b1d853acd0">Delete</a> To delete an arbitrary substring.</li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a3919b9c770d283b5df0b09b756081d99">DeleteStart</a> To delete n characters from the start.</li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4c72c80e34049aa4566be4fffe4b9251">DeleteEnd</a> To delete n characters from the end. </li>
</ul>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, Destructor and Assignment</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a135d849a18470b04a1f4cf761de3a17c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a135d849a18470b04a1f4cf761de3a17c">AString</a> ()</td></tr>
<tr class="separator:a135d849a18470b04a1f4cf761de3a17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d15090f040cca48bcb7f1875de0fe3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a8d15090f040cca48bcb7f1875de0fe3e">AString</a> (int initialCapacity)</td></tr>
<tr class="separator:a8d15090f040cca48bcb7f1875de0fe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3aebb5fc9bc80c4f569df5d6450025"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4f3aebb5fc9bc80c4f569df5d6450025">AString</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;copy)</td></tr>
<tr class="separator:a4f3aebb5fc9bc80c4f569df5d6450025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0679449a7bd77ef8c90909a186b0f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#aea0679449a7bd77ef8c90909a186b0f8">AString</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&amp;move) noexcept</td></tr>
<tr class="separator:aea0679449a7bd77ef8c90909a186b0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc985ab1428055a05aee879e173910a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aebc985ab1428055a05aee879e173910a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#aebc985ab1428055a05aee879e173910a">AString</a> (const T &amp;src)</td></tr>
<tr class="separator:aebc985ab1428055a05aee879e173910a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572f9132e424efddf6bfa92581db2b36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a572f9132e424efddf6bfa92581db2b36">AString</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;src, int regionStart, int regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>)</td></tr>
<tr class="separator:a572f9132e424efddf6bfa92581db2b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93ea5df790ecc39b4f09e84cbd9805c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ab93ea5df790ecc39b4f09e84cbd9805c">~AString</a> () noexcept</td></tr>
<tr class="separator:ab93ea5df790ecc39b4f09e84cbd9805c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e4f0275095724f12cb477527d2f33b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ab5e4f0275095724f12cb477527d2f33b">operator=</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;copy)</td></tr>
<tr class="separator:ab5e4f0275095724f12cb477527d2f33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfb898b4e0d87d08b6c0b115b690239"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6cfb898b4e0d87d08b6c0b115b690239"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a6cfb898b4e0d87d08b6c0b115b690239">operator=</a> (const T &amp;op)</td></tr>
<tr class="separator:a6cfb898b4e0d87d08b6c0b115b690239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory allocation and buffer access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a0bdd4581fc80e9bba8ceb46e030c75ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0bdd4581fc80e9bba8ceb46e030c75ac">SetBuffer</a> (int newCapacity)</td></tr>
<tr class="separator:a0bdd4581fc80e9bba8ceb46e030c75ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8474e9c19a45b535f1b460aac3847b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0c8474e9c19a45b535f1b460aac3847b">SetBuffer</a> (char *extBuffer, int extBufferSize, int extLength=0, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab5305b978950ba3946cf79a4bccbf7af">enums::Responsibility</a> responsibility=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab5305b978950ba3946cf79a4bccbf7afa2540530a938da82bfe62957f4aff599b">enums::Responsibility::KeepWithSender</a>)</td></tr>
<tr class="separator:a0c8474e9c19a45b535f1b460aac3847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c14574ea5ef859e15b51f288c40f5da"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a0c14574ea5ef859e15b51f288c40f5da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0c14574ea5ef859e15b51f288c40f5da">SetLength</a> (int newLength)</td></tr>
<tr class="separator:a0c14574ea5ef859e15b51f288c40f5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa227b35c03708d90f56d9b3280163f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#afa227b35c03708d90f56d9b3280163f1">EnsureRemainingCapacity</a> (int spaceNeeded)</td></tr>
<tr class="separator:afa227b35c03708d90f56d9b3280163f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc410cc4cccd79e66c2f7491bce4bd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a3fc410cc4cccd79e66c2f7491bce4bd3">GrowBufferAtLeastBy</a> (int minimumGrowth)</td></tr>
<tr class="separator:a3fc410cc4cccd79e66c2f7491bce4bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07c7e740f0be42afb0c1eda25361864"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ad07c7e740f0be42afb0c1eda25361864">Capacity</a> () const </td></tr>
<tr class="separator:ad07c7e740f0be42afb0c1eda25361864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799c4f153843f7dbba7fe16cf9bfc457"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a799c4f153843f7dbba7fe16cf9bfc457">HasInternalBuffer</a> ()</td></tr>
<tr class="separator:a799c4f153843f7dbba7fe16cf9bfc457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787c9800970197d19a5452ac456d64f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a787c9800970197d19a5452ac456d64f1">SetNull</a> ()</td></tr>
<tr class="separator:a787c9800970197d19a5452ac456d64f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Writable Buffer Access</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a39184b93936d495a501cbea28e12495e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a39184b93936d495a501cbea28e12495e">VBuffer</a> () const </td></tr>
<tr class="separator:a39184b93936d495a501cbea28e12495e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cf143ab3c019c18b6ada0ea87a6370"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:ab2cf143ab3c019c18b6ada0ea87a6370"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ab2cf143ab3c019c18b6ada0ea87a6370">SetCharAt</a> (int idx, char c)</td></tr>
<tr class="separator:ab2cf143ab3c019c18b6ada0ea87a6370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8068d1bbfd60c6cb178bdc0b2084ab9b"><td class="memItemLeft" align="right" valign="top">char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a8068d1bbfd60c6cb178bdc0b2084ab9b">operator[]</a> (int op)</td></tr>
<tr class="separator:a8068d1bbfd60c6cb178bdc0b2084ab9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert and Delete</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:ae4d5af65574550e39830297e4496f81b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ae4d5af65574550e39830297e4496f81b">Clear</a> ()</td></tr>
<tr class="separator:ae4d5af65574550e39830297e4496f81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05403e545a0fa8171456199085790c1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a05403e545a0fa8171456199085790c1c">_</a> ()</td></tr>
<tr class="separator:a05403e545a0fa8171456199085790c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5159f28435000513953d4b28b98c6d"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a8b5159f28435000513953d4b28b98c6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a8b5159f28435000513953d4b28b98c6d">InsertAt</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;src, int pos)</td></tr>
<tr class="separator:a8b5159f28435000513953d4b28b98c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf74925ba2fc5109db3c8be01c962e4e"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:abf74925ba2fc5109db3c8be01c962e4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#abf74925ba2fc5109db3c8be01c962e4e">InsertChars</a> (char c, int qty, int pos=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>)</td></tr>
<tr class="separator:abf74925ba2fc5109db3c8be01c962e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e140dfb247b527da7f6e253601e6b3"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a17e140dfb247b527da7f6e253601e6b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a17e140dfb247b527da7f6e253601e6b3">ReplaceSubstring</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;src, int regionStart, int regionLength)</td></tr>
<tr class="separator:a17e140dfb247b527da7f6e253601e6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e984ef7acfdeb4d63b572c6f2dca70"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:ab7e984ef7acfdeb4d63b572c6f2dca70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ab7e984ef7acfdeb4d63b572c6f2dca70">ReplaceRegion</a> (char c, int regionStart, int regionLength)</td></tr>
<tr class="separator:ab7e984ef7acfdeb4d63b572c6f2dca70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7ec24a8f70ba85b88032b1d853acd0"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a7d7ec24a8f70ba85b88032b1d853acd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a7d7ec24a8f70ba85b88032b1d853acd0">Delete</a> (int regionStart, int regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>)</td></tr>
<tr class="separator:a7d7ec24a8f70ba85b88032b1d853acd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3919b9c770d283b5df0b09b756081d99"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a3919b9c770d283b5df0b09b756081d99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a3919b9c770d283b5df0b09b756081d99">DeleteStart</a> (int regionLength)</td></tr>
<tr class="separator:a3919b9c770d283b5df0b09b756081d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c72c80e34049aa4566be4fffe4b9251"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a4c72c80e34049aa4566be4fffe4b9251"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4c72c80e34049aa4566be4fffe4b9251">DeleteEnd</a> (int regionLength)</td></tr>
<tr class="separator:a4c72c80e34049aa4566be4fffe4b9251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5902ed6d5d02134b98ac686172f34dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a5902ed6d5d02134b98ac686172f34dc9">Trim</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;trimChars=<a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">DefaultWhitespaces</a>)</td></tr>
<tr class="separator:a5902ed6d5d02134b98ac686172f34dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f255e8769be77d70b70407e388746b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a63f255e8769be77d70b70407e388746b">TrimAt</a> (int index, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;trimChars=<a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">DefaultWhitespaces</a>)</td></tr>
<tr class="separator:a63f255e8769be77d70b70407e388746b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aacb9ead9be86623c688267f76760cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4aacb9ead9be86623c688267f76760cf">TrimStart</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;trimChars=<a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">DefaultWhitespaces</a>)</td></tr>
<tr class="separator:a4aacb9ead9be86623c688267f76760cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb73aa66ba9e9ebedecd9de6ee6ed9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#abfb73aa66ba9e9ebedecd9de6ee6ed9b">TrimEnd</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;trimChars=<a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">DefaultWhitespaces</a>)</td></tr>
<tr class="separator:abfb73aa66ba9e9ebedecd9de6ee6ed9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Append and apply</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a45cb08597c96cf62edb8ece124d8e4fc"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a45cb08597c96cf62edb8ece124d8e4fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a45cb08597c96cf62edb8ece124d8e4fc">Append</a> (const char *src, int srcLength)</td></tr>
<tr class="separator:a45cb08597c96cf62edb8ece124d8e4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e836e4a665a6ffd7cd1ee48dda06798"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4e836e4a665a6ffd7cd1ee48dda06798">Append</a> (const wchar_t *src, int srcLength)</td></tr>
<tr class="separator:a4e836e4a665a6ffd7cd1ee48dda06798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbe5fba1e5c5ed69d12d57b3eb49ef7"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, class T &gt; </td></tr>
<tr class="memitem:a4dbe5fba1e5c5ed69d12d57b3eb49ef7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4dbe5fba1e5c5ed69d12d57b3eb49ef7">Apply</a> (const T &amp;src)</td></tr>
<tr class="separator:a4dbe5fba1e5c5ed69d12d57b3eb49ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635ad749475cecd00e3ec3603327d78c"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true, class T &gt; </td></tr>
<tr class="memitem:a635ad749475cecd00e3ec3603327d78c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a635ad749475cecd00e3ec3603327d78c">_</a> (const T &amp;src)</td></tr>
<tr class="separator:a635ad749475cecd00e3ec3603327d78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5997f9405428b49e5fd680e62ee41c45"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a5997f9405428b49e5fd680e62ee41c45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a5997f9405428b49e5fd680e62ee41c45">_</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;src, int regionStart, int regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>)</td></tr>
<tr class="separator:a5997f9405428b49e5fd680e62ee41c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac243bc3f2d0f61eb45d49f488ddbcb63"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac243bc3f2d0f61eb45d49f488ddbcb63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ac243bc3f2d0f61eb45d49f488ddbcb63">operator&lt;&lt;</a> (const T &amp;op)</td></tr>
<tr class="separator:ac243bc3f2d0f61eb45d49f488ddbcb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949cac7084e10566b50a195b60bff591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a949cac7084e10566b50a195b60bff591">NewLine</a> ()</td></tr>
<tr class="separator:a949cac7084e10566b50a195b60bff591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Replace</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a5bf64f32d0163186492461fb2c3e4300"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a5bf64f32d0163186492461fb2c3e4300">SearchAndReplace</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;needle, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;replacement, int startIdx=0, int maxReplacements=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>)</td></tr>
<tr class="separator:a5bf64f32d0163186492461fb2c3e4300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2d3b01c31c088c8e04676c6e50e78b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ada2d3b01c31c088c8e04676c6e50e78b">SearchAndReplaceAll</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> needle, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;replacement, int startIdx=0, int maxReplacements=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>)</td></tr>
<tr class="separator:ada2d3b01c31c088c8e04676c6e50e78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76441306378ccdc4d560ea2ea417a89b"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a76441306378ccdc4d560ea2ea417a89b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a76441306378ccdc4d560ea2ea417a89b">ToUpper</a> (int regionStart=0, int regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>)</td></tr>
<tr class="separator:a76441306378ccdc4d560ea2ea417a89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1a7077beb29dd16e84c469e5e01f12"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a4d1a7077beb29dd16e84c469e5e01f12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4d1a7077beb29dd16e84c469e5e01f12">ToLower</a> (int regionStart=0, int regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>)</td></tr>
<tr class="separator:a4d1a7077beb29dd16e84c469e5e01f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classaworx_1_1lib_1_1strings_1_1TString')"><img src="closed.png" alt="-"/>&#160;Public Methods inherited from <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a></td></tr>
<tr class="memitem:a0b3b9871d2fc6522c1f2aedf67b8b1c2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a0b3b9871d2fc6522c1f2aedf67b8b1c2">operator[]</a> (int op) const </td></tr>
<tr class="separator:a0b3b9871d2fc6522c1f2aedf67b8b1c2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1430f618f869550a47b5f078ce6860 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a7a1430f618f869550a47b5f078ce6860">Terminate</a> () const </td></tr>
<tr class="separator:a7a1430f618f869550a47b5f078ce6860 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57423bbca362af5c912ea619d9a14746 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a57423bbca362af5c912ea619d9a14746 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a57423bbca362af5c912ea619d9a14746">IndexOf</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;needle, int startIdx=0, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:a57423bbca362af5c912ea619d9a14746 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77001b79e815a22ce126e3df14f591b2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a77001b79e815a22ce126e3df14f591b2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a77001b79e815a22ce126e3df14f591b2">IndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;needles, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a217539925b78b2eed40ae7817d5bee52">enums::Inclusion</a> inclusion, int startIdx=0) const </td></tr>
<tr class="separator:a77001b79e815a22ce126e3df14f591b2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75164b28454722bdf29710c208f0736 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ab75164b28454722bdf29710c208f0736">operator const char *</a> ()</td></tr>
<tr class="separator:ab75164b28454722bdf29710c208f0736 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af283db5a533654cb8a0fa2e110d4b20f inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#af283db5a533654cb8a0fa2e110d4b20f">ToCString</a> () const </td></tr>
<tr class="separator:af283db5a533654cb8a0fa2e110d4b20f inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2efe140bd7fe9300fa64c27c7adab08 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#af2efe140bd7fe9300fa64c27c7adab08">ToLong</a> (int startIdx=0, int *newIdx=nullptr, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> *whitespaces=nullptr) const </td></tr>
<tr class="separator:af2efe140bd7fe9300fa64c27c7adab08 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0318c4e2b29a58be56c9f8645184448d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a0318c4e2b29a58be56c9f8645184448d">ToInt</a> (int startIdx=0, int *newIdx=nullptr, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> *whitespaces=nullptr) const </td></tr>
<tr class="separator:a0318c4e2b29a58be56c9f8645184448d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefab2dff23cb4a711c8efdd73e85c15e inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aefab2dff23cb4a711c8efdd73e85c15e">ToFloat</a> (int startIdx=0, int *newIdx=nullptr, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat=nullptr, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> *whitespaces=nullptr) const </td></tr>
<tr class="separator:aefab2dff23cb4a711c8efdd73e85c15e inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8747c38ac0ef9f863ede544d51ff6721 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a8747c38ac0ef9f863ede544d51ff6721">_dbgCheck</a> () const </td></tr>
<tr class="separator:a8747c38ac0ef9f863ede544d51ff6721 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad751e8adb9aa217a042c45e1c0585285 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ad751e8adb9aa217a042c45e1c0585285">TString</a> ()</td></tr>
<tr class="separator:ad751e8adb9aa217a042c45e1c0585285 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0c3a5e03ba9a10bd9b19a22a261499 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe0c3a5e03ba9a10bd9b19a22a261499 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#abe0c3a5e03ba9a10bd9b19a22a261499">TString</a> (const T &amp;src)</td></tr>
<tr class="separator:abe0c3a5e03ba9a10bd9b19a22a261499 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classaworx_1_1lib_1_1strings_1_1String')"><img src="closed.png" alt="-"/>&#160;Public Methods inherited from <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a></td></tr>
<tr class="memitem:adcffeb665e497d8c0909063e4b5df871 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adcffeb665e497d8c0909063e4b5df871">String</a> ()</td></tr>
<tr class="separator:adcffeb665e497d8c0909063e4b5df871 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863a723eb56ea0b5fab9a838c5f27658 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a863a723eb56ea0b5fab9a838c5f27658">String</a> (const char *<a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a>, int contentLength)</td></tr>
<tr class="separator:a863a723eb56ea0b5fab9a838c5f27658 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91744e23d962777f812b537979d5ce9e inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a91744e23d962777f812b537979d5ce9e">String</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;src, int regionStart, int regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>)</td></tr>
<tr class="separator:a91744e23d962777f812b537979d5ce9e inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1f593a0b9b71d210993cea0727b419 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b1f593a0b9b71d210993cea0727b419 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a2b1f593a0b9b71d210993cea0727b419">String</a> (const T &amp;src)</td></tr>
<tr class="separator:a2b1f593a0b9b71d210993cea0727b419 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5ce30daece7ec96d0b70ccc5d46002 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a5d5ce30daece7ec96d0b70ccc5d46002">Buffer</a> () const </td></tr>
<tr class="separator:a5d5ce30daece7ec96d0b70ccc5d46002 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e891964a37680c01e21dedac6ffe670 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a6e891964a37680c01e21dedac6ffe670">Length</a> () const </td></tr>
<tr class="separator:a6e891964a37680c01e21dedac6ffe670 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055d87b78f69c9d039b7e12ead7aa6b6 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a055d87b78f69c9d039b7e12ead7aa6b6">IsNull</a> () const </td></tr>
<tr class="separator:a055d87b78f69c9d039b7e12ead7aa6b6 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf24e0ec4b4b51df542cd654230c3da inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aaaf24e0ec4b4b51df542cd654230c3da">IsNotNull</a> () const </td></tr>
<tr class="separator:aaaf24e0ec4b4b51df542cd654230c3da inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef62c8761ddd1b95824fc57b1b277b5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aaef62c8761ddd1b95824fc57b1b277b5">IsEmpty</a> () const </td></tr>
<tr class="separator:aaef62c8761ddd1b95824fc57b1b277b5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484ba322b1d13f2e2c90066db81179ed inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a484ba322b1d13f2e2c90066db81179ed">IsNotEmpty</a> () const </td></tr>
<tr class="separator:a484ba322b1d13f2e2c90066db81179ed inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9706f704337ae92062d7b68c8f33ea inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:aaf9706f704337ae92062d7b68c8f33ea inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aaf9706f704337ae92062d7b68c8f33ea">CharAt</a> (int idx) const </td></tr>
<tr class="separator:aaf9706f704337ae92062d7b68c8f33ea inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43766377944d0423a71478f1bbd61e1 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:aa43766377944d0423a71478f1bbd61e1 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa43766377944d0423a71478f1bbd61e1">CharAtStart</a> () const </td></tr>
<tr class="separator:aa43766377944d0423a71478f1bbd61e1 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fb764265a5d096e56717a52754396d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a78fb764265a5d096e56717a52754396d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a78fb764265a5d096e56717a52754396d">CharAtEnd</a> () const </td></tr>
<tr class="separator:a78fb764265a5d096e56717a52754396d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3b9871d2fc6522c1f2aedf67b8b1c2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a0b3b9871d2fc6522c1f2aedf67b8b1c2">operator[]</a> (int op) const </td></tr>
<tr class="separator:a0b3b9871d2fc6522c1f2aedf67b8b1c2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30b895dcfaf0574aca843b212ee2602 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa30b895dcfaf0574aca843b212ee2602">Equals</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:aa30b895dcfaf0574aca843b212ee2602 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6c00e3b4e659d0088973d4219d86b3 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a0c6c00e3b4e659d0088973d4219d86b3 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a0c6c00e3b4e659d0088973d4219d86b3">ContainsAt</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, int pos, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:a0c6c00e3b4e659d0088973d4219d86b3 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874e198025e872dc30012ccdaef4ea71 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a874e198025e872dc30012ccdaef4ea71">StartsWith</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:a874e198025e872dc30012ccdaef4ea71 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f943472db189e27586b5ad6df554f4 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a34f943472db189e27586b5ad6df554f4">EndsWith</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:a34f943472db189e27586b5ad6df554f4 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9596ce7ca16857d887ae619a42d231c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:aa9596ce7ca16857d887ae619a42d231c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa9596ce7ca16857d887ae619a42d231c">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:aa9596ce7ca16857d887ae619a42d231c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830c0be0e018f2e52eb311d566e61338 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a830c0be0e018f2e52eb311d566e61338 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a830c0be0e018f2e52eb311d566e61338">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity, int cmpRegionStart, int cmpRegionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>) const </td></tr>
<tr class="separator:a830c0be0e018f2e52eb311d566e61338 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6c71cbde80abfd17075314878964a9 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a6e6c71cbde80abfd17075314878964a9 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a6e6c71cbde80abfd17075314878964a9">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity, int cmpRegionStart, int cmpRegionLength, int regionStart, int regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>) const </td></tr>
<tr class="separator:a6e6c71cbde80abfd17075314878964a9 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87398e168744e30fdae0c9641273ab2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa87398e168744e30fdae0c9641273ab2">operator&lt;</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const </td></tr>
<tr class="separator:aa87398e168744e30fdae0c9641273ab2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e233e56892e8dde5bbc59d232561895 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8e233e56892e8dde5bbc59d232561895">operator&gt;</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const </td></tr>
<tr class="separator:a8e233e56892e8dde5bbc59d232561895 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5458d43552b4f83c721cc967f091cc4c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a5458d43552b4f83c721cc967f091cc4c">operator==</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const </td></tr>
<tr class="separator:a5458d43552b4f83c721cc967f091cc4c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9582e8e8e4b37606065566ec88f9626d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a9582e8e8e4b37606065566ec88f9626d">operator!=</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const </td></tr>
<tr class="separator:a9582e8e8e4b37606065566ec88f9626d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4903bdaa9803322caddc87c623646a90 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a4903bdaa9803322caddc87c623646a90">IndexOf</a> (char needle) const </td></tr>
<tr class="separator:a4903bdaa9803322caddc87c623646a90 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62c5abf6381ef65c72b97183fd64c8d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:ab62c5abf6381ef65c72b97183fd64c8d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ab62c5abf6381ef65c72b97183fd64c8d">IndexOf</a> (char needle, int regionStart) const </td></tr>
<tr class="separator:ab62c5abf6381ef65c72b97183fd64c8d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea4959c28189d614a7c883dae3787f5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a8ea4959c28189d614a7c883dae3787f5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8ea4959c28189d614a7c883dae3787f5">IndexOf</a> (char needle, int regionStart, int regionLength) const </td></tr>
<tr class="separator:a8ea4959c28189d614a7c883dae3787f5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff7c059a19d1003e1d150ab86d784f8 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a6ff7c059a19d1003e1d150ab86d784f8 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a6ff7c059a19d1003e1d150ab86d784f8">LastIndexOf</a> (char needle, int startIndex=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>) const </td></tr>
<tr class="separator:a6ff7c059a19d1003e1d150ab86d784f8 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56c0c63f30160a0e3e44957e3409732 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:af56c0c63f30160a0e3e44957e3409732 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#af56c0c63f30160a0e3e44957e3409732">IndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needles, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a217539925b78b2eed40ae7817d5bee52">enums::Inclusion</a> inclusion, int startIdx=0) const </td></tr>
<tr class="separator:af56c0c63f30160a0e3e44957e3409732 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7292ca793aceb1572d65a8ee444e97c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:aa7292ca793aceb1572d65a8ee444e97c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa7292ca793aceb1572d65a8ee444e97c">LastIndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needles, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a217539925b78b2eed40ae7817d5bee52">enums::Inclusion</a> inclusion, int startIdx=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>) const </td></tr>
<tr class="separator:aa7292ca793aceb1572d65a8ee444e97c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc427de75c146cf8618a397833edaa9a inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:adc427de75c146cf8618a397833edaa9a inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adc427de75c146cf8618a397833edaa9a">IndexOfSubstring</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, int startIdx=0, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:adc427de75c146cf8618a397833edaa9a inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cfa0a1eb5f3c47cb633967c8b22333 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a73cfa0a1eb5f3c47cb633967c8b22333">ToWString</a> (wchar_t *dest, int destCapacity, int regionStart=0, int regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>) const </td></tr>
<tr class="separator:a73cfa0a1eb5f3c47cb633967c8b22333 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe13e5000dc11709e5da14d928f838b7 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#afe13e5000dc11709e5da14d928f838b7">AdjustRegion</a> (int &amp;regionStart, int &amp;regionLength) const </td></tr>
<tr class="separator:afe13e5000dc11709e5da14d928f838b7 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad3c3bba82982d562b15eb6c9f80bef1e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad3c3bba82982d562b15eb6c9f80bef1e"></a>
template&lt;const int TCapacity&gt; </td></tr>
<tr class="memitem:ad3c3bba82982d562b15eb6c9f80bef1e"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PreallocatedString</b></td></tr>
<tr class="separator:ad3c3bba82982d562b15eb6c9f80bef1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Debug Features</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp18d5773e76efea404b20dc446350f091"></a></p><h6></h6>
<h2></h2>
</td></tr>
<tr class="memitem:a7ebc042256408173ee3c3904906a0e47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a7ebc042256408173ee3c3904906a0e47">debugLastAllocRequest</a> =0</td></tr>
<tr class="separator:a7ebc042256408173ee3c3904906a0e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa155a96ba168342ab2ae8067d96e373e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#aa155a96ba168342ab2ae8067d96e373e">debugBufferWithMagicBytePadding</a> =false</td></tr>
<tr class="separator:aa155a96ba168342ab2ae8067d96e373e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe66a087ac3fd4a5b0566f64ca2d12b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#adbe66a087ac3fd4a5b0566f64ca2d12b">capacity</a></td></tr>
<tr class="separator:adbe66a087ac3fd4a5b0566f64ca2d12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e756e6f5ccc142f9fc3ceb6ba18cf0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ae6e756e6f5ccc142f9fc3ceb6ba18cf0">ReplaceExternalBuffer</a> = true</td></tr>
<tr class="separator:ae6e756e6f5ccc142f9fc3ceb6ba18cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8747c38ac0ef9f863ede544d51ff6721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a8747c38ac0ef9f863ede544d51ff6721">_dbgCheck</a> () const </td></tr>
<tr class="separator:a8747c38ac0ef9f863ede544d51ff6721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a710a7a5bc7604ce80ae47265f5835"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a56a710a7a5bc7604ce80ae47265f5835">AString</a> (char *extBuffer, int extBufferSize)</td></tr>
<tr class="separator:a56a710a7a5bc7604ce80ae47265f5835"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classaworx_1_1lib_1_1strings_1_1TString"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classaworx_1_1lib_1_1strings_1_1TString')"><img src="closed.png" alt="-"/>&#160;Public Fields inherited from <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a></td></tr>
<tr class="memitem:ac3615a067cb671e6b0cac6dbb26c9f3e inherit pub_attribs_classaworx_1_1lib_1_1strings_1_1TString"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ac3615a067cb671e6b0cac6dbb26c9f3e">debugIsTerminated</a> =-1</td></tr>
<tr class="separator:ac3615a067cb671e6b0cac6dbb26c9f3e inherit pub_attribs_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classaworx_1_1lib_1_1strings_1_1String')"><img src="closed.png" alt="-"/>&#160;Protected Fields inherited from <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a></td></tr>
<tr class="memitem:adae84acc92cd77a04f6aaf533643a33a inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a></td></tr>
<tr class="separator:adae84acc92cd77a04f6aaf533643a33a inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f59b34b1f25fe00023291b678246bcc inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a9f59b34b1f25fe00023291b678246bcc">length</a></td></tr>
<tr class="separator:a9f59b34b1f25fe00023291b678246bcc inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab060ffba71bd8a3d7067a38950b39a82 inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ab060ffba71bd8a3d7067a38950b39a82">vbuffer</a></td></tr>
<tr class="separator:ab060ffba71bd8a3d7067a38950b39a82 inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classaworx_1_1lib_1_1strings_1_1TString"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classaworx_1_1lib_1_1strings_1_1TString')"><img src="closed.png" alt="-"/>&#160;Protected Methods inherited from <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a></td></tr>
<tr class="memitem:a6d715743a3937ea101a8deda34d993dc inherit pro_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a6d715743a3937ea101a8deda34d993dc">TString</a> (const char *<a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a>, int contentLength)</td></tr>
<tr class="separator:a6d715743a3937ea101a8deda34d993dc inherit pro_methods_classaworx_1_1lib_1_1strings_1_1TString"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a56a710a7a5bc7604ce80ae47265f5835"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>extBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructs an <b>AString</b> with the given external buffer. The given buffers' life-cycle is considered to be managed externally.<br />
 This constructor is protected and provided for derived classes that dispose about their own buffer.</p>
<dl class="section note"><dt>Note</dt><dd>Protected access was given to this method also to avoid misunderstandings that this constructor is not for providing copyable string data. If the functionality of this constructor is needed, it can simply be imitated by<ul>
<li>default construction and</li>
<li>immediate invocation of <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0c8474e9c19a45b535f1b460aac3847b">SetBuffer(char*, int, int, enums::Responsibility)</a>.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extBuffer</td><td>The external buffer to use. </td></tr>
    <tr><td class="paramname">extBufferSize</td><td>The capacity of the given buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a135d849a18470b04a1f4cf761de3a17c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructs an empty, <em>nulled</em> <b>AString</b> (does not allocate a buffer). </p>

</div>
</div>
<a class="anchor" id="a8d15090f040cca48bcb7f1875de0fe3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initialCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructor allocating a specific given buffer size (plus one for a potential termination character).</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is useful for <b>AString</b> objects whose minimum future string length is predictable to avoid recurring incremental allocations up to the known minimum size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialCapacity</td><td>The size of the buffer that is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f3aebb5fc9bc80c4f569df5d6450025"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Copy constructor that allocates memory and copies the contents of the given object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>The object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea0679449a7bd77ef8c90909a186b0f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>move</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Move constructor. See <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#alib_namespace_strings_astring_move">Move Constructor and Move Assignment</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">move</td><td>The object to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebc985ab1428055a05aee879e173910a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructs the object and uses <em>Apply</em> to append objects of arbitrary type. See <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4dbe5fba1e5c5ed69d12d57b3eb49ef7">Apply</a> for more information.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>source</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source of type T to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a572f9132e424efddf6bfa92581db2b36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructor copying a region of an <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The reference to the the <b>String</b> to copy from. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in <code>src</code> to append. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region in <code>src</code> to append. Defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab93ea5df790ecc39b4f09e84cbd9805c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Destructs an <b>AString</b> object </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a05403e545a0fa8171456199085790c1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; _ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Clear the Buffer. Same as <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ae4d5af65574550e39830297e4496f81b">Clear()</a>, really just a synonym to allow short code in alignment with the various "Apply" methods named <em>_(type src)</em> </p><dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a635ad749475cecd00e3ec3603327d78c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; _ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Wrapper method around <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4dbe5fba1e5c5ed69d12d57b3eb49ef7">Apply</a> that returns <code>*this</code> to allow concatenated calls.</p>
<p>With template parameter TCheck equal to <code>true</code>, this method is equivalent to invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ac243bc3f2d0f61eb45d49f488ddbcb63">operator&lt;&lt;(const T&amp;)</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is added to the method name, checks are omitted. </td></tr>
    <tr><td class="paramname">T</td><td>The type of parameter <code>source</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source of type <code>T</code> to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a5997f9405428b49e5fd680e62ee41c45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; _ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a45cb08597c96cf62edb8ece124d8e4fc">Append</a> on a region of a reference of <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a>. Accepts various types for <code>src</code>, due to the flexibility of class <b>String</b> to implicitly construct.</p>
<dl class="section note"><dt>Note</dt><dd>When using the non-checking version, parameter <code>regionLength</code> must be set explicitly to the correct value (instead of using the default value).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Chooses checking or non-checking implementation. Defaults to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The <b>String</b> to append. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region in src to append. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The maximum length of the region in src to append. Defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a8747c38ac0ef9f863ede544d51ff6721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _dbgCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks this objects' state. This method is internally invoked with almost every other method of this class, but only if compilation symbol <a class="el" href="group__GrpALibCodeSelectorSymbols.html#gae0e4a87e11482df5ecd72f6a2a648f05">ALIB_DEBUG_STRINGS</a> is defined. </p>

</div>
</div>
<a class="anchor" id="a45cb08597c96cf62edb8ece124d8e4fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; Append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Appends a portion of a cstring.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is added to the method name, no nullptr check is done on parameter <code>src</code>. Also, this object would not loose a <em>nulled</em> state when the given cstring portion is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A pointer to the cstring to append. </td></tr>
    <tr><td class="paramname">srcLength</td><td>The length of the portion of the cstring to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e836e4a665a6ffd7cd1ee48dda06798"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp; Append </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Appends a portion of a wide cstring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A pointer to the wide cstring to append. </td></tr>
    <tr><td class="paramname">srcLength</td><td>The length of the portion of the cstring to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a4dbe5fba1e5c5ed69d12d57b3eb49ef7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Apply </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This generic method allows to apply or 'use' this object with different types of other objects. If the given type is a string type, then 'apply' means to append the string.<br />
 In detail, the implementation of this method proceeds as follows:</p><ul>
<li>If a pointer type is detected and value is nullptr, nothing is done and -1 is returned. This allows the caller to react on nullptr values (e.g. the assignment operator, would set this object to <em>nulled</em> state if -1 was returned).</li>
<li>If a reference or pointer type of StringLiteral&lt;TLength&gt; or a character string literal (respectively a fixed size char array) is provided, its contents is appended to this <b>AString</b> and the appended length is returned. (The append operation in this case is implemented using fast inline method <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringLiteral.html#a9d3a01b96278e25b770eabce9295bdf9">StringLiteral::Copy</a>)</li>
<li>If above is <code>false</code>, using TMP mechanics, the given parameter <code>src</code> of type <code>T</code> is converted into a const reference of the original type.<br />
 E.g. if a <em>std::string* src</em> was given, it is converted to <em>const std::string&amp; src</em>.</li>
<li>This const reference is then passed to partially implemented template function <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aa8fb47b820e77796083d2c3eb13d56b2">ApplyTo(AString&amp; , const T)</a>.<br />
</li>
<li>If a matching (partially implemented) template method is found, this method defines what 'applying' of an object of this type means.</li>
<li>The default implementation of <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aa8fb47b820e77796083d2c3eb13d56b2">ApplyTo(AString&amp;,const T)</a> determines if <code>src</code> is of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> or derived from that. If yes, the contents of such <b>String</b> is appended.</li>
<li>Furthermore, the default implementation determines if an <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> was constructible from the given <code>src</code> object (using TMP 'method' <a class="el" href="structaworx_1_1lib_1_1strings_1_1ToStringDefined.html">ToStringDefined</a>.</li>
</ul>
<p>See <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aa8fb47b820e77796083d2c3eb13d56b2">ApplyTo( AString&amp;,const T)</a> for information on how to implement a supporting template method to allow the application of user defined types.</p>
<dl class="section note"><dt>Note</dt><dd>A static assertion tries to detect unsupported types at compile time. However, there might be a few types not fetched by this static assert. In this case an ALIB_WARNING is raised at runtime and 0 is returned.</dd></dl>
<p><b>Usage</b></p>
<p>This method not directly used by standard user code. However, indirectly it is used through:</p><ul>
<li>constructor <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#aebc985ab1428055a05aee879e173910a">AString(const T&amp; src)</a></li>
<li>assignment <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a6cfb898b4e0d87d08b6c0b115b690239">operator=(const T&amp; src)</a></li>
<li>apply <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ac243bc3f2d0f61eb45d49f488ddbcb63">operator &lt;&lt;(const T&amp; src)</a>.</li>
<li>apply method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a635ad749475cecd00e3ec3603327d78c">_(const T&amp; src)</a></li>
</ul>
<p>which therefore each provide huge flexibility in their use.</p>
<p><b>Built-in Applicable Types</b></p>
<p>For a list of Bult-in typse that are applicable using this method, respectively the methods listed in the previous section, see <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#alib_namespace_strings_astring_application_vs_interface">Application Instead of Explicit Interface Methods</a>.</p>
<p><b>Non-checking version</b></p>
<p>If template parameter <code>TCheck</code> is provided as <code>false</code> on invocation, two things are omitted:</p><ul>
<li>There is no check for nullptr objects (attention!)</li>
<li>If this is a <em>nulled</em> <b>AString</b> object, and the length of the given parameter <code>src</code> to append is zero (e.g. an empty string), this object would not loose its <em>nulled</em> state. In other words, <em>nulled</em> strings keep being <em>nulled</em> if empty objects are appended when invocating this method with <code>TCheck=</code> <code>false</code>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The one and only motivation for using the non-checking version of this method is to improve performance in critical code sections.</dd>
<dd>
This method's description may sound (and the code may look) like having quite some runtime overhead. However, due to TMP, there is no overhead involved with this mechanism, in respect to the alternative of having overloaded apply methods implemented.</dd></dl>
<p><b>Sample</b></p>
<p>Besides implementations of <em>ApplyTo</em> for various types like integer or double, ALib provides class <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format.html">Format</a> having public inner classes with simple constructors that are useful to pass to the methods listed above like in the following sample:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="alib_8hpp.html">alib/alib.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// get support for  ostream operator&lt;&lt;() on String objects</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="std__iostream_8hpp.html">alib/compatibility/std_iostream.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="std__string_8hpp.html">alib/compatibility/std_string.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="directory_8hpp.html">alib/system/directory.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceaworx.html">aworx</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> PrintResult()</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> result= 42; <span class="comment">// this took a long time to calculate</span></div><div class="line"></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> as;</div><div class="line">    as &lt;&lt;  <span class="stringliteral">&quot;The result is: &quot;</span> &lt;&lt; <a class="code" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Tab.html">Format::Tab</a>(15) &lt;&lt; <a class="code" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Field.html">Format::Field</a>( <a class="code" href="namespaceaworx.html#a148a217c34a72b4360462205858b8f0e">String16</a>(result), 8, Alignment::Center, <span class="charliteral">&#39;*&#39;</span> );</div><div class="line">    cout &lt;&lt; as &lt;&lt; endl;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> The output will be:</p>
<div class="fragment"><div class="line">The result is:                ***42***</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is added to the method name, checks are omitted as documented. </td></tr>
    <tr><td class="paramname">T</td><td>The type of parameter <code>source</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source of type T to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the given object represents a <em>nulled</em> string. Otherwise 0 or positive value is returned (indicating the number of characters that were appended, but not necessarily correct). Depends on the implementation of the template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aa8fb47b820e77796083d2c3eb13d56b2">ApplyTo( AString&amp;,const T)</a> which is invoked in turn. </dd></dl>

</div>
</div>
<a class="anchor" id="ad07c7e740f0be42afb0c1eda25361864"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> The current size of the internal buffer (this is excluding the trailing '\0'character) which is reserved to terminate the represented character array if needed. In other words, the internal memory allocated is the size returned here plus one.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the allocated buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4d5af65574550e39830297e4496f81b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Clear the Buffer. Same as <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a7d7ec24a8f70ba85b88032b1d853acd0">Delete(0, Length())</a> (but of-course, without internal region checks). </p><dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d7ec24a8f70ba85b88032b1d853acd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; Delete </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Deletes a region from the Buffer. A range check is performed and the region is cut to fit to the string.</p>
<p>The non-checking version (<code>TCheck</code> = <code>false</code>) still allows to leave parameter <code>regionLength</code> as default (respectively allows the sum of parameters <code>regionStart</code> and <code>regionLength</code> to be longer than the length of this <b>AString</b>). In this case, this string is cut starting from index <code>regionStart</code>.</p>
<dl class="section note"><dt>Note</dt><dd>See also methods <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ae4d5af65574550e39830297e4496f81b">Clear</a>, <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a3919b9c770d283b5df0b09b756081d99">DeleteStart</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4c72c80e34049aa4566be4fffe4b9251">DeleteEnd</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is added to the method name, no parameter checks are performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionStart</td><td>The start of the region to delete. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region to delete. Defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c72c80e34049aa4566be4fffe4b9251"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; DeleteEnd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Deletes the given number of characters from the end of the string.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is added to the method name, no parameter checks are performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionLength</td><td>The length of the region at the end to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a3919b9c770d283b5df0b09b756081d99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; DeleteStart </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Deletes the given number of characters from the start of the string.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is added to the method name, no parameter checks are performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionLength</td><td>The length of the region at the start to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="afa227b35c03708d90f56d9b3280163f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EnsureRemainingCapacity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>spaceNeeded</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Ensures that the capacity of the internal buffer meets or exceeds the actual length plus the given growth value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spaceNeeded</td><td>The desired growth of the length of the string represented by this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fc410cc4cccd79e66c2f7491bce4bd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GrowBufferAtLeastBy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minimumGrowth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Increases the allocation size at least by the value provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimumGrowth</td><td>The desired minimum growth of length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a799c4f153843f7dbba7fe16cf9bfc457"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HasInternalBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code>, if the buffer was allocated by this class itself. If the buffer was set using <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0c8474e9c19a45b535f1b460aac3847b">SetBuffer(char*,int,int,enums::Responsibility)</a> with parameter <code>responsibility</code> given as <code>Responsibility::KeepWithSender</code> (and not automatically replaced, yet, because it became too small) then <code>false</code> is returned. </p><dl class="section note"><dt>Note</dt><dd>Derived class <a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">PreallocatedString</a> will report <code>false</code> here. This sounds wrong on the first sight, as the buffer is allocated by an 'internal' member. But from an <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>'s perspective, class <em><a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">PreallocatedString</a></em> works on an 'external' buffer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the buffer is internally allocated and will be deleted with the deletion of this object. False otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b5159f28435000513953d4b28b98c6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; InsertAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Inserts the given strings at given position. If the position is not between 0 and the length of the target, nothing is inserted.</p>
<dl class="section note"><dt>Note</dt><dd>To insert a string with replacing a different one at the same time, use <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a17e140dfb247b527da7f6e253601e6b3">ReplaceSubstring(src, pos, regionLength)</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Chooses checking or non-checking implementation. Defaults to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The <b>String</b> to insert. </td></tr>
    <tr><td class="paramname">pos</td><td>The position to insert <code>src</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="abf74925ba2fc5109db3c8be01c962e4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; InsertChars </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Inserts the given character n-times at a given position. If the given position is out of range, nothing is inserted.</p>
<p>The non-checking version does not check the position. However the default value which is appending at the end) is still verfied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character to insert <code>qty</code> times. </td></tr>
    <tr><td class="paramname">qty</td><td>The quantity of characters to insert. </td></tr>
    <tr><td class="paramname">pos</td><td>The index in this object where <code>c</code> is inserted <code>qty</code> times. Defaults to <b><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a></b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a949cac7084e10566b50a195b60bff591"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; NewLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Appends platform specific new line character(s) by appending literal string <a class="el" href="namespaceaworx.html#aca82326cfe712c18f9adb9f560a28553">NewLine</a>. </p><dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="ac243bc3f2d0f61eb45d49f488ddbcb63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4dbe5fba1e5c5ed69d12d57b3eb49ef7">Apply</a> to append string-type objects and to generically 'apply' objects of arbitrary type. This template method wraps an invocation of <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4dbe5fba1e5c5ed69d12d57b3eb49ef7">Apply</a>, ignoring its return value and instead returns <code>*this</code> to allow concatenated calls. This operator is equivalent to invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a635ad749475cecd00e3ec3603327d78c">_&lt;true&gt;(const T&amp;)</a>. </p><dl class="section see"><dt>See also</dt><dd>Method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4dbe5fba1e5c5ed69d12d57b3eb49ef7">Apply</a> for more information.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of parameter <code>source</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The object of type T to append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5e4f0275095724f12cb477527d2f33b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> The <em>default</em> C++ assign operator (ClassT &amp; operator=(const ClassT &amp;) ). Copies the contents of the given object <code>copy</code>. </p><dl class="section note"><dt>Note</dt><dd>There is no move assignment operator defined. In general, it might be advisable to use a combination of <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ae4d5af65574550e39830297e4496f81b">Clear</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a635ad749475cecd00e3ec3603327d78c">_(const T&amp;)</a> instead of using assignments. See <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#alib_namespace_strings_astring_move">Move Constructor and Move Assignment</a> for an explanation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>The object to copy the contents from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cfb898b4e0d87d08b6c0b115b690239"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Clears this object and uses <em>Apply</em> to append objects of arbitrary type. See <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4dbe5fba1e5c5ed69d12d57b3eb49ef7">Apply</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>In general, it might be advisable to use a combination of <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ae4d5af65574550e39830297e4496f81b">Clear</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a635ad749475cecd00e3ec3603327d78c">_(const T&amp;)</a> instead of using assignments. See <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#alib_namespace_strings_astring_move">Move Constructor and Move Assignment</a> for an explanation.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is added to the method name, checks are omitted as documented. </td></tr>
    <tr><td class="paramname">T</td><td>The type of parameter <code>source</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The source of type T to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a8068d1bbfd60c6cb178bdc0b2084ab9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Provides read/write access to single characters. Overwrites <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a0b3b9871d2fc6522c1f2aedf67b8b1c2">String::operator[]</a> returning a reference to a char which allows assignments of values when using an object with this operator as lvalue.</p>
<dl class="section attention"><dt>Attention</dt><dd>Unlike other operator methods in the family of string classes of ALib, which are doing parameter checks (in this case a range check), this operator does <em>not</em> do a check! The rationale is that, no reference to a character can be given if <code>op</code> is out of range.<br />
 This way, this method is equivalent to methods <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ab2cf143ab3c019c18b6ada0ea87a6370">SetCharAt&lt;false&gt;</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aaf9706f704337ae92062d7b68c8f33ea">CharAt&lt;false&gt;</a>. For safe access to characters in the buffer use <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ab2cf143ab3c019c18b6ada0ea87a6370">SetCharAt</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aaf9706f704337ae92062d7b68c8f33ea">CharAt</a> (with template parameter <code>TCheck</code> being <code>true</code>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The index of the character within this objects' buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the character contained (or, if lvalue the one to set). </dd></dl>

</div>
</div>
<a class="anchor" id="ab7e984ef7acfdeb4d63b572c6f2dca70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; ReplaceRegion </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Replaces a region in the string with the given character. The region is adjusted to fit into the current length. In other words, the length of this instances remains the same.</p>
<dl class="section note"><dt>Note</dt><dd>To replace a region with a single character (by shrinking the region to this character) use <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a17e140dfb247b527da7f6e253601e6b3">ReplaceSubstring( String(c), regionStart, regionLength)</a>.</dd></dl>
<p>The non-checking version does not adjust the region.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Chooses checking or non-checking implementation. Defaults to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionStart</td><td>The start of the region </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region </td></tr>
    <tr><td class="paramname">c</td><td>The character to set in the region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a17e140dfb247b527da7f6e253601e6b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; ReplaceSubstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Replaces a region in this object by a given string. If the region does not fit to this object, then nothing is done.</p>
<p>The non-checking version does not adjust the region.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Chooses checking or non-checking implementation. Defaults to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The replacement string. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start of the region. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The length of the region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a5bf64f32d0163186492461fb2c3e4300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SearchAndReplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxReplacements</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a>&#160;</td>
          <td class="paramname"><em>sensitivity</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Replaces one or more occurrences of a terminatable string ( <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a>) by a replacement string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The terminatable string to be replaced. </td></tr>
    <tr><td class="paramname">replacement</td><td>The replacement string (does not need to be zero terminatable). </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index where the search starts. Optional and defaults 0. </td></tr>
    <tr><td class="paramname">maxReplacements</td><td>The maximum number of replacements to perform. Optional and defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>. </td></tr>
    <tr><td class="paramname">sensitivity</td><td>Case sensitivity of the comparison. Optional and defaults to Case::Sensitive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of replacements that where performed. </dd></dl>

</div>
</div>
<a class="anchor" id="ada2d3b01c31c088c8e04676c6e50e78b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; SearchAndReplaceAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a>&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxReplacements</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a>&#160;</td>
          <td class="paramname"><em>sensitivity</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Replaces one or more occurrences of a terminatable string ( <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a>) by a replacement string. </p><dl class="section note"><dt>Note</dt><dd>The difference to <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a5bf64f32d0163186492461fb2c3e4300">SearchAndReplace</a> is that this method returns <b>*this</b> to allow concatenated calls.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The terminatable string to be replaced. </td></tr>
    <tr><td class="paramname">replacement</td><td>The replacement string (does not need to be zero terminatable). </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index where the search starts. Optional and defaults 0. </td></tr>
    <tr><td class="paramname">maxReplacements</td><td>The maximum number of replacements to perform. Optional and defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>. </td></tr>
    <tr><td class="paramname">sensitivity</td><td>Case sensitivity of the comparison. Optional and defaults to Case::Sensitive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bdd4581fc80e9bba8ceb46e030c75ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Resizes the internal buffer to meet exactly the given size.</p>
<p>The following rules apply:</p><ul>
<li>The string represented by this instance is copied to the new buffer. If this is larger than the new buffer size, the string is cut at the end to fit.</li>
<li>If the desired new size is 0, then the currently allocated buffer will be released and the objects state is <em>nulled</em>.</li>
<li>If the current buffers' life-cycle is managed externally (e.g. was set using <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0c8474e9c19a45b535f1b460aac3847b">SetBuffer(char*,int,int, enums::Responsibility)</a> with parameter <code>responsibility</code> being <code>Responsibility::KeepWithSender</code>), this method will replace the buffer by a new one, even if the new requested size is the same as the external buffers' size. In other words, the only case when this method does not replace the current buffer is when the current buffers' life-cycle is (already) internally managed and it has the same size than what is requested.</li>
<li>In the C++ version of ALib, the <code>true</code> allocation size is + 1 of what is given in parameter <code>newCapacity</code>. This is is to duly apply to a constraint given by parent <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a6d715743a3937ea101a8deda34d993dc">TString</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Any methods of this class that extend the length of the string represented, will invoke this method if the current buffer size is not sufficient. If a future string length of an <b>AString</b> is predictable, then it is advisable to allocate such size prior to start appending the data to avoid recurring allocations (performance optimization). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If currently an external buffer is set (this means a buffer whose life-cycle is not controlled by this instance), an one-time warning per instance is issued. To enable/disable this warning use macro<ul>
<li><a class="el" href="group__GrpALibMacros.html#gaea25b327ef9d2c90aad05f5bef07bd97">ALIB_WARN_ONCE_PER_INSTANCE_ENABLE(theInstanceInQuestion, ReplaceExternalBuffer)</a> or</li>
<li><a class="el" href="group__GrpALibMacros.html#ga30e363647f8ea56f0af8e834768548bc">ALIB_WARN_ONCE_PER_INSTANCE_DISABLE(theInstanceInQuestion, ReplaceExternalBuffer)</a>.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newCapacity</td><td>The new capacity of the internal buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c8474e9c19a45b535f1b460aac3847b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetBuffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>extBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extLength</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab5305b978950ba3946cf79a4bccbf7af">enums::Responsibility</a>&#160;</td>
          <td class="paramname"><em>responsibility</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab5305b978950ba3946cf79a4bccbf7afa2540530a938da82bfe62957f4aff599b">enums::Responsibility::KeepWithSender</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> This methods replaces the current buffer with the one provided.</p>
<p>The following rules apply:</p><ul>
<li>If a nullptr is provided still, the current buffer is released.</li>
<li>If provided buffer is not nullptr, its size provided with parameter <code>extBufferSize</code> has to be at least 1 for providing the space for a termination character.</li>
<li>After the operation, <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ad07c7e740f0be42afb0c1eda25361864">Capacity</a> will report <code>extBufferSize</code> <code>-1</code>.</li>
<li>Optional parameter <code>responsibility</code> can be used to pass the responsibility for the deletion of the buffer to this object.</li>
<li>The length of the content provided with parameter <code>extLength</code> must not exceed the value of parameter <code>extBufferSize</code> <code>-1</code>.</li>
<li>In no event any data of an existing buffer is copied into the new one. The rationale here is that in most use cases, this is not needed. Should this be desired, then the contents has to be copied manually, e.g. by invoking <code>strcpy( extBuffer, target.ToCString() )</code> prior to invoking this method.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extBuffer</td><td>The external buffer to use. </td></tr>
    <tr><td class="paramname">extBufferSize</td><td>The size of the given buffer. </td></tr>
    <tr><td class="paramname">extLength</td><td>The length of any content located in the given buffer that should be used. Has to be smaller or equal to extBufferSize -1 to preserve space for a trailing '\0'. </td></tr>
    <tr><td class="paramname">responsibility</td><td>If <code>Responsibility::Transfer</code>, the given buffer will be deleted by this object when a new buffer is set or it is deleted itself. Defaults to <code>Responsibility::KeepWithSender</code> which denotes that the life-cycle of the given external buffer is managed elsewhere. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2cf143ab3c019c18b6ada0ea87a6370"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetCharAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Sets the character at the given index. A range check is performed. If this fails, nothing is done.</p>
<dl class="section note"><dt>Note</dt><dd>The C++ language would allow to declare this method const, as it does not manipulate the data of the class itself but a character in the buffer pointer.<br />
 In exclamation cases, to manipulate the contents of <em>const AString</em>, use method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a39184b93936d495a501cbea28e12495e">VBuffer()</a> like in the following sample: <div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html#a135d849a18470b04a1f4cf761de3a17c">AString</a> myAString( <span class="stringliteral">&quot;Hello&quot;</span> );</div><div class="line"></div><div class="line">    <span class="comment">// this would not compile because ALib volunteers to not declare AString::SetCharAt()</span></div><div class="line">    <span class="comment">// to be a const method.</span></div><div class="line">    <span class="comment">//myAString.SetCharAt( 1, &#39;e&#39; );</span></div><div class="line"></div><div class="line">    myAString.VBuffer()[1]= <span class="charliteral">&#39;e&#39;</span>;</div></div><!-- fragment --> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Performs a range check on the given index and a check for illegal setting of termination character '\0' anywhere else but at idx==length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the character to write. </td></tr>
    <tr><td class="paramname">c</td><td>The character to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c14574ea5ef859e15b51f288c40f5da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Sets a new length for this string.</p>
<p>The <em>checking version</em> (<code>TCheck=<code>true</code>)</code> of this method must be used to shorten the string only. If the new length is requested to be higher than the current length, a one time warning is issued. The warning occurs only once for the first occurrence of an invocation of this method with such wrong parameter. To enable/disable this warning use macros</p><ul>
<li><a class="el" href="group__GrpALibMacros.html#ga0627077cd7f96033d848dc29f2875a5d">ALIB_WARN_ONCE_PER_TYPE_ENABLE(String, SetLengthLonger)</a> or</li>
<li><a class="el" href="group__GrpALibMacros.html#ga5558b6404fddb317efd26bf8a9665f40">ALIB_WARN_ONCE_PER_TYPE_DISABLE(String, SetLengthLonger)</a>.</li>
</ul>
<p>The <em>non-checking</em> version may be used to increase the length. Here, an assertion is only raised, when the length is negative or greater than the current <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ad07c7e740f0be42afb0c1eda25361864">Capacity</a>. Therefore, the non-checking version <em>has to</em> be used when external change an <code>AStrings'</code> size. E.g. specializations of function <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> regularly do that.</p>
<p>Furthermore, if <a class="el" href="group__GrpALibCodeSelectorSymbols.html#gae0e4a87e11482df5ecd72f6a2a648f05">ALIB_DEBUG_STRINGS</a> is defined, the non-checking version applies <a class="el" href="group__GrpALibStringsMacros.html#gacf96023d903e78f3b5d784a799041667">ALIB_STRING_DBG_UNTERMINATE</a> to this object, after the new length was set. Only the, a <a class="el" href="group__GrpALibStringsMacros.html#gae7492253da37c76b118d446494f1f632">ALIB_STRING_DBG_CHK</a> is executed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is added to the method name, no parameter checks are performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newLength</td><td>The new length of the <b>AString</b>. Must be between 0 and the current length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a787c9800970197d19a5452ac456d64f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0bdd4581fc80e9bba8ceb46e030c75ac">SetBuffer(0)</a>. </p><dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d1a7077beb29dd16e84c469e5e01f12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; ToLower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Converts all or a region of characters in the Buffer to lower case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionStart</td><td>Start of the region to be converted. Defaults to 0 </td></tr>
    <tr><td class="paramname">regionLength</td><td>Length of the region to be converted. Defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a76441306378ccdc4d560ea2ea417a89b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; ToUpper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Converts all or a region of characters in the Buffer to upper case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regionStart</td><td>Start of the region to be converted. Defaults to 0 </td></tr>
    <tr><td class="paramname">regionLength</td><td>Length of the region to be converted. Defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a5902ed6d5d02134b98ac686172f34dc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp; Trim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;&#160;</td>
          <td class="paramname"><em>trimChars</em> = <code><a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">DefaultWhitespaces</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> All characters defined in given set are removed at the beginning and at the end of this string.</p>
<dl class="section see"><dt>See also</dt><dd>Method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a63f255e8769be77d70b70407e388746b">TrimAt</a> to remove whitespaces at arbitrary places in the string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trimChars</td><td>Pointer to a zero terminated set of characters to be omitted. Defaults to <a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">DefaultWhitespaces</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a63f255e8769be77d70b70407e388746b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp; TrimAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;&#160;</td>
          <td class="paramname"><em>trimChars</em> = <code><a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">DefaultWhitespaces</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> All characters defined in given set at, left of and right of the given index are removed from the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to perform the trim operation at. Has to be between zero and <em>length -1</em>. </td></tr>
    <tr><td class="paramname">trimChars</td><td>Pointer to a zero terminated set of characters to be omitted. Defaults to <a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">DefaultWhitespaces</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="abfb73aa66ba9e9ebedecd9de6ee6ed9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; TrimEnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;&#160;</td>
          <td class="paramname"><em>trimChars</em> = <code><a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">DefaultWhitespaces</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> All characters defined in given set are removed at the end of this string.</p>
<dl class="section see"><dt>See also</dt><dd>Method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a63f255e8769be77d70b70407e388746b">TrimAt</a> to remove whitespaces at arbitrary places in the string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trimChars</td><td>Pointer to a zero terminated set of characters to be omitted. Defaults to <a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">DefaultWhitespaces</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a4aacb9ead9be86623c688267f76760cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; TrimStart </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;&#160;</td>
          <td class="paramname"><em>trimChars</em> = <code><a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">DefaultWhitespaces</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> All characters defined in given set are removed at the beginning of this string.</p>
<dl class="section see"><dt>See also</dt><dd>Method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a63f255e8769be77d70b70407e388746b">TrimAt</a> to remove whitespaces at arbitrary places in the string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trimChars</td><td>Pointer to a zero terminated set of characters to be omitted. Defaults to <a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">DefaultWhitespaces</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> to allow concatenated calls. </dd></dl>

</div>
</div>
<a class="anchor" id="a39184b93936d495a501cbea28e12495e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* VBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> The internal buffer character array provided as non constant char pointer. </p><dl class="section see"><dt>See also</dt><dd>Chapter <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#alib_namespace_strings_astring_write_access">Write Access to the Buffer</a> of the reference documentation of this class.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The internal buffer array. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="adbe66a087ac3fd4a5b0566f64ca2d12b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current size of the buffer excluding the trailing '\0'. If no buffer is allocated, this is is 0. If an external Buffer is used and if this buffer is not under our control (we must not delete it), then the size of such buffer is stored as a negative value. </p>

</div>
</div>
<a class="anchor" id="aa155a96ba168342ab2ae8067d96e373e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool debugBufferWithMagicBytePadding =false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to check if previous grow request was exactly what is now the length.<br />
 This is available only if <a class="el" href="group__GrpALibCodeSelectorSymbols.html#gae0e4a87e11482df5ecd72f6a2a648f05">ALIB_DEBUG_STRINGS</a> is set. </p>

</div>
</div>
<a class="anchor" id="a7ebc042256408173ee3c3904906a0e47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int debugLastAllocRequest =0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to check if previous grow request was exactly what is now the length.<br />
 This is available only if <a class="el" href="group__GrpALibCodeSelectorSymbols.html#gae0e4a87e11482df5ecd72f6a2a648f05">ALIB_DEBUG_STRINGS</a> is set. </p>

</div>
</div>
<a class="anchor" id="ae6e756e6f5ccc142f9fc3ceb6ba18cf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ReplaceExternalBuffer = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code>true</code>, an one-time warning (using <a class="el" href="classaworx_1_1lib_1_1Report.html#a3977916df8d86dcb2c61e95d9b457b38">Report::DoReport</a>) will be issued when an external buffer, whose life-cycle is not controlled by this instance gets replaced by a new allocation. This normally shall not happen, but still might be wanted or at least taken into account.</p>
<p>E.g. for <a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">PreallocatedString</a> objects, that sometimes may grow more than average, this warning may be disabled after creation of an instance.</p>
<p>The warning will be issued only once per instance unless the warning gets re-enabled</p>
<dl class="section note"><dt>Note</dt><dd>This field can not be accessed directly (For technical reasons, it is differently declared than stated here in the source documentation).<br />
 To change the field use macros<ul>
<li><a class="el" href="group__GrpALibMacros.html#gaea25b327ef9d2c90aad05f5bef07bd97">ALIB_WARN_ONCE_PER_INSTANCE_ENABLE(myinstance, ReplaceExternalBuffer)</a> and</li>
<li><a class="el" href="group__GrpALibMacros.html#ga30e363647f8ea56f0af8e834768548bc">ALIB_WARN_ONCE_PER_INSTANCE_DISABLE(myinstance, ReplaceExternalBuffer)</a></li>
</ul>
</dd></dl>
<p>where <code>myinstance</code> is a reference to the object in question). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="astring_8hpp_source.html">astring.hpp</a></li>
<li>astring.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 20 2016 10:57:53 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
