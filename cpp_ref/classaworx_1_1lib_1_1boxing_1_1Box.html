<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALox: Box Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1712 R. 1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--ALox Main Menu-->
<div style="background: #2f3a48; " >
<table  class="aworx-menutable"  >
 <tbody>
 <tr style="height: 36px;">
  <td> <a class="aworx-menu"    href="../index.html"                                   >Home</a>                     </td>
  <td> <a class="aworx-menu_hl" href="../cpp_ref/alox_cpp_mainpage.html"                >ALox for C++</a>             </td>
  <td> <a class="aworx-menu"    href="../cs_ref/alox_cs_mainpage.html"                  >ALox for C#</a>              </td>
  <td> <a class="aworx-menu"    href="../java_ref/alox_java_mainpage.html"              >ALox for Java</a>            </td>
  <td> <a class="aworx-menu"    href="https://github.com/AlexWorx/ALox-Logging-Library">Download</a></td>
 </tr>
 </tbody>
</table>
</div>
<!--end ALox Main Menu-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">boxing</a></li><li class="navelem"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Methods</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#pro-attribs">Protected Fields</a> &#124;
<a href="classaworx_1_1lib_1_1boxing_1_1Box-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Box Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="box_8hpp_source.html">box.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Box:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1boxing_1_1Box__inherit__graph.svg" width="192" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Box:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1boxing_1_1Box__coll__graph.svg" width="163" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><hr/>
<p> This is the central class of <b>ALib Boxing</b>. By using template meta programming, an object of this class can be created by passing just any C++ type to the constructor. The passed value will be "boxed" within the instance of this class.</p>
<p>Then, the instances of this class support type checking, value extraction ("unboxing") and the invocation of "virtual methods". All features are customizable in detail per "boxable type".</p>
<p>A thorough introduction to and documentation of all aspects of <b>ALib Boxing</b> is given with namespace documentation <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">aworx::lib::boxing</a>. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr class="memitem:ab35f0568f1775ad9ae0b7c63c47f0362"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ab35f0568f1775ad9ae0b7c63c47f0362">Box</a> ()=default</td></tr>
<tr class="separator:ab35f0568f1775ad9ae0b7c63c47f0362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac2ce6e5fab2e2f088846cee710de4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a0ac2ce6e5fab2e2f088846cee710de4d">Box</a> (const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;)=default</td></tr>
<tr class="separator:a0ac2ce6e5fab2e2f088846cee710de4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d562f23daeb465002adabc9a03cee7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ab9d562f23daeb465002adabc9a03cee7">Box</a> (<a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ab9d562f23daeb465002adabc9a03cee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e25eb867bc754d3dbe587c596fc328"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a11e25eb867bc754d3dbe587c596fc328">Box</a> (void *src)</td></tr>
<tr class="separator:a11e25eb867bc754d3dbe587c596fc328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90d52a5e3f9084ab290a399c4ab0f2c"><td class="memTemplParams" colspan="2">template&lt;typename TEnum , typename TEnableIf  = typename std::enable_if&lt;std::is_enum&lt;TEnum&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ac90d52a5e3f9084ab290a399c4ab0f2c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ac90d52a5e3f9084ab290a399c4ab0f2c">Box</a> (TEnum src)</td></tr>
<tr class="separator:ac90d52a5e3f9084ab290a399c4ab0f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438cf18a7c4cc8b5cab3ca9aea51bbee"><td class="memTemplParams" colspan="2">template&lt;typename TBoxable , typename TEnableIf  = typename std::enable_if&lt; !std::is_enum&lt;TBoxable&gt;::value  &gt;::type&gt; </td></tr>
<tr class="memitem:a438cf18a7c4cc8b5cab3ca9aea51bbee"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a438cf18a7c4cc8b5cab3ca9aea51bbee">Box</a> (const TBoxable &amp;src)</td></tr>
<tr class="separator:a438cf18a7c4cc8b5cab3ca9aea51bbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3c77489682d92eebd69ad2a5c0824e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a0a3c77489682d92eebd69ad2a5c0824e">ArrayElementSize</a> () const</td></tr>
<tr class="separator:a0a3c77489682d92eebd69ad2a5c0824e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b7ce5446ed5ad892af64d02eed6efc"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#aa1b7ce5446ed5ad892af64d02eed6efc">DbgGetReferenceType</a> () const</td></tr>
<tr class="separator:aa1b7ce5446ed5ad892af64d02eed6efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff845e5a76eb0fab90db26cda997c70b"><td class="memTemplParams" colspan="2">template&lt;typename TInterface &gt; </td></tr>
<tr class="memitem:aff845e5a76eb0fab90db26cda997c70b"><td class="memTemplItemLeft" align="right" valign="top">TInterface *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#aff845e5a76eb0fab90db26cda997c70b">GetInterface</a> () const</td></tr>
<tr class="separator:aff845e5a76eb0fab90db26cda997c70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5be4d1c296e19fc0097e98d8f949524"><td class="memTemplParams" colspan="2">template&lt;int TIsArray = -1&gt; </td></tr>
<tr class="memitem:aa5be4d1c296e19fc0097e98d8f949524"><td class="memTemplItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#aa5be4d1c296e19fc0097e98d8f949524">GetTypeInfo</a> () const</td></tr>
<tr class="separator:aa5be4d1c296e19fc0097e98d8f949524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5"><td class="memTemplParams" colspan="2">template&lt;typename TInterface &gt; </td></tr>
<tr class="memitem:af00a56f400aaf960349d00e50d8effd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#af00a56f400aaf960349d00e50d8effd5">HasInterface</a> () const</td></tr>
<tr class="separator:af00a56f400aaf960349d00e50d8effd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae828c5649908bb8346f1187bb4187936"><td class="memTemplParams" colspan="2">template&lt;typename TInterface , typename TReturn  = void, typename... Args&gt; </td></tr>
<tr class="memitem:ae828c5649908bb8346f1187bb4187936"><td class="memTemplItemLeft" align="right" valign="top">TReturn&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ae828c5649908bb8346f1187bb4187936">Invoke</a> (Args &amp;&amp;... args) const</td></tr>
<tr class="separator:ae828c5649908bb8346f1187bb4187936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebef9889d05411b93c68c9a7d9d773cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#aebef9889d05411b93c68c9a7d9d773cf">IsArray</a> () const</td></tr>
<tr class="separator:aebef9889d05411b93c68c9a7d9d773cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34718fb8f3109b7ee870650ae8dedbf"><td class="memTemplParams" colspan="2">template&lt;typename TElementType &gt; </td></tr>
<tr class="memitem:ad34718fb8f3109b7ee870650ae8dedbf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ad34718fb8f3109b7ee870650ae8dedbf">IsArrayOf</a> () const</td></tr>
<tr class="separator:ad34718fb8f3109b7ee870650ae8dedbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1975261f9100a453259d7df75ad4080d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a1975261f9100a453259d7df75ad4080d">IsNotNull</a> () const</td></tr>
<tr class="separator:a1975261f9100a453259d7df75ad4080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d637a0dec45d546495c1660c9f6047"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ac4d637a0dec45d546495c1660c9f6047">IsNull</a> () const</td></tr>
<tr class="separator:ac4d637a0dec45d546495c1660c9f6047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7d7c493c9172bcebf20d5324a396b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a4c7d7c493c9172bcebf20d5324a396b3">IsSameType</a> (const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;other) const</td></tr>
<tr class="separator:a4c7d7c493c9172bcebf20d5324a396b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfff1d08a62820fcf3a5f82922a3bba"><td class="memTemplParams" colspan="2">template&lt;typename TBoxable &gt; </td></tr>
<tr class="memitem:a6cfff1d08a62820fcf3a5f82922a3bba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a> () const</td></tr>
<tr class="separator:a6cfff1d08a62820fcf3a5f82922a3bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7634ca57b5937c59db2299e0baeabb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a2a7634ca57b5937c59db2299e0baeabb">IsVoidPointer</a> () const</td></tr>
<tr class="separator:a2a7634ca57b5937c59db2299e0baeabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a515bdd031a8d3b713bb05edcf126c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a> () const</td></tr>
<tr class="separator:a78a515bdd031a8d3b713bb05edcf126c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab207b1ddd2f1a9520136b9af42f8e91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#aab207b1ddd2f1a9520136b9af42f8e91">operator!=</a> (const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;rhs) const</td></tr>
<tr class="separator:aab207b1ddd2f1a9520136b9af42f8e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b62da43ec37b35ae6477f90464c4dbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a4b62da43ec37b35ae6477f90464c4dbd">operator&lt;</a> (const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;rhs) const</td></tr>
<tr class="separator:a4b62da43ec37b35ae6477f90464c4dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35267b54746c4e9606e66623cc95a244"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a35267b54746c4e9606e66623cc95a244">operator&lt;=</a> (const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;rhs) const</td></tr>
<tr class="separator:a35267b54746c4e9606e66623cc95a244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373b8473fbb454f0721ce5c6fe369b1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a373b8473fbb454f0721ce5c6fe369b1d">operator=</a> (const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;)=default</td></tr>
<tr class="separator:a373b8473fbb454f0721ce5c6fe369b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69c7ac656903a021aefd1de808b64ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#aa69c7ac656903a021aefd1de808b64ed">operator=</a> (<a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&amp;)=default</td></tr>
<tr class="separator:aa69c7ac656903a021aefd1de808b64ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade892ae7540dc827ee1f5928c4fda5dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ade892ae7540dc827ee1f5928c4fda5dc">operator==</a> (<a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> const &amp;rhs) const</td></tr>
<tr class="separator:ade892ae7540dc827ee1f5928c4fda5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293df796606768d77881b10ae804440e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a293df796606768d77881b10ae804440e">operator&gt;</a> (const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;rhs) const</td></tr>
<tr class="separator:a293df796606768d77881b10ae804440e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95620818d9f7f599fdbedf9621caa62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#af95620818d9f7f599fdbedf9621caa62">operator&gt;=</a> (const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;rhs) const</td></tr>
<tr class="separator:af95620818d9f7f599fdbedf9621caa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e697abb81d1cc6d8669a75e48ec0d88"><td class="memTemplParams" colspan="2">template&lt;typename TBoxable &gt; </td></tr>
<tr class="memitem:a7e697abb81d1cc6d8669a75e48ec0d88"><td class="memTemplItemLeft" align="right" valign="top">TBoxable&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a> () const</td></tr>
<tr class="separator:a7e697abb81d1cc6d8669a75e48ec0d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974225964bd92b7338e69557376719e1"><td class="memTemplParams" colspan="2">template&lt;typename TElementType &gt; </td></tr>
<tr class="memitem:a974225964bd92b7338e69557376719e1"><td class="memTemplItemLeft" align="right" valign="top">TElementType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a974225964bd92b7338e69557376719e1">UnboxElement</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> idx) const</td></tr>
<tr class="separator:a974225964bd92b7338e69557376719e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f83d910b885d130193aaa77d472f29c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#aa3e009a14ed9d13b3f9cfac1ac29bee5">boxvalue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7f83d910b885d130193aaa77d472f29c">UnboxRaw</a> () const</td></tr>
<tr class="separator:a7f83d910b885d130193aaa77d472f29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a34465e3dfe6a07d5e53b7c9f7d8d9b79"><td class="memTemplParams" colspan="2">template&lt;typename TBoxable &gt; </td></tr>
<tr class="memitem:a34465e3dfe6a07d5e53b7c9f7d8d9b79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a34465e3dfe6a07d5e53b7c9f7d8d9b79">DefaultBoxing</a> (<a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;box, const TBoxable &amp;value)</td></tr>
<tr class="separator:a34465e3dfe6a07d5e53b7c9f7d8d9b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b628b92185f310ea42b146c15b9ce1"><td class="memTemplParams" colspan="2">template&lt;typename TBoxable &gt; </td></tr>
<tr class="memitem:a28b628b92185f310ea42b146c15b9ce1"><td class="memTemplItemLeft" align="right" valign="top">TBoxable&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a28b628b92185f310ea42b146c15b9ce1">DefaultUnboxing</a> (const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr class="separator:a28b628b92185f310ea42b146c15b9ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acd27547301a0bb7c2d2fbdbd709df3"><td class="memTemplParams" colspan="2">template&lt;typename TBoxable &gt; </td></tr>
<tr class="memitem:a0acd27547301a0bb7c2d2fbdbd709df3"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a0acd27547301a0bb7c2d2fbdbd709df3">T_Boxing</a></td></tr>
<tr class="separator:a0acd27547301a0bb7c2d2fbdbd709df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Fields</h2></td></tr>
<tr class="memitem:ac9663bfd726a1b8c391b21f6e836c66e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html">Boxer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ac9663bfd726a1b8c391b21f6e836c66e">boxer</a></td></tr>
<tr class="separator:ac9663bfd726a1b8c391b21f6e836c66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae873c14aa392d71bf9d5b0c4a28f4af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html">BoxData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ae873c14aa392d71bf9d5b0c4a28f4af5">data</a></td></tr>
<tr class="separator:ae873c14aa392d71bf9d5b0c4a28f4af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab35f0568f1775ad9ae0b7c63c47f0362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35f0568f1775ad9ae0b7c63c47f0362">&#9670;&nbsp;</a></span>Box() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Trivial default constructor. Creates an uninitialized boxed which must not be used prior to assignment of values. </p>

</div>
</div>
<a id="a0ac2ce6e5fab2e2f088846cee710de4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac2ce6e5fab2e2f088846cee710de4d">&#9670;&nbsp;</a></span>Box() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Trivial default constructor. </p>

</div>
</div>
<a id="ab9d562f23daeb465002adabc9a03cee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d562f23daeb465002adabc9a03cee7">&#9670;&nbsp;</a></span>Box() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Trivial default move constructor. </p>

</div>
</div>
<a id="a11e25eb867bc754d3dbe587c596fc328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e25eb867bc754d3dbe587c596fc328">&#9670;&nbsp;</a></span>Box() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructor fetching type <code>void*</code> values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The <code>void*</code> value to be boxed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac90d52a5e3f9084ab290a399c4ab0f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90d52a5e3f9084ab290a399c4ab0f2c">&#9670;&nbsp;</a></span>Box() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructor for enum elements.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>Enum type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Enum element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a438cf18a7c4cc8b5cab3ca9aea51bbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438cf18a7c4cc8b5cab3ca9aea51bbee">&#9670;&nbsp;</a></span>Box() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> </td>
          <td>(</td>
          <td class="paramtype">const TBoxable &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructor using template meta programming to fetch any type of C++ value.</p>
<p>Types derived from class <b>Box</b> itself are boxed by coping the internal values of the box. This means, that boxing objects of derived types is similar to "downcasting" the object to class <b>Box</b>..</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TBoxable</td><td>Any C++ type to be boxed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The src of (template) type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0a3c77489682d92eebd69ad2a5c0824e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3c77489682d92eebd69ad2a5c0824e">&#9670;&nbsp;</a></span>ArrayElementSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ArrayElementSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the size in bytes of on element of the stored array. This method is applicable only for array types. For non-array types, <code>0</code> is returned and in debug compilation an <b>ALib</b> assertion is raised.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of elements in the array. </dd></dl>

</div>
</div>
<a id="aa1b7ce5446ed5ad892af64d02eed6efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b7ce5446ed5ad892af64d02eed6efc">&#9670;&nbsp;</a></span>DbgGetReferenceType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; DbgGetReferenceType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <code>std::type_info</code> that can be used to query information on the boxer of this instance. Available only in debug compilations. See also static methods <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxing.html#a2cdb9dc37645e581ecca4a45376f287a">Boxing::DbgGetInterfaces</a>, <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxing.html#a928b4f70113d24da32ea6895b79ab2e3">Boxing::DbgGetKnownBoxers</a>, <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxing.html#ad0e6afc9d06b2ddd35d5fc8f70bf3283">Boxing::DbgGetKnownInterfaces</a>, <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxing.html#ae3eb64b459dc5813723d650ec1da43a6">Boxing::DbgGetDefaultInterfaces</a> and <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxing.html#aa4c2f7712ed86c42a710b567a8570934">Boxing::DbgGetKnownInterfaceImpl</a>,</p>
<dl class="section return"><dt>Returns</dt><dd>Type information of the boxer of this instance. </dd></dl>

</div>
</div>
<a id="aff845e5a76eb0fab90db26cda997c70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff845e5a76eb0fab90db26cda997c70b">&#9670;&nbsp;</a></span>GetInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TInterface* GetInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Searches and receives the singleton instance of type <code>TInterface</code> (which needs to be of a type derived from class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a>) defined for boxed types represented by this object.</p>
<dl class="section note"><dt>Note</dt><dd>Instead of using this method, it is advised to use method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ae828c5649908bb8346f1187bb4187936">Invoke</a> instead. The use of this method and subsequent "manual" invocation of the method named <b>"Invoke"</b> on of the returned interface instance is useful, when multiple invocations of the interface method are to be done on the same box, like in the following sample:</dd></dl>
<p>MyInterface* mIF= aBox.GetInterface&lt;MyInterface&gt;(); if( mIF != nullptr ) for( int i= 0; i&lt; 100; ++i ) mIF-&gt;Invoke( aBox, i );</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInterface</td><td>The interface type to receive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interface singleton defined. <code>nullptr</code> in case that no interface is available. </dd></dl>

</div>
</div>
<a id="aa5be4d1c296e19fc0097e98d8f949524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5be4d1c296e19fc0097e98d8f949524">&#9670;&nbsp;</a></span>GetTypeInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; GetTypeInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the <code>std::type_info</code> struct describing the boxed type. In case of arrays, the info of the element type is returned.</p>
<dl class="section attention"><dt>Attention</dt><dd>This method is provided for "completeness" and only be used in special situations.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The <code>std::type_info</code> of the boxed value. In case of arrays, the type info of the array elements. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIsArray</td><td>May be used to omit internal check for box being an array type or not:<ul>
<li>If it is known to be <b>no</b> array type, set this to <code>0</code>,</li>
<li>if it is known to be an array type, set this to <code>1</code> and</li>
<li>if it is not known, leave it to the default value <code>-1</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af00a56f400aaf960349d00e50d8effd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00a56f400aaf960349d00e50d8effd5">&#9670;&nbsp;</a></span>HasInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HasInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code> if this box supports the interface <code>IF</code>. See class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a> for more information about how to enable custom types to support arbitrary method interfaces.</p>
<dl class="section note"><dt>Note</dt><dd>This method returns <code>false</code> even if a default interface used for any type is available! In this case, the interface might still be invoked or received using <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ae828c5649908bb8346f1187bb4187936">Invoke</a> or <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#aff845e5a76eb0fab90db26cda997c70b">GetInterface</a>. Consequently, this method can be used to detect (and avoid) default behaviour,</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInterface</td><td>The interface to receive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a dedicated interface of type <code>IF</code> exists for the boxed value. </dd></dl>

</div>
</div>
<a id="ae828c5649908bb8346f1187bb4187936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae828c5649908bb8346f1187bb4187936">&#9670;&nbsp;</a></span>Invoke()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TReturn Invoke </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Invokes method <b>%"Invoke"</b> of attached interface type <code>TInterface</code>.</p>
<p>If no interface is attached to this classes <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ac9663bfd726a1b8c391b21f6e836c66e">boxer</a>, then a default value of <code>TReturn</code> returned. Hence, type <code>TReturn</code> needs to be default constructable. In debug compilations, <a class="el" href="assert_8hpp.html#a91e7766134a7092e04ac33e257519d03">ALIB_ERROR</a> is used to handle non-existing interface errors.</p>
<p>In the case that a default instance of type <code>TInterface</code> is not set (see <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html#a6228b2d41176a6f8fd6489b150dfc5c3">Boxer::DefineDefaultInterface</a>), method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#af00a56f400aaf960349d00e50d8effd5">HasInterface</a> should be used to determine the existence of a specialized interface for the boxed type.</p>
<p>If return type of method <b>%"Invoke"</b> of interface class <code>TInterface</code> is other than <code>void</code>, then this return type needs to be explicitly specified as second template parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInterface</td><td>The interface type to receive. </td></tr>
    <tr><td class="paramname">TReturn</td><td>The return type of the invocation. Defaults to <code>void</code>. </td></tr>
    <tr><td class="paramname">Args</td><td>The types of the variadic arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The variadic arguments to interface methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing in case that <code>TReturn</code> is void, otherwise the result of the invocation, respectively <code>TReturn()</code> if requested interface type was not found for this <b>Box</b>. </dd></dl>

</div>
</div>
<a id="aebef9889d05411b93c68c9a7d9d773cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebef9889d05411b93c68c9a7d9d773cf">&#9670;&nbsp;</a></span>IsArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code> if this box represents an array of objects. In this case, method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a> (usually) will return the length of the array and <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a974225964bd92b7338e69557376719e1">UnboxElement</a> may be used to access elements of the array.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this box represents an array, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad34718fb8f3109b7ee870650ae8dedbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34718fb8f3109b7ee870650ae8dedbf">&#9670;&nbsp;</a></span>IsArrayOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsArrayOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code> if this objects represents an array and the element type equals template parameter <code>TElementType</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TElementType</td><td>The array element type to compare our element type with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this box represents an array of given type, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a1975261f9100a453259d7df75ad4080d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1975261f9100a453259d7df75ad4080d">&#9670;&nbsp;</a></span>IsNotNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsNotNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns negation of <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ac4d637a0dec45d546495c1660c9f6047">IsNull</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this box contains a value. </dd></dl>

</div>
</div>
<a id="ac4d637a0dec45d546495c1660c9f6047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d637a0dec45d546495c1660c9f6047">&#9670;&nbsp;</a></span>IsNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Checks if a box does not contain a value. This happens if constructed with <code>nullptr</code> or standard constructor. Internally, this method checks if the type of the stored value is <code>decltype(nullptr)</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this box does not contain a value. </dd></dl>

</div>
</div>
<a id="a4c7d7c493c9172bcebf20d5324a396b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7d7c493c9172bcebf20d5324a396b3">&#9670;&nbsp;</a></span>IsSameType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsSameType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns <code>true</code> if <code>other</code> and this object share the same boxed type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The box to compare our type with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this box has the same type like <code>other</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a6cfff1d08a62820fcf3a5f82922a3bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfff1d08a62820fcf3a5f82922a3bba">&#9670;&nbsp;</a></span>IsType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Checks if this box stores a value of type <code>TBoxable</code>. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if this box stores a value of type <code>TBoxable</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a2a7634ca57b5937c59db2299e0baeabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7634ca57b5937c59db2299e0baeabb">&#9670;&nbsp;</a></span>IsVoidPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsVoidPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Checks if this box stores a value of type <code>void*</code>. This special treatment of this type is necessary for technical reasons. To unbox a <code>void*</code> use <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7f83d910b885d130193aaa77d472f29c">UnboxRaw()</a>. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if this box stores a value of type <code>TBoxable</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a78a515bdd031a8d3b713bb05edcf126c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a515bdd031a8d3b713bb05edcf126c">&#9670;&nbsp;</a></span>Length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> Length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the length of the boxed object. The length is only applicable for array-type objects or for custom-type objects that use this field for arbitrary data (in which case the name of this method might be misleading).</p>
<dl class="section return"><dt>Returns</dt><dd>The length of the boxed object. </dd></dl>

</div>
</div>
<a id="aab207b1ddd2f1a9520136b9af42f8e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab207b1ddd2f1a9520136b9af42f8e91">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Comparison operator. Returns the negated result of <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ade892ae7540dc827ee1f5928c4fda5dc">operator==</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right hand side argument of the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object equals <code>lhs</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a4b62da43ec37b35ae6477f90464c4dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b62da43ec37b35ae6477f90464c4dbd">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Comparison operator. Returns the result of invocation of built-in boxing interface <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsLess.html">IIsLess</a>.</p>
<dl class="section see"><dt>See also</dt><dd>Sample code provided with documentation of boxing interface <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsLess.html">IIsLess</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right hand side argument of the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object is smaller than <code>lhs</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a35267b54746c4e9606e66623cc95a244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35267b54746c4e9606e66623cc95a244">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Comparison operator. Uses a combination of <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a4b62da43ec37b35ae6477f90464c4dbd">operator&lt;</a> and <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ade892ae7540dc827ee1f5928c4fda5dc">operator==</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right hand side argument of the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object is smaller than <code>lhs</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a373b8473fbb454f0721ce5c6fe369b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373b8473fbb454f0721ce5c6fe369b1d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Trivial default copy assign operator. </p><dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code>. </dd></dl>

</div>
</div>
<a id="aa69c7ac656903a021aefd1de808b64ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69c7ac656903a021aefd1de808b64ed">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Trivial default move assign operator. </p><dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code>. </dd></dl>

</div>
</div>
<a id="ade892ae7540dc827ee1f5928c4fda5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade892ae7540dc827ee1f5928c4fda5dc">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Comparison operator. Returns the result of invocation of built-in boxing interface <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IEquals.html">IEquals</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right hand side argument of the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object equals <code>lhs</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a293df796606768d77881b10ae804440e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293df796606768d77881b10ae804440e">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Comparison operator. Uses a combination of <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a4b62da43ec37b35ae6477f90464c4dbd">operator&lt;</a> and <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ade892ae7540dc827ee1f5928c4fda5dc">operator==</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right hand side argument of the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object is smaller than <code>lhs</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="af95620818d9f7f599fdbedf9621caa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95620818d9f7f599fdbedf9621caa62">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Comparison operator. Returns the negated result of of <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a4b62da43ec37b35ae6477f90464c4dbd">operator&lt;</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right hand side argument of the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object is smaller than <code>lhs</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a7e697abb81d1cc6d8669a75e48ec0d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e697abb81d1cc6d8669a75e48ec0d88">&#9670;&nbsp;</a></span>Unbox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TBoxable Unbox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the contents of this box converted to type <code>TBoxable</code>. By default this is done by invoking template method <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a28b628b92185f310ea42b146c15b9ce1">DefaultUnboxing</a> and might be customized by specializing struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">T_Boxing</a>.</p>
<p>In debug compilations, the actual type of this object is asserted to equal the templated return type.</p>
<p>For technical reasons, type <code>void*</code> can not be unboxed using this method. Use <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7f83d910b885d130193aaa77d472f29c">UnboxRaw()</a> instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TBoxable</td><td>The supported type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type ID (BoID) of this object </dd></dl>

</div>
</div>
<a id="a974225964bd92b7338e69557376719e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974225964bd92b7338e69557376719e1">&#9670;&nbsp;</a></span>UnboxElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TElementType&amp; UnboxElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns a reference to element <code>idx</code> of the boxed array.</p>
<dl class="section note"><dt>Note</dt><dd>In debug compilations, it is asserted that <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#aebef9889d05411b93c68c9a7d9d773cf">IsArray</a> returns <code>true</code>, the stored type is the same as requested and the provided <code>idx</code> is between <code>0</code> and the length of the array. In release compilations, no checks are performed!</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TElementType</td><td>The type of array elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the element to receive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the element at <code>idx</code>. </dd></dl>

</div>
</div>
<a id="a7f83d910b885d130193aaa77d472f29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f83d910b885d130193aaa77d472f29c">&#9670;&nbsp;</a></span>UnboxRaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#aa3e009a14ed9d13b3f9cfac1ac29bee5">boxvalue</a> UnboxRaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the raw value of the contents of this box. The value is declared as type <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#aa3e009a14ed9d13b3f9cfac1ac29bee5">boxvalue</a>, which usually is an alias to <code>uint64_t</code>.</p>
<p>In special situations, it might be useful to access the raw value and reinterpret its contents in any proper way.</p>
<dl class="section return"><dt>Returns</dt><dd>The raw contents of this object </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a34465e3dfe6a07d5e53b7c9f7d8d9b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34465e3dfe6a07d5e53b7c9f7d8d9b79">&#9670;&nbsp;</a></span>DefaultBoxing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DefaultBoxing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TBoxable &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>DefaultBoxing</b> shall access our data object directly.</p>
<p>This template function provides the default implementation used to store values in struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html">BoxData</a> when they are placed in a <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a>.</p>
<p>To customize boxing for a type, specialize struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">aworx::lib::boxing::T_Boxing</a> (with the help of macro <a class="el" href="group__GrpALibMacros.html#ga8c3e36e52f60303e7639ae48b146f0d6">ALIB_BOXING_SPECIALIZE</a>) with implementing methods <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#aefb0e0f2f3b71d443b0f590698407367">T_Boxing::HasCustomBoxing</a> to return <code>true</code> and having <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#adfa6c5fa593667614c5c9346247b4c1d">T_Boxing::Boxing</a> to do the boxing.</p>
<p>Fields <a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html#ae5cc2f97c501622beca5fdeffb7e755c">BoxData::Value</a> and <a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html#a5f38f944ed993ecb18fb7bbcee7c8f9e">BoxData::Length</a> have to be set, because for efficiency reasons, both are not initialized otherwise.</p>
<p>However, specializing this method for custom boxable types is seldom necessary, because complex custom types (structs and classes) usually get announced to the <b>ALib</b> boxing system as pointer types. The default implementation of this function, as well as corresponding function <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a28b628b92185f310ea42b146c15b9ce1">DefaultUnboxing</a>, are using <code>memcpy</code> for reading and writing the value. This is necessary to avoid de-referencing type-punned pointers which breaks the strict-aliasing rule when compiling the code with higher optimization levels.</p>
<p>Typically, a custom version of boxing is needed for fundamental types (value types), when a type is stored as a different type in a box. For example, custom string types might be stored as pointer to the array of characters and the string length. The advantage is, that this way all custom string classes are stored in the same way, and code that is processing a <b>Box</b> does not need to check for more than one type.</p>
<p>See <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">documentation of <b>%%ALib</b> %Boxing</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td>The <b>Box</b> to set the data vor </td></tr>
    <tr><td class="paramname">value</td><td>The 'native' data value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28b628b92185f310ea42b146c15b9ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b628b92185f310ea42b146c15b9ce1">&#9670;&nbsp;</a></span>DefaultUnboxing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TBoxable DefaultUnboxing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>DefaultUnboxing</b> shall access our data object directly.</p>
<p>This template function provides the default implementation used to retrieve values from struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html">BoxData</a> from a <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a>.</p>
<p>To customize unboxing for a type, specialize struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">aworx::lib::boxing::T_Boxing</a> (with the help of macro <a class="el" href="group__GrpALibMacros.html#ga8c3e36e52f60303e7639ae48b146f0d6">ALIB_BOXING_SPECIALIZE</a>) with implementing methods <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a7c300d564618b287a95515308e0dc5fd">T_Boxing::HasCustomUnboxing</a> to return <code>true</code> and having <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a5dfd7dc3e9e72651fd2441d71bc56163">T_Boxing::Unboxing</a> to do the boxing.</p>
<p>See <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">T_Boxing</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td>The <b>Box</b> to get the data of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the boxed data converted to template type <code>TBoxable</code>. </dd></dl>

</div>
</div>
<a id="a0acd27547301a0bb7c2d2fbdbd709df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acd27547301a0bb7c2d2fbdbd709df3">&#9670;&nbsp;</a></span>T_Boxing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">T_Boxing</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><b>T_Boxing</b> shall access our data object directly. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac9663bfd726a1b8c391b21f6e836c66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9663bfd726a1b8c391b21f6e836c66e">&#9670;&nbsp;</a></span>boxer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html">Boxer</a>* boxer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The singleton of a class derived from class <b>Boxer</b> which defines our type and behaviour. </p>

</div>
</div>
<a id="ae873c14aa392d71bf9d5b0c4a28f4af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae873c14aa392d71bf9d5b0c4a28f4af5">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html">BoxData</a> data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The data that we encapsulate. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="box_8hpp_source.html">box.hpp</a></li>
<li>boxinglib.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 28 2018 20:08:33 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
<!-- Start of StatCounter Code e -->
<script type="text/javascript">
var sc_project=11242602;
var sc_invisible=1;
var sc_security="5ac13373";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web statistics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11242602/0/5ac13373/1/" alt="web
statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
