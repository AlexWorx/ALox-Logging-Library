<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALox: T_EnumMetaDataDecl&lt; TEnum, TCheckEnum &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1712 R. 0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--ALox Main Menu-->
<div style="background: #2f3a48; " >
<table  class="aworx-menutable"  >
 <tbody>
 <tr style="height: 36px;">
  <td> <a class="aworx-menu"    href="../index.html"                                   >Home</a>                     </td>
  <td> <a class="aworx-menu_hl" href="../cpp_ref/alox_cpp_mainpage.html"                >ALox for C++</a>             </td>
  <td> <a class="aworx-menu"    href="../cs_ref/alox_cs_mainpage.html"                  >ALox for C#</a>              </td>
  <td> <a class="aworx-menu"    href="../java_ref/alox_java_mainpage.html"              >ALox for Java</a>            </td>
  <td> <a class="aworx-menu"    href="https://github.com/AlexWorx/ALox-Logging-Library">Download</a></td>
 </tr>
 </tbody>
</table>
</div>
<!--end ALox Main Menu-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html">lang</a></li><li class="navelem"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">T_EnumMetaDataDecl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">T_EnumMetaDataDecl&lt; TEnum, TCheckEnum &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="enummetadata_8hpp_source.html">enummetadata.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for T_EnumMetaDataDecl&lt; TEnum, TCheckEnum &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl__inherit__graph.svg" width="310" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for T_EnumMetaDataDecl&lt; TEnum, TCheckEnum &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl__coll__graph.svg" width="310" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><h3>template&lt;typename TEnum, typename TCheckEnum = typename std::enable_if&lt;std::is_enum&lt;TEnum&gt;::value&gt;::type&gt;<br />
struct aworx::lib::lang::T_EnumMetaDataDecl&lt; TEnum, TCheckEnum &gt;</h3>

<h2>Introduction</h2>
<p>In software, enumerations often need more static/constant information along with each enumeration element. This TMP struct is used to associate meta data with the elements of non-scoped or C++ 11 scoped enum types.<br />
 The meta data is stored in a a <a class="el" href="classaworx_1_1lib_1_1lang_1_1Singleton.html">singleton</a> of type <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html">EnumMetaData</a> within a <code>std::vector</code> of user defined <code>std::tuple</code> objects. Besides the vector, a reference to the data sets is available through a hash map that uses the underlying integer value of the elements of the enumeration as its hash key.</p>
<p>While the code of this part of <b>ALib</b> uses template meta programming (TMP), when using the library this is not noticed as the otherwise complicated parts are supported by preprocessor macros which are very simple to use. The next section introduces a simple sample to implement an "element name translation table". While this is a most simple form of meta data, it is so frequently needed, that programming languages like C# or Java provide such table as a built-in language feature!</p>
<h2>Enum Element Name Output</h2>
<p>One obvious use case of enum meta data is the frequent requirement of writing enum elements in human readable form (e.g. log or configuration files). To achieve this, a character string needs to be stored for every element of the enumeration.<br />
 For this use case, macro <a class="el" href="group__GrpALibMacros.html#ga6915abca60042daca351cff2906671ae">ALIB_LANG_ENUM_NAMED</a> does almost all that is needed. Consider the following sample code:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>MyNamespace</div><div class="line">{</div><div class="line">    <span class="keyword">enum class</span> Fruits</div><div class="line">    {</div><div class="line">        Apple,</div><div class="line">        Orange,</div><div class="line">        Banana,</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="group__GrpALibMacros.html#ga6915abca60042daca351cff2906671ae">ALIB_LANG_ENUM_NAMED</a>( MyNamespace::Fruits )</div></div><!-- fragment --><p>Macro <a class="el" href="group__GrpALibMacros.html#ga6915abca60042daca351cff2906671ae">ALIB_LANG_ENUM_NAMED</a> is used to specialize this TMP struct for scoped enum class <code>Fruits</code>. The macro has to be placed <b>in the header file in the default namespace</b>. Then, in a non-header code unit, the meta data has to be initialized. Using macro <b>ALIB_LANG_ENUM_NAMED</b>, the tuples that represent the meta data are fixed to type: </p><pre class="fragment">     std::tuple&lt;int, aworx::String&gt;
</pre><p> The first element of the meta data tuple always stores the enumeration element value using the integer type which the enum class uses. Hence, the definition of the data <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html#a903afc19e63fb1137c661a8e595f314c">Table</a> uses corresponding initializers:</p>
<div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1lang_1_1Singleton.html#aacc819bf0193ea5e1185fc98291b03aa">EnumMetaData&lt;MyNamespace::Fruits&gt;::GetSingleton</a>()-&gt;<a class="code" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html#a903afc19e63fb1137c661a8e595f314c">Table</a>=</div><div class="line">{</div><div class="line">    { <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( Fruits::Apple  ), <span class="stringliteral">&quot;Apple&quot;</span>  },</div><div class="line">    { <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( Fruits::Orange ), <span class="stringliteral">&quot;Orange&quot;</span> },</div><div class="line">    { <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( Fruits::Banana ), <span class="stringliteral">&quot;Banana&quot;</span> },</div><div class="line">};</div></div><!-- fragment --><p> That is all we need to add to our software to start using the meta data! The following code gives a simple sample:</p>
<div class="fragment"><div class="line">Fruits fruit1= Fruits::Apple;</div><div class="line">Fruits fruit2= Fruits::Orange;</div><div class="line">Fruits fruit3= Fruits::Banana;</div><div class="line"></div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Fruit 1: &quot;</span> &lt;&lt; fruit1  &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Fruit 2: &quot;</span> &lt;&lt; fruit2  &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Fruit 3: &quot;</span> &lt;&lt; fruit3  &lt;&lt; endl;</div></div><!-- fragment --><p> This code produces the following output: </p><div class="fragment"><div class="line">Fruit 1: Apple</div><div class="line">Fruit 2: Orange</div><div class="line">Fruit 3: Banana</div></div><!-- fragment --><p> While custom code might also use the meta data for its own purpose, this sample uses <b>ALib</b> built-in mechanism that become available to all enum types that specialize this TMP struct and in addition TMP struct <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDeclReadWrite.html">T_EnumMetaDataDeclReadWrite</a>. The latter is also done with macro <b>ALIB_LANG_ENUM_NAMED</b>.</p>
<p>The output of the name is implemented by making such enum types "applicable" to objects of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>.</p>
<p>Documentation and details to this topic is found with</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">T_Apply</a>: For general information about converting user types to <b>AStrings</b>.</li>
<li><a class="el" href="structaworx_1_1lib_1_1strings_1_1applyto_1_1T__Apply_3_01TEnum_01_4.html">T_Apply&lt;TEnum&gt;</a>: For information and code sample of applying non-bitwise enum types to <b>AStrings</b>.</li>
<li><a class="el" href="structaworx_1_1lib_1_1strings_1_1applyto_1_1T__Apply_3_01TEnumBitwise_01_4.html">T_Apply&lt;TEnumBitwise&gt;</a>: For information and code sample of applying bitwise enum types to <b>AStrings</b>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If TMP struct <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">T_EnumIsBitwise</a> is specialized for the enum type, a different specialization of <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">T_Apply</a> is chosen. This version has a few special demands on the meta data given. Those are well documented and sampled with <a class="el" href="structaworx_1_1lib_1_1strings_1_1applyto_1_1T__Apply_3_01TEnumBitwise_01_4.html">T_Apply&lt;TEnumBitwise&gt;</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only for completeness, it should be mentioned that in the sample above, in addition operator <a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1thirdparty_1_1std.html#a7a8be392083299363a46570e0b11d422">operator&lt;&lt;(std::ostream&amp;,const TApplicable&amp;)</a> comes into play, which allows any <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">applicable type</a> to be used with <code>std::cout</code> respectively <code>std::ostream</code>.</dd></dl>
<p><a class="anchor" id="anchor_T_EnumMetaDataDecl_read_enum"></a></p><h2>Parsing Enum Elements</h2>
<p>The opposite of writing the name of an enum element in human readable form is parsing string data (back) to enumeration values. For this, <b>ALib</b> provides built-in methods</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html#a108a7aaa23fe6b9ac6b37339766ad17f">Substring::ConsumeEnum</a>,</li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html#a1525edfa4acb47087a795c78d3a0f41f">Substring::ConsumeEnumBitwise</a> and</li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html#a9756182d816925205b1c7390e78f68d0">Substring::ConsumeEnumOrBool</a>.</li>
</ul>
<p>Besides what was stored as meta data in the previous section, a third tuple element of type <code>int</code> is needed: This is used to optionally limit the necessary number of characters to match an element name. If the table value is <code>0</code> or negative, all characters need to match. Otherwise, abbreviations may be used, which is often helpful when writing configuration files manually.</p>
<p>To define the specialization of this TMP struct for enum types that support reading values, instead of <a class="el" href="group__GrpALibMacros.html#ga6915abca60042daca351cff2906671ae">ALIB_LANG_ENUM_NAMED</a>, macro <a class="el" href="group__GrpALibMacros.html#ga2a32829c21bae9e8a3440ec519b37a1d">ALIB_LANG_ENUM_PARSABLE</a> can be used. </p><dl class="section note"><dt>Note</dt><dd>Like macro <a class="el" href="group__GrpALibMacros.html#ga6915abca60042daca351cff2906671ae">ALIB_LANG_ENUM_NAMED</a>,this macro also specializes <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDeclReadWrite.html">T_EnumMetaDataDeclReadWrite</a> in one step.</dd></dl>
<p>As a sample we take the actual source code of built-in <b>ALib</b> enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">Case</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">Case</a></div><div class="line">{</div><div class="line">    <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">Sensitive</a>, <span class="comment">///&lt; Chooses an operation mode which differs between lower and upper case letters</span></div><div class="line"><span class="comment"></span><span class="comment">               ///&lt; (usually the default).</span></div><div class="line"><span class="comment"></span>    <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17afd038fc7f319e48f3115d92bf5bdbef9">Ignore</a>     <span class="comment">///&lt; Chooses an operation mode which does not differ between between lower and</span></div><div class="line"><span class="comment"></span><span class="comment">               ///&lt; upper case letters.</span></div><div class="line"><span class="comment"></span>};</div></div><!-- fragment --><p> Because <b>ALib</b> reads all enum meta data from resource files, an additional macro, <a class="el" href="group__GrpALibMacros.html#gac419003997599df2be29a9eada120d98">ALIB_LANG_RESOURCED</a> is used:</p>
<div class="fragment"><div class="line"><a class="code" href="group__GrpALibMacros.html#ga2a32829c21bae9e8a3440ec519b37a1d">ALIB_LANG_ENUM_PARSABLE</a>( <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">aworx::lib::lang::Case</a> )</div><div class="line"><a class="code" href="group__GrpALibMacros.html#gac419003997599df2be29a9eada120d98">ALIB_LANG_RESOURCED</a> ( <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">aworx::lib::lang::Case</a>, <a class="code" href="namespaceaworx_1_1lib.html#a549dea7bf1e3a136dc14e77e96ac2b2a">LANG</a>, <span class="stringliteral">&quot;Case&quot;</span> )</div></div><!-- fragment --><p> This macro receives the <a class="el" href="classaworx_1_1lib_1_1lang_1_1Library.html">Library</a> singleton to use for loading the resources along with the resource identifier.</p>
<p>The corresponding default resource data definition looks like this:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;Case&quot;</span>,         <span class="stringliteral">&quot;0,Sensitive,1,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;1,Ignore,1&quot;</span>,</div></div><!-- fragment --><p> Here, the minimum length to identify the elements when parsing is <code>1</code> for both elements. The reason is that they have different starting characters, so one character is enough to identify each.</p>
<p>A quick sample for parsing enum class <code>Case</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">Case</a> target;</div><div class="line"><a class="code" href="namespaceaworx.html#afed2e22d908094b0badbf8ac4d5f3900">Substring</a>(<span class="stringliteral">&quot;sensitive&quot;</span>).<a class="code" href="classaworx_1_1lib_1_1strings_1_1Substring.html#a108a7aaa23fe6b9ac6b37339766ad17f">ConsumeEnum</a>( target ); cout &lt;&lt; target &lt;&lt; endl;</div><div class="line"><a class="code" href="namespaceaworx.html#afed2e22d908094b0badbf8ac4d5f3900">Substring</a>(<span class="stringliteral">&quot;s&quot;</span>        ).<a class="code" href="classaworx_1_1lib_1_1strings_1_1Substring.html#a108a7aaa23fe6b9ac6b37339766ad17f">ConsumeEnum</a>( target ); cout &lt;&lt; target &lt;&lt; endl;</div><div class="line"><a class="code" href="namespaceaworx.html#afed2e22d908094b0badbf8ac4d5f3900">Substring</a>(<span class="stringliteral">&quot;ignore&quot;</span>   ).<a class="code" href="classaworx_1_1lib_1_1strings_1_1Substring.html#a108a7aaa23fe6b9ac6b37339766ad17f">ConsumeEnum</a>( target ); cout &lt;&lt; target &lt;&lt; endl;</div><div class="line"><a class="code" href="namespaceaworx.html#afed2e22d908094b0badbf8ac4d5f3900">Substring</a>(<span class="stringliteral">&quot;ign&quot;</span>      ).<a class="code" href="classaworx_1_1lib_1_1strings_1_1Substring.html#a108a7aaa23fe6b9ac6b37339766ad17f">ConsumeEnum</a>( target ); cout &lt;&lt; target &lt;&lt; endl;</div></div><!-- fragment --><p> produces the following output: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">Sensitive</a></div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">Sensitive</a></div><div class="line">Ignore</div><div class="line">Ignore</div></div><!-- fragment --><h3>Sort Order of Table Entries</h3>
<p>In more complicated cases, it might be needed change the sort order of the table: longer names which include shorter ones have to be earlier in the table. The default resource for meta data of <b>ALib</b> enum type <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af6d9cc1e6686eca6e60d57d959cf57fb">ContainerOp</a> looks like this:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;ContainerOp&quot;</span>,  <span class="stringliteral">&quot;0,Insert,1,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;1,Remove,1,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;3,GetCreate,4,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;2,Get,1,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;4,Create,1&quot;</span>,</div></div><!-- fragment --><p> If in this definition, "Get" was placed before "GetCreate", the latter could never be identified, because even if "Get" had a minimum length of <code>3</code>, it would always be positively detected on a string like "GetCr".</p>
<p><a class="anchor" id="anchor_T_EnumMetaDataDecl_multiple_entries"></a></p><h3>Enable Multiple Keywords For Parsing</h3>
<p>To allow multiple optional keywords for parsing enum elements, such keywords simply are added as new entries to the name translation table. In other words, it is allowed to have more than one table entry representing the same enum element. This is again true for both, normal enum types and those that are defined <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsBitwise.html">bitwise</a>.</p>
<p>This feature is extensively used with built-in enum <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a39db6982619d623273fad8a383489309">Bool</a> as seen in the <b>ALib</b> source code:</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;Bool&quot;</span>,         <span class="stringliteral">&quot;0,False,1,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;1,True,1,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;0,0,1,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;1,1,1,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;0,No,1,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;1,Yes,1,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;0,On,2,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;1,Off,2,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;0,-,1,&quot;</span></div><div class="line">                <span class="stringliteral">&quot;1,Ok,2&quot;</span>,</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Only the first entry for a dedicated enum element that is found in the table is stored in hash map <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html#a81e92dd684b7ae73c72282b630d32cb8">EnumMetaData::Map</a>. Furthermore, with output methods <a class="el" href="structaworx_1_1lib_1_1strings_1_1applyto_1_1T__Apply_3_01TEnum_01_4.html">T_Apply&lt;TEnum&gt;</a> and <a class="el" href="structaworx_1_1lib_1_1strings_1_1applyto_1_1T__Apply_3_01TEnumBitwise_01_4.html">T_Apply&lt;TEnumBitwise&gt;</a>, it is always the first entry found in a table that is used for writing the human readable name.</dd></dl>
<h2>Custom Meta data</h2>
<p>The last documentation sections introduced simple but commonly used and therefore predefined meta data types. Now, a sample that uses of a fully customized meta data tuple is discussed. The code above used macro <a class="el" href="group__GrpALibMacros.html#ga6915abca60042daca351cff2906671ae">ALIB_LANG_ENUM_NAMED</a>, which evaluates to </p><pre class="fragment"> ALIB_LANG_ENUM_META_DATA(  TEnum, aworx::lib::strings::String )
 ALIB_LANG_ENUM_READ_WRITE( TEnum, 1, 0 )
</pre><p> respectively <a class="el" href="group__GrpALibMacros.html#ga2a32829c21bae9e8a3440ec519b37a1d">ALIB_LANG_ENUM_PARSABLE</a>, which evaluates to </p><pre class="fragment">ALIB_LANG_ENUM_META_DATA(  TEnum, aworx::lib::strings::String, int )
ALIB_LANG_ENUM_READ_WRITE( TEnum, 1, 2 )
</pre><p>This shows, that both just use a more general macro: <a class="el" href="group__GrpALibMacros.html#gaa125ece6dbb0d4b39e25fba2c478c6d1">ALIB_LANG_ENUM_META_DATA</a>.<br />
 This takes the enumeration type as the first element, followed by a variadic argument list, that is used to define the tuple elements. To be precise: the tuple elements besides the first element (which as said before, has the same integer type which is underlying <code>TEnum</code> and stores the enum element value).</p>
<p>The second macro, <a class="el" href="group__GrpALibMacros.html#gacb8b467ea60e139999a47b8383d80be6">ALIB_LANG_ENUM_READ_WRITE</a>, has three parameters</p><ul>
<li>The enumeration type</li>
<li>The tuple index that denotes a textual representation of the element name (often just the same string as the C++ element identifier).</li>
<li>The tuple index that denoting the minimum characters to read when parsing this element with methods <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html#a108a7aaa23fe6b9ac6b37339766ad17f">ConsumeEnum</a>, <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html#a1525edfa4acb47087a795c78d3a0f41f">ConsumeEnumBitwise</a> or <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html#a9756182d816925205b1c7390e78f68d0">ConsumeEnumOrBool</a> (or a custom parsing method).</li>
</ul>
<p>Let's use these macros to set a custom type of the meta data:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>MyNamespace</div><div class="line">{</div><div class="line">    <span class="keyword">enum class</span> Pets</div><div class="line">    {</div><div class="line">        Cat,</div><div class="line">        Dog,</div><div class="line">        Bird,</div><div class="line">        Snake,</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="group__GrpALibMacros.html#gaa125ece6dbb0d4b39e25fba2c478c6d1">ALIB_LANG_ENUM_META_DATA</a>(</div><div class="line">    MyNamespace::Pets, <span class="comment">// The enum type.</span></div><div class="line">    <span class="keywordtype">int</span> ,              <span class="comment">// tuple element 1: number of legs. (0 is underlying integer)</span></div><div class="line">    <span class="keywordtype">int</span> ,              <span class="comment">// tuple element 2: number of wings.</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a>      <span class="comment">// tuple element 3: element name</span></div><div class="line">)</div><div class="line"><a class="code" href="group__GrpALibMacros.html#gacb8b467ea60e139999a47b8383d80be6">ALIB_LANG_ENUM_READ_WRITE</a>(</div><div class="line">    MyNamespace::Pets, <span class="comment">// The enum type.</span></div><div class="line">    3   ,              <span class="comment">// index of name element in the tuple.</span></div><div class="line">    0                  <span class="comment">// index of minimum read length. Set to 0, hence parsing disabled.</span></div><div class="line">)</div></div><!-- fragment --><p>Again, please note that the macros have to be placed in the header file in the global scope.</p>
<p>Then, in a non-header code unit, the meta data has to be initialized:</p>
<div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1lang_1_1Singleton.html#aacc819bf0193ea5e1185fc98291b03aa">EnumMetaData&lt;MyNamespace::Pets&gt;::GetSingleton</a>()-&gt;<a class="code" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html#a903afc19e63fb1137c661a8e595f314c">Table</a>=</div><div class="line">{</div><div class="line">    <span class="comment">//       pet enum           #legs    #wings      name</span></div><div class="line">    { <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( Pets::Cat   ),   4    ,   0     ,  <span class="stringliteral">&quot;Cat&quot;</span>   },</div><div class="line">    { <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( Pets::Dog   ),   4    ,   0     ,  <span class="stringliteral">&quot;Dog&quot;</span>   },</div><div class="line">    { <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( Pets::Bird  ),   2    ,   2     ,  <span class="stringliteral">&quot;Bird&quot;</span>  },</div><div class="line">    { <a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>( Pets::Snake ),   0    ,   0     ,  <span class="stringliteral">&quot;Snake&quot;</span> },</div><div class="line">};</div></div><!-- fragment --><p> While in the previous sample this is all we needed to start, there is one thing left here. Usually, after changes of the data vector <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html#a903afc19e63fb1137c661a8e595f314c">EnumMetaData::Table</a>, the hash map <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html#a81e92dd684b7ae73c72282b630d32cb8">EnumMetaData::Map</a> has to be updated. This is done with method <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html#a715ca664eec221260f558b2a5ceffea9">EnumMetaData::CheckLoad</a>. In the former sample this was not needed, because the values were "applied" to an <b>AString</b> and the built-in method invokes this function for convenience with every run. In the sample code below, we have to do this manually.</p>
<p>If the data is set with an initializer as shown here, it is good practice to invoke this function for each of your enums right away after the initialization.</p>
<p>So let's call it:</p>
<div class="fragment"><div class="line"><span class="comment">// Initialize hash map from meta data table. Needs to be done once on bootstrap.</span></div><div class="line"><a class="code" href="classaworx_1_1lib_1_1lang_1_1Singleton.html#aacc819bf0193ea5e1185fc98291b03aa">aworx::EnumMetaData&lt;Pets&gt;::GetSingleton</a>()-&gt;<a class="code" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html#a36c448bf6f4a286e7504b77e6c0230d0">CheckMap</a>();</div></div><!-- fragment --><p> Now anywhere in the software, code like this can be performed:</p>
<div class="fragment"><div class="line"><span class="comment">// A vector of pets</span></div><div class="line">std::vector&lt;Pets&gt; pets= { Pets::Cat, Pets::Dog, Pets::Bird, Pets::Snake };</div><div class="line"></div><div class="line"><span class="comment">// loop over them</span></div><div class="line"><span class="keyword">auto</span>&amp; enumMetaData= *<a class="code" href="classaworx_1_1lib_1_1lang_1_1Singleton.html#aacc819bf0193ea5e1185fc98291b03aa">aworx::EnumMetaData&lt;Pets&gt;::GetSingleton</a>();</div><div class="line"><span class="keywordflow">for</span>( <span class="keyword">auto</span> pet : pets )</div><div class="line">{</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A &quot;</span>     &lt;&lt; <a class="code" href="structaworx_1_1lib_1_1lang_1_1EnumReadWriteInfo.html#a3a4f86d809607a8ad171af4f2b86afc9">aworx::EnumReadWriteInfo&lt;Pets&gt;::Name</a>( enumMetaData, pet )</div><div class="line">         &lt;&lt; <span class="stringliteral">&quot; has &quot;</span>  &lt;&lt; enumMetaData.Value&lt;1&gt;( pet ) &lt;&lt; <span class="stringliteral">&quot; legs&quot;</span></div><div class="line">         &lt;&lt; <span class="stringliteral">&quot; and &quot;</span>  &lt;&lt; enumMetaData.Value&lt;2&gt;( pet ) &lt;&lt; <span class="stringliteral">&quot; wings!&quot;</span> &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>For iteration, we need the <code>std::vector</code> of Pets. Check out <b>ALib</b> <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumIsIteratable.html">enum iterating feature</a> for information on how to avoid this error prone and inefficient approach.</dd></dl>
<p>This sample produces the following output: </p><div class="fragment"><div class="line">A Cat has 4 legs and 0 wings!</div><div class="line">A Dog has 4 legs and 0 wings!</div><div class="line">A Bird has 2 legs and 2 wings!</div><div class="line">A Snake has 0 legs and 0 wings!</div></div><!-- fragment --><h2>Using Class Resources For Loading Enum Meta Data</h2>
<p>As it was already shown in some samples above, <a class="el" href="classaworx_1_1lib_1_1lang_1_1Resources.html">ALib Resource Data</a> might be used to "externalize" enum meta data.</p>
<p>This is supported by specializing TMP struct <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__Resourced.html">T_Resourced</a> in addition to specializing TMP struct <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html">T_EnumMetaDataDecl</a>. Such specialization is easily done with macros:</p><ul>
<li><a class="el" href="group__GrpALibMacros.html#gac419003997599df2be29a9eada120d98">ALIB_LANG_RESOURCED</a> and</li>
<li><a class="el" href="group__GrpALibMacros.html#gac419003997599df2be29a9eada120d98">ALIB_LANG_RESOURCED</a></li>
</ul>
<p>For standard meta data types ("named" and "parsable") this is all that is needed to start loading the meta data from the resources. However, with custom tuple types, method <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html#a715ca664eec221260f558b2a5ceffea9">EnumMetaData::CheckLoad</a> has to specialized to perform the load. With macro <a class="el" href="group__GrpALibMacros.html#ga16d4f8ecf681d773b1e93f64144cc02a">ALIB_LANG_ENUM_META_DATA_RESOURCE_LOADER</a> such specialization is implemented in a way that it should satisfy the most common needs: Static helper method <a class="el" href="classaworx_1_1lib_1_1lang_1_1ResourcedTupleLoader.html#ac6cfcaf50cfacefa9aff1f2a980506c7">ResourcedTupleLoader::LoadTable</a> is used to load the data. As documented, this method (optionally) allows to have all data stored in one resource string or to separate the data of each enum element in an own numbered resource string.</p>
<p>Using the macros above, the following things have to be kept in mind:</p><ul>
<li>The macros refer to class <a class="el" href="classaworx_1_1lib_1_1lang_1_1Library.html">Library</a> which internally holds and instances of <a class="el" href="classaworx_1_1lib_1_1lang_1_1Resources.html">Resources</a> and probably shares this with other libraries, like <b>ALox</b>.</li>
<li>Externalization allows translation of strings to different languages, as well as to change identifiers that a library uses by default. This way, a user of <b>ALib</b> might translate and change all of the built-in identifier names, configuration variables, exception messages and so forth.</li>
<li>The meta data is not loaded automatically from the resources, instead this is done only with an explicit invocation of <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html#a715ca664eec221260f558b2a5ceffea9">EnumMetaData&lt;TEnum&gt;::GetSingleton()-&gt;CheckLoad</a>.<br />
 Therefore, prior to accessing the data, this method has to be invoked "manually".</li>
<li>All write and parse methods built-in to <b>ALib</b>, invoke this method upfront.</li>
</ul>
<h1>Reference Documentation</h1>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>The enumeration type this struct applies to. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a192f961ba0493883f37bd7b662fa3ecc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html#a192f961ba0493883f37bd7b662fa3ecc">TTuple</a> = void</td></tr>
<tr class="separator:a192f961ba0493883f37bd7b662fa3ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a192f961ba0493883f37bd7b662fa3ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192f961ba0493883f37bd7b662fa3ecc">&#9670;&nbsp;</a></span>TTuple</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structaworx_1_1lib_1_1lang_1_1T__EnumMetaDataDecl.html#a192f961ba0493883f37bd7b662fa3ecc">TTuple</a> =  void</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <code>std::tuple</code> type used for entries in the static meta data <a class="el" href="structaworx_1_1lib_1_1lang_1_1EnumMetaData.html#a903afc19e63fb1137c661a8e595f314c">Table</a>. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="enummetadata_8hpp_source.html">enummetadata.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 22 2017 22:23:15 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<!-- Start of StatCounter Code e -->
<script type="text/javascript">
var sc_project=11242602;
var sc_invisible=1;
var sc_security="5ac13373";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web statistics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11242602/0/5ac13373/1/" alt="web
statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
