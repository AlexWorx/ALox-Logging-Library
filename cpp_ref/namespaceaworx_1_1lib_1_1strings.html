<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ALox: aworx::lib::strings Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!-- so strange, that doxgen does not highlight each menu item. Just some... -->
<script>
  $(document).ready(function() {     
    fnameStart= window.location.href.lastIndexOf('/')
    fnameEnd=   window.location.href.indexOf('_', fnameStart )
    if( fnameEnd < 0 ) {
        fnameEnd=   window.location.href.indexOf('.', fnameStart )
    }
    if( fnameEnd > -1 ) {
        subString= window.location.href.substring( fnameStart, fnameEnd )
        $('li').toArray().forEach(function(li){
            if(     typeof li.firstChild.href != 'undefined'
                &&  li.firstChild.href.indexOf(subString) > 0 
                ){
               li.classList.add('current');
            }
        });
    }
  });
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1602 R. 1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../index.html"><span>ALox&#160;Home</span></a></li>
      <li><a href="../faq.html"><span>FAQ</span></a></li>
      <li><a href="../manual.html"><span>Manual</span></a></li>
      <li class="current"><a href="cppmainpage.html"><span>ALox&#160;for&#160;C++</span></a></li>
      <li><a href="../cs_ref/csmainpage.html"><span>ALox&#160;for&#160;C#</span></a></li>
      <li><a href="../java_ref/javamainpage.html"><span>ALox&#160;for&#160;Java</span></a></li>
      <li><a href="../tools.html"><span>Tools</span></a></li>
      <li><a href="https://github.com/AlexWorx/ALox-Logging-Library"><span>Download</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="cppmainpage.html"><span>Overview</span></a></li>
      <li><a href="cpptutorial.html"><span>Tutorial</span></a></li>
      <li><a href="cppsetup.html"><span>IDE/Build&#160;system&#160;setup</span></a></li>
      <li><a href="cppprepro.html"><span>ALox&#160;Preprocessor&#160;Symbols</span></a></li>
      <li><a href="annotated.html"><span>Class&#160;Reference</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html">strings</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">aworx::lib::strings Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Namespace Description</h2>
<div class="textblock"><hr/>
<h1><a class="anchor" id="alib_namespace_strings_intro"></a>
Introduction</h1>
<p>This namespace of ALib provides classes that operate on character strings (following <a class="el" href="namespaceaworx_1_1lib.html">the principle design goals of ALib</a>). As the given C#/Java StringBuilder/Buffer classes are either "sealed" and/or do not provide direct access to the internal buffer, to avoid conversion to new immutable strings in certain situations, ALib implements its own string class. More complex functions, like extended formatting operations are not supported and remain the domain of the language specific class libraries.</p>
<p>In contrast to the Java and C# versions of ALib, which merely provide a central string class named <b>AString</b> along with <b>Substring</b>, things became a little more complex in ALib for C++. The following feature overview illustrate the reasons for this:</p>
<ul>
<li>Implicit conversion of external, user defined string types when passing data into ALib. This includes of-course compatibility with <em>std::string</em> and <em>cstrings</em> (<em>char*</em>), but also 3rd party types like e.g. <em>QString</em>.</li>
<li>Conversion/construction through template meta programming, with minimum (almost no) runtime overhead.</li>
<li>Support for user defined types that get 'applied' to strings. (Mostly concatenated, but also more complex string algorithms can be implemented without changing ALib sources.)</li>
<li>Stack allocated strings that avoid overhead of dynamic memory allocation, but in case of unexpected capacity demands, automatically switch to a dynamic data model.</li>
<li>Fast processing of C++ string literals and other string types whose length is known at compile time (no strlen(), for short types no memcpy() ).</li>
<li>Zero terminated and non-zero-terminated strings with mostly implicit termination.</li>
<li>'Nullable' state that avoids nullptr checks and enables to work with references everywhere.</li>
<li>Conversion to and from wide character strings.</li>
<li>'Non-checking' versions of many string methods are available to avoid redundant parameter checks.</li>
<li>Built-in debugging mechanics.</li>
<li>But still: as much as possible/reasonable compatibility with strings in ALib for JAVA/C#.</li>
</ul>
<h1><a class="anchor" id="alib_namespace_strings_class_overview"></a>
Classes overview</h1>
<p>To understand the rationale behind introducing different string types, it is easiest to go quickly through them one by one. The classes are:</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">PreallocatedString</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringLiteral.html">StringLiteral</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>As described in <a class="el" href="namespaceaworx.html#CPP_AWORX_NS_SHORTCUTS">Type Shortcuts in the aworx Namespace</a>, the type names of ALib are 'mirrored' into namespace <b>aworx</b>. As there is a limitation with template types, classes <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringLiteral.html">StringLiteral</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">PreallocatedString</a> got renamed in namespace <b>aworx</b>. Their names are mapped to <code>SLiteral</code> and <code>PAString</code>.<br />
 The latter names are probably even more common in the documentation. Just remember that <b>StringLiteral</b> and <b>SLiteral</b> are synonyms, the same as <b>PreallocatedString</b> and <b>PAString</b> are.</dd></dl>
<h2><a class="anchor" id="alib_namespace_strings_class_overview_as"></a>
Class String</h2>
<p>The most basic class is <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a>. It just contains a character pointer and the length of the data that should be represented by this object. Class <b>String</b> does not allocate any string data and with the exclamation of assigning something (completely) different, does not allow to change the pointer to its buffer or its length.</p>
<p>Objects of type <b>String</b> are implicitly constructed or assigned to from other string types like</p><ul>
<li>C++ string literals</li>
<li><em>char* / wchar_t*</em> pointers</li>
<li><em>std::string</em> objects</li>
<li>derived <b>String</b> types or</li>
<li>external, user defined types.</li>
</ul>
<p>The use cases of the class concentrate on two scenarios:</p>
<p><em>1. Using class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> for <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> Constants:</em></p>
<p>Often, some constant string data is needed. For example, let's look at class ALib and it's field <a class="el" href="classaworx_1_1lib_1_1ALIB.html#affcf83e8b52935dd94b74c1a47cf7e0a">ALIB::ConfigCategoryName</a>. This field is used by ALib when getting configuration parameters, e.g. from environment variables. By default, this field is set to "ALIB", but an application might want to change it to something like "MYAPP". By having this field of type <code>String</code>, just any string type can be assigned to it. The user of ALib must not explicitly convert '<em>his'</em> string type to ALib types but just using the assignment operator <em>'='</em>. Furthermore, in advantage to type <em>const char*</em>, along with the pointer, the length of the string is stored. This gives a good performance improvement, as e.g. no <em>strlen()</em> call has to be made prior to copying this string to some other place.<br />
 </p><dl class="section attention"><dt>Attention</dt><dd>Same as with a use of <em>const char*</em>, when assigning a string to an <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a></code> object, it has to be made sure that this string is kept intact during the life-time of the target.</dd></dl>
<p><em>2. Using 'const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a>&amp;' as Method Parameter Type:</em></p>
<p>All ALib interface methods that need some string input use a constant reference to <code>String</code> as parameter type (or to derived type <code>TString</code>, discussed later). Again, the using code does not need to care about conversion. References or pointers to any sort of string classes might be passed. In this case lifetime is deemed to be rather short, local and stack allocated. With having C++ 11 move constructor and assignment in place, no destructor, no virtual methods and just two members, objects of type <code>String</code> are a very lightweight and perfect candidates to be constructed implicitly for method parameter passing.<br />
 As a sample, see constructor of class <a class="el" href="classaworx_1_1lib_1_1system_1_1Directory.html#a3d2aef8216e51d8fea90c4f4b4f26959">Directory</a>. It is declared as: </p><div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#ae59166dff4149598acd5f636fe6760d8">Directory</a>( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a>&amp; path );</div></div><!-- fragment --><p> With this declaration, it is possible to invoke that constructor passing using just any type of strings: </p><div class="fragment"><div class="line"><span class="comment">// Creating Directory object from C++ string literal</span></div><div class="line"><a class="code" href="namespaceaworx.html#ae59166dff4149598acd5f636fe6760d8">Directory</a> bin( <span class="stringliteral">&quot;/usr/bin&quot;</span> );</div><div class="line"></div><div class="line"><span class="comment">// Creating Directory object from std::string</span></div><div class="line">std::string libPath( <span class="stringliteral">&quot;/usr/lib&quot;</span> );</div><div class="line"><a class="code" href="namespaceaworx.html#ae59166dff4149598acd5f636fe6760d8">Directory</a> lib( libPath );</div><div class="line"></div><div class="line"><span class="comment">// Creating Directory object from std::string given as pointer</span></div><div class="line"><a class="code" href="namespaceaworx.html#ae59166dff4149598acd5f636fe6760d8">Directory</a> lib2( &amp;libPath );</div><div class="line"></div><div class="line"><span class="comment">// Creating Directory object from ALib AString</span></div><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> srcPath( <span class="stringliteral">&quot;/usr/src&quot;</span> );</div><div class="line"><a class="code" href="namespaceaworx.html#ae59166dff4149598acd5f636fe6760d8">Directory</a> src( srcPath );</div><div class="line"></div><div class="line"><span class="comment">// Creating Directory object from ALib AString given as pointer</span></div><div class="line"><a class="code" href="namespaceaworx.html#ae59166dff4149598acd5f636fe6760d8">Directory</a> src2( &amp;srcPath );</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>ALib methods that continue to need the string data after their execution will create a copy of it. In other words, they will never expect that the buffer received in a parameter of type <code>String</code> still exists after the method exits.</dd></dl>
<h3>Binding user types to ALib strings</h3>
<p>With a little one-time effort of implementing two small template methods, also user defined string types (or types from other 3rd party library) can be made compatible easily. Due to template meta programming, variations of these types, like pointers or references, const or non-const, etc. will be accepted with minimum (mostly no) runtime impact, because TMP hook in at compile time.<br />
 For more information on how to make ALib support user defined types see partially specialized template function <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7cfd45024bf9222b42febac98fdcc146">ToString</a>.<br />
</p>
<p><a class="anchor" id="alib_namespace_strings_nullable"></a></p><h3>Nullable Strings</h3>
<p>Another important note is the fact that class <b>String</b> are 'nullable'. This term means here, that when they got constructed with no value, with <em>nullptr</em>, with other <em>nulled</em> ALib strings, etc., this state is detectable and is different from representing an empty string of zero length. This is very important for lean and clean user code.</p>
<p>Derived mutable class <b>AString</b> (which is discussed below in more detail) inherits this ability See the sample exposed in <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#alib_namespace_strings_astring_nullable">Nullable AStrings</a> to get a better understanding of this concept.</p>
<h3>Not Zero-Terminated</h3>
<p>Strings represented by this class may be zero terminated. E.g. when constructed from a string literal they definitely are (as C++ string literals are zero terminated an not writable). However, class <b>String</b> does not count on that and treats its content as not zero-terminated. Therefore, the interface methods provided implement those standard string operations that are allowed (or can be implemented efficiently) on non-zero-terminated strings.</p>
<p>For further information about this type, note the reference documentation <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">class String</a>.</p>
<h3>Lightweight and Volatile</h3>
<p>Due to the minimum footprint (a pointer to the string buffer and an integer value for the strings' length), move construction and assignment is compiler defined and very fast. Even passing objects as value has a very limited (and sometimes no) performance impact.</p>
<h2><a class="anchor" id="alib_namespace_strings_class_overview_asterminatable"></a>
Class TString</h2>
<p>A first specialization of class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> is class <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> which is representing strings that - other than the name might indicate - either</p><ul>
<li><b>are</b> terminated with a trailing '\0' character, or</li>
<li><b>can be</b> terminated by writing a trailing '\0' into the <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a> at position <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a9f59b34b1f25fe00023291b678246bcc">length</a>.</li>
</ul>
<p>This is important to understand. For example, a C++ string literal like <em>"Hello"</em> is zero terminated. If it was not, it could not be terminated explicitly because write access is not allowed.</p>
<p>The important design decision made here is that the constructing objects this class is still implicit. This is sometimes a little dangerous, but runtime checks are provided to detect illegal construction with data that either is not terminated or can't be terminated. (For details, refer to <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a>'s reference documentation.)</p>
<p>The interface of class <b>TString</b> extends the set of methods provided by parent class <b>String</b>, by those standard string operations that can be implemented more efficiently on zero-terminated strings. This includes search operations for other strings and for single characters taken from a choice of characters.</p>
<h2><a class="anchor" id="alib_namespace_strings_class_overview_astring"></a>
Class AString</h2>
<p>Class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> which specializes class <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> disposes of an allocation mechanism to allow the creation and manipulation of strings. Therefore, this is the central class to assemble strings at runtime. Whenever append operations exceed the existing buffer, the contents is copied to a new, bigger buffer and the old one is disposed.</p>
<p>Conceptually, the difference to parent classes <b>String</b> and <b>TString</b> is that those <em>represent</em> (constant) string objects, while this class might be considered of <em>being</em> a non-constant string.</p>
<p><a class="anchor" id="alib_namespace_strings_class_overview_astring_construction"></a></p><h3>Construction</h3>
<p>Class <b>AString</b> hides all parent constructors and offers re-implementations of these that <b>copy</b> the data that is passed. Consequently - as this copying is not considered a lightweight operation - all constructors are explicit. If, for example, a function expects a constant <b>AString</b> reference, such <b>AString</b> has to be created explicitly before or inside the function invocation. Consequently the assignment operator is not applicable with initializations as well. The following code will not compile: </p><pre class="fragment">AString as=  "This will not compile";
</pre><p> Instead, explicit creation has to be made, as shown here: </p><pre class="fragment">AString as("This will compile");

// or alternatively
AString as;
as= "This will compile";
</pre><p>With constructor <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#aebc985ab1428055a05aee879e173910a">AString(const T&amp;)</a>, class <b>AString</b> provides the same the flexibility like parent class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> in respect to the ability to take just anything that is a string, including 'external' user defined types as an initial value.</p>
<p>Copy constructor, move constructor and move assignment are well defined, which allows <b>AString</b> objects to be used (as efficiently as possible) e.g. in std::vector instantiations.</p>
<h3>Buffer Management</h3>
<p>As mentioned before, class <b>AString</b> provides logic to manage its own buffer. Furthermore, it is also possible to have objects of class <b>AString</b> work on 'external' buffers, hence buffers that are not bound to the <b>AStrings'</b> life-cycle. For details on this see method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0c8474e9c19a45b535f1b460aac3847b">AString::SetBuffer</a>. Class <a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">PreallocatedString</a>, which is discussed below, makes use of this feature and provides the possibility to have local (stack based) allocations of strings.</p>
<h3>Appending and Applying Objects</h3>
<p>Similar to parent class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> for construction, class <b>AString</b> provides a template meta programming based method to "apply" any type of object to an <b>AString</b> after its construction. For many types, e.g. string types or integer and floating point types, the term '<em>applying</em>' is means nothing else than '<em>appending</em>'. If a string gets applied to an object of type <b>AString</b>, the string is appended. However, as almost any type, including 'external', user defined types might be applied and such application is performed in a specialized template method, the operation associated with the <em>application</em> of an object of a certain type is not limited to appending data.</p>
<p>As an example, the concept of <em>'applying'</em> is used to add 'fields' to an <b><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a></b>. To achieve this, a special <em>'applicable'</em> type named <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Field.html">Format::Field</a> is defined. Appending a field is done as follows: </p><div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> centered;</div><div class="line">centered &lt;&lt; <span class="charliteral">&#39;*&#39;</span> &lt;&lt; Format::Field( <span class="stringliteral">&quot;Hello&quot;</span>, 15, Alignment::Center ) &lt;&lt; <span class="charliteral">&#39;*&#39;</span>;</div><div class="line">cout &lt;&lt; centered &lt;&lt; endl;</div></div><!-- fragment --><p>which produces the following output: </p><div class="fragment"><div class="line">*     Hello     *</div></div><!-- fragment --><p>For more information on how to make <b>AString</b> support user defined applicable types see method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4dbe5fba1e5c5ed69d12d57b3eb49ef7">AString::Apply</a> and partially specialized template function <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aa8fb47b820e77796083d2c3eb13d56b2">ApplyTo</a>.</p>
<h2><a class="anchor" id="alib_namespace_strings_class_overview_asprealoc"></a>
Class PreallocatedString</h2>
<p>Template class <a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">PreallocatedString&lt;int TCapacity&gt;</a>, derived from class <b>AString</b> uses an internal member of type <em>char[TCapacity]</em> with templated size to store the string data. The huge benefit lies in performance: The impact of frequent allocation of '<em>free memory</em>' (aka <em>heap allocation</em>) is often underestimated by developers. Therefore, for local string operations class <b>PreallocatedString</b> and its convenient type definitions <a class="el" href="namespaceaworx.html#a148a217c34a72b4360462205858b8f0e" title="Type alias name for PreallocatedString&lt;16&gt;. ">String16</a>, <a class="el" href="namespaceaworx.html#a221752691fb92bcd592c045d6c368289" title="Type alias name for PreallocatedString&lt;32&gt;. ">String32</a> ... <a class="el" href="namespaceaworx.html#a82395a8f3fac47787ebe8749679a2796" title="Type alias name for PreallocatedString&lt;1024&gt;. ">String1K</a>, <a class="el" href="namespaceaworx.html#a76f69ad445caecfbf03351c884637b09" title="Type alias name for PreallocatedString&lt;2048&gt;. ">String2K</a>, <a class="el" href="namespaceaworx.html#a772f06f37ace5e2b2eb8cafc0c859c44" title="Type alias name for PreallocatedString&lt;4096&gt;. ">String4K</a>. should be considered as a fast alternative for class <b>AString</b>.</p>
<h3>Exceeding the Buffer Capacity</h3>
<p>Although the internal buffer size is fixed at compile time and hence can not be expanded, a user of the class must not fear an assertion from '<em>buffer overflows</em>'. If the internal buffer capacity is exceeded, a regular allocated buffer from the <em>free memory</em> (aka '<em>heap'</em>) will be allocated. The slight disadvantage then is, that the memory of the internal buffer is (of-course) not freed.</p>
<p>In debug compilations of ALib, already parent class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> provides warning mechanism that enables the easy detection of such probably unwanted replacements of external buffers (in this case the '<em>member-allocated'</em> buffer). Using macro <a class="el" href="group__GrpALibMacros.html#gac506942a02a0be3af76a71116e8ce645">ALIB_WARN_ONCE_PER_INSTANCE_DECL</a> an <em>ALib Warning</em> will be issued when a buffer is replaced. There are two scenarios how a this mechanism might be used during development:</p><ul>
<li>If the buffer should never be replaced, the capacity of an PreallocatedString has to be increased step by step when the warning is issued, until the member-buffer is huge enough.</li>
<li>If it is OK, if the buffer is replaced every once in a while (because there special situations with higher capacity needs occur, but are relatively seldom) then, the warning should be switched off for this specific object, as it is explained in <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ae6e756e6f5ccc142f9fc3ceb6ba18cf0">AString::ReplaceExternalBuffer</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Again, all warnings are effective only with debug compilations of ALib.</dd></dl>
<h3>Aliases For Frequently Used Sizes</h3>
<p>For commonly used sizes, some convenient alias names are defined. See aliases <a class="el" href="namespaceaworx.html#a148a217c34a72b4360462205858b8f0e" title="Type alias name for PreallocatedString&lt;16&gt;. ">String16</a>, <a class="el" href="namespaceaworx.html#a221752691fb92bcd592c045d6c368289" title="Type alias name for PreallocatedString&lt;32&gt;. ">String32</a>, <a class="el" href="namespaceaworx.html#ac2fdc487456a994238ba4284b3859c41" title="Type alias name for PreallocatedString&lt;64&gt;. ">String64</a> ... <a class="el" href="namespaceaworx.html#a82395a8f3fac47787ebe8749679a2796" title="Type alias name for PreallocatedString&lt;1024&gt;. ">String1K</a>, <a class="el" href="namespaceaworx.html#a76f69ad445caecfbf03351c884637b09" title="Type alias name for PreallocatedString&lt;2048&gt;. ">String2K</a>, <a class="el" href="namespaceaworx.html#a772f06f37ace5e2b2eb8cafc0c859c44" title="Type alias name for PreallocatedString&lt;4096&gt;. ">String4K</a>.</p>
<h3>Implicit construction</h3>
<p>While class <b>AString</b>, as <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_namespace_strings_class_overview_astring_construction">noted above</a>, does not provide implicit construction, this class re-implements the common constructors of <b>AString</b> and exposes them as <em>implicit</em>. The rationale here is that although the data is copied (which might not be a very lightweight task), still the performance impact is far less compared to constructing an <b>AString</b> and it is taken into account that an <b>PreallocatedString</b> is created without explicit exposure of this creation. </p>
<p>The following method, as a sample, takes three different ALib string types as parameters: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> TakeStrings( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a>&amp; s1, <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a>&amp; s2, <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">aworx::String64</a> s3 )</div></div><!-- fragment --><p>The following code will <em>not</em> compile: </p><div class="fragment"><div class="line">TakeStrings( <span class="stringliteral">&quot;Str1&quot;</span>, <span class="stringliteral">&quot;Str2&quot;</span>, <span class="stringliteral">&quot;Str3&quot;</span> );          <span class="comment">// Error, AString not implicitly constructable</span></div></div><!-- fragment --><p>Class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> has to be explicitly created, the others don't: </p><div class="fragment"><div class="line">TakeStrings( <span class="stringliteral">&quot;Str1&quot;</span>, <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a>(<span class="stringliteral">&quot;Str2&quot;</span>), <span class="stringliteral">&quot;Str3&quot;</span> ); <span class="comment">// OK, AString explicit, AS and ASPrealloc implicit</span></div></div><!-- fragment --><p> In addition, besides having implicit construction, the default assign operator is defined as well. This allows to use objects of this type as class members that are initialized within the class declaration as shown here: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div><div class="line">{</div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">aworx::PAString&lt;20&gt;</a> name=  <span class="stringliteral">&quot;(none)&quot;</span>;</div><div class="line">};</div></div><!-- fragment --><p>Such members are not allowed to be initialized in the declaration if their type is <b>AString</b>.</p>
<h3>Move Constructor and Assignment</h3>
<p>Class <b>PreallocatedString</b> provides a '<em>move constructor</em>' but no '<em>move assignment operator</em>'. See the <a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">classes reference documentation</a> for more information.</p>
<h2><a class="anchor" id="alib_namespace_strings_class_overview_substring"></a>
Class Substring</h2>
<p>Class <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a> is derived directly from class <b>String</b>. Conceptually, the difference to its parent class is that it is not constant. It was discussed earlier, that objects of type <b>String</b>, once constructed, will never change the pointer to the buffer or its length. Objects of class <b>Substring</b> are entitled to do so. In general, the string they represent is a portion of another string and if they change, this change normally means either shrinking or they are just changing completely. They are especially useful to parsing string data. Some Parsing of strings (in its probably simplest form) making use of class <b>Substring</b> is provided with class <a class="el" href="classaworx_1_1lib_1_1strings_1_1Tokenizer.html">Tokenizer</a>, which is also defined in this namespace.</p>
<dl class="section note"><dt>Note</dt><dd>Speaking of <b>Substring</b> being '<em>non constant</em>' refers to their own members <em>buffer</em> and <em>length</em>. This does not mean that the contents of the buffer is manipulatable.</dd></dl>
<h2><a class="anchor" id="alib_namespace_strings_class_overview_asliteral"></a>
Class StringLiteral</h2>
<p>Other than this classes' name might suggest, template class <a class="el" href="classaworx_1_1lib_1_1strings_1_1StringLiteral.html">StringLiteral</a> represent strings whose length is fixed and known at compile time. Moste ofently, objects of this type are constructed from C++ string literals, like in the following samples: </p><div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1StringLiteral.html">aworx::SLiteral&lt;3&gt;</a> litA= <span class="stringliteral">&quot;123&quot;</span>;</div><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1StringLiteral.html">aworx::SLiteral&lt;5&gt;</a> litB= <span class="stringliteral">&quot;MAGIC&quot;</span>;</div><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1StringLiteral.html">aworx::SLiteral&lt;1&gt;</a> litC= <span class="stringliteral">&quot;x&quot;</span>;</div></div><!-- fragment --><p> But it is also allowed to construct them from other character arrays, even writable ones, like here: </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> carr[4] {<span class="stringliteral">&quot;123&quot;</span>};</div><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1StringLiteral.html">aworx::SLiteral&lt;3&gt;</a> variableLit= carr;</div><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a>          as( variableLit );</div><div class="line"></div><div class="line">carr[0]= <span class="charliteral">&#39;4&#39;</span>;</div><div class="line">carr[1]= <span class="charliteral">&#39;5&#39;</span>;</div><div class="line">carr[2]= <span class="charliteral">&#39;6&#39;</span>;</div><div class="line"></div><div class="line">as &lt;&lt; variableLit;</div></div><!-- fragment --><p> As the class specializes <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a>, with the second sample, the user of the class has to make sure that the string represented by objects of this type is zero terminated.</p>
<p>Using class <b>StringLiteral</b> improves the performance of certain operations. For example appending (applying) objects of this type to objects of class <b>AString</b> will not result in a copy loop but will simply inline the correct number of copy operations into the object code (at least for the smaller sizes which are typically used).</p>
<dl class="section note"><dt>Note</dt><dd>ALib string classes, try to preserve this performance improvement using C++ string literals directly. But, when C++ string literals get passed to methods, usually such passing will convert them to <em>const char*</em> type (unless template methods are in place). From this moment on, the information about the length is lost. Therefore, class <b>StringLiteral</b> should be used whenever C++ literals whose length is know at compile time are shared between different code segments to avoid converting them to <em>const char*</em> or <b>String</b> type. </dd>
<dd>
It is possible to enable 'external', user defined types to act as string literals as well. This is a rather unlikely scenario, but if requested, optionally and solely for a (potentially small) performance gain, these types can get adopted to ALib by implementing class <a class="el" href="structaworx_1_1lib_1_1strings_1_1TMPLiteral.html">TMPLiteral</a>. This process is not further documented or demonstrated by a sample. Interested audience should consult the source code of ALib for doing it. The mechanism used is similar to what is used with template functions <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7cfd45024bf9222b42febac98fdcc146">ToString</a> and <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a>.</dd></dl>
<h1><a class="anchor" id="alib_namespace_strings_nonchecking"></a>
'Non-Checking' Methods of ALib String Classes</h1>
<p>Many of the methods found in the different string classes of ALib are template methods with a boolean template parameter named <em>TCheck</em>. This template parameter is defaulted with the value <code>true</code> which is sort of 'hiding' it in normal code. Consider the following piece of code: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> parse( <a class="code" href="classaworx_1_1lib_1_1strings_1_1Substring.html">aworx::Substring</a> line )</div><div class="line">{</div><div class="line">    <span class="comment">// object &#39;line&#39; is of type aworx::Substring</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1TString.html">aworx::TString</a> startWord= <span class="stringliteral">&quot;&lt;start&gt;&quot;</span>;</div><div class="line">    <span class="keywordtype">int</span> idx= line.<a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html#adc427de75c146cf8618a397833edaa9a">IndexOfSubstring</a>( startWord );</div><div class="line">    <span class="keywordflow">if</span>( idx &gt; 0 )</div><div class="line">        line.<a class="code" href="classaworx_1_1lib_1_1strings_1_1Substring.html#aaf59accd324c73fe307fbf81e1c35242">Consume</a>( idx + startWord.<a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html#a6e891964a37680c01e21dedac6ffe670">Length</a>() );</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="comment">//...</span></div></div><!-- fragment --><p> The implementation of method <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html#aaf59accd324c73fe307fbf81e1c35242">Substring::Consume(int)</a> by default checks if object <em>line</em> is big enough to cut the given number of characters from the front. Obviously this check is redundant here, because <b>Consume</b> is invoked only if <b>IndexOfSubstring</b> had found the string <em>"\&lt;start\&gt;"</em>. To avoid the redundant check, we invoke the non-checking version of method <b>Consume</b> by providing template parameter <code>TCheck</code> with value <code>false:</code> </p><div class="fragment"><div class="line">    <span class="keywordflow">if</span>( idx &gt; 0 )</div><div class="line">        line.<a class="code" href="classaworx_1_1lib_1_1strings_1_1Substring.html#aaf59accd324c73fe307fbf81e1c35242">Consume</a>&lt;<span class="keyword">false</span>&gt;( idx + startWord.<a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html#a6e891964a37680c01e21dedac6ffe670">Length</a>() ); <span class="comment">// No check for length of object &#39;line&#39;</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In this simple sample, especially as these methods are inlined, the compiler might detect already that the check is redundant and would remove it from the code. However, there are many occasions where the compiler is lacking the information and the possibility to detect such redundancy.</dd></dl>
<p>In the C# and Java versions of ALib, where such template methods are not available, still some non-checking methods are provided, but less than in the C++ implementation. In these languages, these methods exist twice with the same name, the non-checking one with suffix <em>_NC</em>.</p>
<p>The following general rules apply for all non-checking methods:</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> parameters are not checked for being nullptr.</li>
<li>Index, size, length, region start/end and other parameters are not checked to be correct</li>
<li>If parameters are incorrect, the result of the methods is undefined and an exception/assertion may be raised.</li>
<li>Append methods that in their original version would set a <em>nulled</em> <b>AString</b> to non <em>nulled</em> state in the case that an empty string or string region is appended, are not confirming to this principle in their non-checking version.<br />
 In other words, <em>nulled</em> strings keep being <em>nulled</em> if empty strings are appended.</li>
<li>In the Java and C# versions of ALib, the hash value of an <b>AString</b> object keeps being cached when invoking an <em>_NC</em> method. This may lead to wrong behavior, e.g. when an <b>AString</b> object is used as a key of a hash table. To avoid errors, within a context that makes use of an <b>AStrings'</b> hash value, before each hash code retrieval (C#: <em>GetHashCode()</em>, Java: <em>hashCode()</em>), it has to be certified that at least one of the methods manipulating the object has to be a non <em>_NC</em> method.</li>
</ul>
<p>Apart from the previous points, the behavior and result of invoking a non-checking version of a method is the same as of invoking the original version. The only difference is in a higher execution performance.</p>
<h1><a class="anchor" id="alib_namespace_strings_compat"></a>
Compatibility with External Libraries</h1>
<p>ALib provides compatibility extensions with different class libraries. Currently the following extensions are provided: </p><h2>Standard C++ Library</h2>
<ul>
<li>Trough header file <em>"alib/compatibility/std_string.hpp"</em><ul>
<li>Implements template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7cfd45024bf9222b42febac98fdcc146">ToString</a> to allow (implicit) conversion of objects of type <em>std::string</em> to type <a class="el" href="namespaceaworx.html#ad13481d84c6e592a41d07c64f747c95d">aworx::String</a>.</li>
<li>Implements template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> to allow the concatenation of objects of type <em>std::string</em> to type <a class="el" href="namespaceaworx.html#a51ace28d988aa0a7ab391f6aaec35f60">aworx::AString</a>.</li>
<li>Implements namespace function <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#acee8df0c9711c319807b3661f1046dfd">aworx::lib::strings::ToStdString</a> (with various overloads) to convert an object of type <a class="el" href="namespaceaworx.html#ad13481d84c6e592a41d07c64f747c95d">aworx::String</a> to type <em>std::string</em>.</li>
</ul>
</li>
</ul>
<ul>
<li>Trough header file <em>"alib/compatibility/std_iostream.hpp"</em><ul>
<li>Provides <em>applicable</em> class <a class="el" href="classaworx_1_1lib_1_1strings_1_1ReadLineFromIStream.html">ReadLineFromIStream</a> and corresponding implementation of <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> to allow reading lines of text from a <em>std::istream</em> into an object of type <a class="el" href="namespaceaworx.html#a51ace28d988aa0a7ab391f6aaec35f60">aworx::AString</a>.</li>
<li>Provides namespace functions <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a357b7d2e804cb32ac765641afa415eee">operator&gt;&gt;(std::istream&amp;, AString&amp;)</a> and <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a3b4a073d715b00201505dc87ffdcb73e">operator&gt;&gt;(std::istream*, AString&amp;)</a> which are using aforementioned applicable class <b><a class="el" href="classaworx_1_1lib_1_1strings_1_1ReadLineFromIStream.html">ReadLineFromIStream</a></b> with default parameters to read a line from a <em>std::istream</em> into an object of type <a class="el" href="namespaceaworx.html#a51ace28d988aa0a7ab391f6aaec35f60">aworx::AString</a>.</li>
<li>Provides namespace functions <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7c480abd39fa10f40a8af566cf1f4dda">operator&lt;&lt;(std::ostream&amp; os, const String&amp; as)</a> and <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a9a3fcc93b836b62a2ebbca22d3732520">operator&lt;&lt;(std::ostream* os, const String&amp; as)</a> to write an object of type <a class="el" href="namespaceaworx.html#ad13481d84c6e592a41d07c64f747c95d">aworx::String</a> into a <em>std::ostream</em>.</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Support for other Libraries to come...</dd></dl>
<h1><a class="anchor" id="alib_namespace_strings_debugging"></a>
Debugging ALib String Classes</h1>
<p>In some situations during the development using ALib string classes, some additional debug checking is helpful. Among such situations are:</p><ul>
<li>development of types derived from ALib string types</li>
<li>specializing template functions <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7cfd45024bf9222b42febac98fdcc146">ToString</a> or <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> to add support for user defined string types or formatting operations to class <b>AString</b>.</li>
<li>external manipulation of <b>AString</b> string data</li>
<li>provision of external data buffers to class <b>AString</b> </li>
</ul>
<p>In these and similar situations, it is advised to using the compiler symbol <a class="el" href="group__GrpALibCompilerSymbols.html#ga2992625b88f70b1e01564be4e7eba2fb">ALIB_DEBUG_STRINGS_ON</a>. This enables internal consistency checks with almost any method ALib string invoked. By default this is disabled, as it generates a quite huge drop of runtime performance. When string debugging is enabled, macro ALIB_STRING_DBG_CHK can be used to check the consistancy of ALib string classes. Furthermore, macro <a class="el" href="group__GrpALibStringsMacros.html#gacf96023d903e78f3b5d784a799041667">ALIB_STRING_DBG_UNTERMINATE</a> <em>has to</em> be used when changing the length of a terminatable string without using method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a0c14574ea5ef859e15b51f288c40f5da">AString::SetLength&lt;false&gt;</a> (e.g. in custom, derived classes). </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html">CString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1Format.html">Format</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1IsApplicable.html">IsApplicable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1IsApplicable_3_01const_01lox_1_1core_1_1Logger_01_6_01_4.html">IsApplicable&lt; const lox::core::Logger &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1IsApplicable_3_01const_01std_1_1string_01_6_01_4.html">IsApplicable&lt; const std::string &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1IsTerminatable.html">IsTerminatable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1IsTerminatable_3_01AString_01_4.html">IsTerminatable&lt; AString &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1IsTerminatable_3_01PreallocatedString_3_01TCapacity_01_4_01_4.html">IsTerminatable&lt; PreallocatedString&lt; TCapacity &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">PreallocatedString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1ReadLineFromIStream.html">ReadLineFromIStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1StringLiteral.html">StringLiteral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1TMPLiteral.html">TMPLiteral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1Tokenizer.html">Tokenizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1ToStringDefined.html">ToStringDefined</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1strings_1_1ToStringDefined_3_01const_01std_1_1string_01_6_01_4.html">ToStringDefined&lt; const std::string &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a40af8c9dcfc80a2b4a9e0d50ce506725"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a40af8c9dcfc80a2b4a9e0d50ce506725"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1ReadLineFromIStream.html">ReadLineFromIStream</a> &amp;cparam)</td></tr>
<tr class="separator:a40af8c9dcfc80a2b4a9e0d50ce506725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259d311e0220dbf28a4eb0dcb26b5b2e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a259d311e0220dbf28a4eb0dcb26b5b2e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a259d311e0220dbf28a4eb0dcb26b5b2e">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const wchar_t *src)</td></tr>
<tr class="separator:a259d311e0220dbf28a4eb0dcb26b5b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f19ceb8dc5cb5fb75e0e008fc0b62c9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a4f19ceb8dc5cb5fb75e0e008fc0b62c9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a4f19ceb8dc5cb5fb75e0e008fc0b62c9">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Tab.html">Format::Tab</a> &amp;tab)</td></tr>
<tr class="separator:a4f19ceb8dc5cb5fb75e0e008fc0b62c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefaeb91f4a057ddf48252b58e7f168d"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aeefaeb91f4a057ddf48252b58e7f168d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aeefaeb91f4a057ddf48252b58e7f168d">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Field.html">Format::Field</a> &amp;field)</td></tr>
<tr class="separator:aeefaeb91f4a057ddf48252b58e7f168d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71883c7c0a41a97d63c3606296a07c80"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a71883c7c0a41a97d63c3606296a07c80"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a71883c7c0a41a97d63c3606296a07c80">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int32.html">Format::Int32</a> &amp;fmt)</td></tr>
<tr class="separator:a71883c7c0a41a97d63c3606296a07c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26459c1c77708cf6f56a2419734d9978"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a26459c1c77708cf6f56a2419734d9978"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a26459c1c77708cf6f56a2419734d9978">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1ReadLineFromIStream.html">ReadLineFromIStream</a> &amp;param)</td></tr>
<tr class="separator:a26459c1c77708cf6f56a2419734d9978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a404410b1aaf03e4115c05414d6bbf5"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a9a404410b1aaf03e4115c05414d6bbf5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a9a404410b1aaf03e4115c05414d6bbf5">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt32.html">Format::UInt32</a> &amp;fmt)</td></tr>
<tr class="separator:a9a404410b1aaf03e4115c05414d6bbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f1969f5176f25927efd6c3b869dd69"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a07f1969f5176f25927efd6c3b869dd69"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a07f1969f5176f25927efd6c3b869dd69">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int64.html">Format::Int64</a> &amp;fmt)</td></tr>
<tr class="separator:a07f1969f5176f25927efd6c3b869dd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cbaebe29c1bc6e2147b1c25d6ba6ac"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a10cbaebe29c1bc6e2147b1c25d6ba6ac"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a10cbaebe29c1bc6e2147b1c25d6ba6ac">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt64.html">Format::UInt64</a> &amp;fmt)</td></tr>
<tr class="separator:a10cbaebe29c1bc6e2147b1c25d6ba6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fb47b820e77796083d2c3eb13d56b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8fb47b820e77796083d2c3eb13d56b2"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aa8fb47b820e77796083d2c3eb13d56b2">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const T src)</td></tr>
<tr class="separator:aa8fb47b820e77796083d2c3eb13d56b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3166349c4945294de1c31b25b77da647"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3166349c4945294de1c31b25b77da647"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a3166349c4945294de1c31b25b77da647">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Double.html">Format::Double</a> &amp;fmt)</td></tr>
<tr class="separator:a3166349c4945294de1c31b25b77da647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeb23f90707241659667c910e61bbe9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aaaeb23f90707241659667c910e61bbe9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aaaeb23f90707241659667c910e61bbe9">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const char *src)</td></tr>
<tr class="separator:aaaeb23f90707241659667c910e61bbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d3c0fe2a4125c45c804c1fb1509b3e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a51d3c0fe2a4125c45c804c1fb1509b3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a51d3c0fe2a4125c45c804c1fb1509b3e">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const wchar_t *src)</td></tr>
<tr class="separator:a51d3c0fe2a4125c45c804c1fb1509b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bcfa090927eb989e55774a396d73fd"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af0bcfa090927eb989e55774a396d73fd"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#af0bcfa090927eb989e55774a396d73fd">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, bool &amp;b)</td></tr>
<tr class="separator:af0bcfa090927eb989e55774a396d73fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a7ab6f429b5e5e3361d9758b6807d9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a70a7ab6f429b5e5e3361d9758b6807d9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a70a7ab6f429b5e5e3361d9758b6807d9">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9f3c28a2cb05bdcc618b542e49bfda3f">enums::Switch</a> &amp;value)</td></tr>
<tr class="separator:a70a7ab6f429b5e5e3361d9758b6807d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dfe1060a698974265db6b780c709fa"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a17dfe1060a698974265db6b780c709fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a17dfe1060a698974265db6b780c709fa">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Tab.html">Format::Tab</a> &amp;tab)</td></tr>
<tr class="separator:a17dfe1060a698974265db6b780c709fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99617b411c1009b148f37391abf0d789"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a99617b411c1009b148f37391abf0d789"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a99617b411c1009b148f37391abf0d789">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> &amp;value)</td></tr>
<tr class="separator:a99617b411c1009b148f37391abf0d789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5874b01f193017660c4748a8a5fc1fde"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a5874b01f193017660c4748a8a5fc1fde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a5874b01f193017660c4748a8a5fc1fde">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Field.html">Format::Field</a> &amp;field)</td></tr>
<tr class="separator:a5874b01f193017660c4748a8a5fc1fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fad3de9eb89a67a1bc095c3fd5ffc56"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a9fad3de9eb89a67a1bc095c3fd5ffc56"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a9fad3de9eb89a67a1bc095c3fd5ffc56">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#acdfaca60ec19c0265bac2692d7982726">enums::Alignment</a> &amp;value)</td></tr>
<tr class="separator:a9fad3de9eb89a67a1bc095c3fd5ffc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cf6b7c301dca2c1b7efd7d9cf3fd1a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae7cf6b7c301dca2c1b7efd7d9cf3fd1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#ae7cf6b7c301dca2c1b7efd7d9cf3fd1a">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int32.html">Format::Int32</a> &amp;fmt)</td></tr>
<tr class="separator:ae7cf6b7c301dca2c1b7efd7d9cf3fd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829332713d7be0bbde5b1862e1ec837b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a829332713d7be0bbde5b1862e1ec837b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a829332713d7be0bbde5b1862e1ec837b">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a217539925b78b2eed40ae7817d5bee52">enums::Inclusion</a> &amp;value)</td></tr>
<tr class="separator:a829332713d7be0bbde5b1862e1ec837b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff08105164bdbc38149bdea8526b0fe1"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aff08105164bdbc38149bdea8526b0fe1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aff08105164bdbc38149bdea8526b0fe1">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, int8_t &amp;value)</td></tr>
<tr class="separator:aff08105164bdbc38149bdea8526b0fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380a2e715c58148cf81b7e31c4ef1bd9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a380a2e715c58148cf81b7e31c4ef1bd9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a380a2e715c58148cf81b7e31c4ef1bd9">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4">enums::CurrentData</a> &amp;value)</td></tr>
<tr class="separator:a380a2e715c58148cf81b7e31c4ef1bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e06f646e714741651dbcc70c18f7277"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a4e06f646e714741651dbcc70c18f7277"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a4e06f646e714741651dbcc70c18f7277">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, uint8_t &amp;value)</td></tr>
<tr class="separator:a4e06f646e714741651dbcc70c18f7277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43cf0906d4f7d8f1b6ed6dd6454d361"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af43cf0906d4f7d8f1b6ed6dd6454d361"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#af43cf0906d4f7d8f1b6ed6dd6454d361">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a8c800527afe0a8a6c71ae4cceda6bf9d">enums::Safeness</a> &amp;value)</td></tr>
<tr class="separator:af43cf0906d4f7d8f1b6ed6dd6454d361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa619192ac17ef191b23c4a62c98c6b0e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa619192ac17ef191b23c4a62c98c6b0e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aa619192ac17ef191b23c4a62c98c6b0e">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, int16_t &amp;value)</td></tr>
<tr class="separator:aa619192ac17ef191b23c4a62c98c6b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad795b43f0a24b4c0e6147e223e051546"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad795b43f0a24b4c0e6147e223e051546"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#ad795b43f0a24b4c0e6147e223e051546">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab5305b978950ba3946cf79a4bccbf7af">enums::Responsibility</a> &amp;value)</td></tr>
<tr class="separator:ad795b43f0a24b4c0e6147e223e051546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182592417855344b2161faa31b88745e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a182592417855344b2161faa31b88745e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a182592417855344b2161faa31b88745e">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, uint16_t &amp;value)</td></tr>
<tr class="separator:a182592417855344b2161faa31b88745e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcce3ad139fe6f9c313fdfe9be5fed2"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a0dcce3ad139fe6f9c313fdfe9be5fed2"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a0dcce3ad139fe6f9c313fdfe9be5fed2">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9b1d8f31e178e17a8fef3a9e94bc4b2c">enums::Timezone</a> &amp;value)</td></tr>
<tr class="separator:a0dcce3ad139fe6f9c313fdfe9be5fed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebd14cfce8c2eda7ed1dcbca395a33c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3ebd14cfce8c2eda7ed1dcbca395a33c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a3ebd14cfce8c2eda7ed1dcbca395a33c">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, int32_t &amp;value)</td></tr>
<tr class="separator:a3ebd14cfce8c2eda7ed1dcbca395a33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b71964dfcfc46db8bfe4369a60b48c3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3b71964dfcfc46db8bfe4369a60b48c3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a3b71964dfcfc46db8bfe4369a60b48c3">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a00fc859257c8f09ff9198dde28121961">enums::LockMode</a> &amp;value)</td></tr>
<tr class="separator:a3b71964dfcfc46db8bfe4369a60b48c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af234ce05458a46a76cc5a593041895b3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af234ce05458a46a76cc5a593041895b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#af234ce05458a46a76cc5a593041895b3">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt32.html">Format::UInt32</a> &amp;fmt)</td></tr>
<tr class="separator:af234ce05458a46a76cc5a593041895b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c043f8dd398835f7266e1bb2c630bf"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a59c043f8dd398835f7266e1bb2c630bf"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a59c043f8dd398835f7266e1bb2c630bf">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ad4a46f9fb632511f6be7c53e05f330f7">enums::Whitespaces</a> &amp;value)</td></tr>
<tr class="separator:a59c043f8dd398835f7266e1bb2c630bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0544080e363cd67465fc12539c06c1"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aff0544080e363cd67465fc12539c06c1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aff0544080e363cd67465fc12539c06c1">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, uint32_t &amp;value)</td></tr>
<tr class="separator:aff0544080e363cd67465fc12539c06c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6407ebad387df4da89aeed389e712e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:abe6407ebad387df4da89aeed389e712e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#abe6407ebad387df4da89aeed389e712e">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a55781bd0c78c4e5d47ce433f4eeeee85">enums::Create</a> &amp;value)</td></tr>
<tr class="separator:abe6407ebad387df4da89aeed389e712e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ce4d16395dd82846afb86689c512df"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a68ce4d16395dd82846afb86689c512df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a68ce4d16395dd82846afb86689c512df">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int64.html">Format::Int64</a> &amp;fmt)</td></tr>
<tr class="separator:a68ce4d16395dd82846afb86689c512df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b0f925b58b64d308bc299f3fe25281"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a58b0f925b58b64d308bc299f3fe25281"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a58b0f925b58b64d308bc299f3fe25281">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#aeae0c2d4659a32ef54bd221d1a3da4e6">enums::Propagation</a> &amp;value)</td></tr>
<tr class="separator:a58b0f925b58b64d308bc299f3fe25281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c48317b4a34060b56d3e5c581e509e1"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a0c48317b4a34060b56d3e5c581e509e1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a0c48317b4a34060b56d3e5c581e509e1">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, int64_t &amp;value)</td></tr>
<tr class="separator:a0c48317b4a34060b56d3e5c581e509e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0683fedae1a6920e13588d534152f4da"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a0683fedae1a6920e13588d534152f4da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a0683fedae1a6920e13588d534152f4da">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt64.html">Format::UInt64</a> &amp;fmt)</td></tr>
<tr class="separator:a0683fedae1a6920e13588d534152f4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e8c17181156fa7a4a2f3cb94dc15a3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac2e8c17181156fa7a4a2f3cb94dc15a3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#ac2e8c17181156fa7a4a2f3cb94dc15a3">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, uint64_t &amp;value)</td></tr>
<tr class="separator:ac2e8c17181156fa7a4a2f3cb94dc15a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a951e16433abb2461bca80d0c2ad8e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad9a951e16433abb2461bca80d0c2ad8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#ad9a951e16433abb2461bca80d0c2ad8e">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Double.html">Format::Double</a> &amp;fmt)</td></tr>
<tr class="separator:ad9a951e16433abb2461bca80d0c2ad8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc006ddec9bb08e63d7e764a785e715b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:abc006ddec9bb08e63d7e764a785e715b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#abc006ddec9bb08e63d7e764a785e715b">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, double &amp;value)</td></tr>
<tr class="separator:abc006ddec9bb08e63d7e764a785e715b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0aaba9060d3dd6bcb3914d2b7cc538"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aef0aaba9060d3dd6bcb3914d2b7cc538"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#aef0aaba9060d3dd6bcb3914d2b7cc538">ApplyTo</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, float &amp;value)</td></tr>
<tr class="separator:aef0aaba9060d3dd6bcb3914d2b7cc538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9293db3b9b449a46d07d91e1b8964183"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a9293db3b9b449a46d07d91e1b8964183"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a9293db3b9b449a46d07d91e1b8964183">ApplyTo&lt; const lox::core::Logger &amp; &gt;</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const <a class="el" href="classaworx_1_1lox_1_1core_1_1Logger.html">lox::core::Logger</a> &amp;logger)</td></tr>
<tr class="separator:a9293db3b9b449a46d07d91e1b8964183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d2b8074d6fd76918018ca6704e7cfc"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a46d2b8074d6fd76918018ca6704e7cfc"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a46d2b8074d6fd76918018ca6704e7cfc">ApplyTo&lt; const std::string &amp; &gt;</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const std::string &amp;src)</td></tr>
<tr class="separator:a46d2b8074d6fd76918018ca6704e7cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd4a1d202f1c13b510ec14cd55d3a7a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abcd4a1d202f1c13b510ec14cd55d3a7a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#abcd4a1d202f1c13b510ec14cd55d3a7a">ApplyTo_NC</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const T src)</td></tr>
<tr class="separator:abcd4a1d202f1c13b510ec14cd55d3a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8de1e5cfd3f85418261ced125aed661"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac8de1e5cfd3f85418261ced125aed661"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#ac8de1e5cfd3f85418261ced125aed661">ApplyTo_NC&lt; const std::string &amp; &gt;</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;target, const std::string &amp;src)</td></tr>
<tr class="separator:ac8de1e5cfd3f85418261ced125aed661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c480abd39fa10f40a8af566cf1f4dda"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7c480abd39fa10f40a8af566cf1f4dda">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;string)</td></tr>
<tr class="separator:a7c480abd39fa10f40a8af566cf1f4dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3fcc93b836b62a2ebbca22d3732520"><td class="memItemLeft" align="right" valign="top">std::ostream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a9a3fcc93b836b62a2ebbca22d3732520">operator&lt;&lt;</a> (std::ostream *stream, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;string)</td></tr>
<tr class="separator:a9a3fcc93b836b62a2ebbca22d3732520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357b7d2e804cb32ac765641afa415eee"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a357b7d2e804cb32ac765641afa415eee">operator&gt;&gt;</a> (std::istream &amp;stream, <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;string)</td></tr>
<tr class="separator:a357b7d2e804cb32ac765641afa415eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4a073d715b00201505dc87ffdcb73e"><td class="memItemLeft" align="right" valign="top">std::istream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a3b4a073d715b00201505dc87ffdcb73e">operator&gt;&gt;</a> (std::istream *stream, <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;string)</td></tr>
<tr class="separator:a3b4a073d715b00201505dc87ffdcb73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee8df0c9711c319807b3661f1046dfd"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#acee8df0c9711c319807b3661f1046dfd">ToStdString</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;as, std::string &amp;target, int regionStart, int regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4">enums::CurrentData</a> targetData=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4adc30bc0c7914db5918da4263fce93ad2">enums::CurrentData::Clear</a>)</td></tr>
<tr class="separator:acee8df0c9711c319807b3661f1046dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69456b076a8fce4982a9d3790796d424"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a69456b076a8fce4982a9d3790796d424">ToStdString</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;as, int regionStart, int regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>)</td></tr>
<tr class="separator:a69456b076a8fce4982a9d3790796d424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039f938c7e403c09e0271e4f353123bf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a039f938c7e403c09e0271e4f353123bf">ToStdString</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;as)</td></tr>
<tr class="separator:a039f938c7e403c09e0271e4f353123bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1c5a17c57b3b54f2f46e58bef50487"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a8f1c5a17c57b3b54f2f46e58bef50487">ToStdString</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;as, std::string &amp;target, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4">enums::CurrentData</a> targetData=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4adc30bc0c7914db5918da4263fce93ad2">enums::CurrentData::Clear</a>)</td></tr>
<tr class="separator:a8f1c5a17c57b3b54f2f46e58bef50487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfd45024bf9222b42febac98fdcc146"><td class="memTemplParams" colspan="2">template&lt;typename TString , typename TReturn &gt; </td></tr>
<tr class="memitem:a7cfd45024bf9222b42febac98fdcc146"><td class="memTemplItemLeft" align="right" valign="top">TReturn&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7cfd45024bf9222b42febac98fdcc146">ToString</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a>)</td></tr>
<tr class="separator:a7cfd45024bf9222b42febac98fdcc146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d85e610e17c69e9ece8b558735519e0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8d85e610e17c69e9ece8b558735519e0"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a8d85e610e17c69e9ece8b558735519e0">ToString&lt; const std::string &amp; &gt;</a> (const std::string &amp;src)</td></tr>
<tr class="separator:a8d85e610e17c69e9ece8b558735519e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fc15801fea6b54738ca715ed192cf0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae0fc15801fea6b54738ca715ed192cf0"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html#ae0fc15801fea6b54738ca715ed192cf0">ToString&lt; const std::string &amp; &gt;</a> (const std::string &amp;src)</td></tr>
<tr class="separator:ae0fc15801fea6b54738ca715ed192cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a40af8c9dcfc80a2b4a9e0d50ce506725"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1ReadLineFromIStream.html">ReadLineFromIStream</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1ReadLineFromIStream.html">ReadLineFromIStream</a>. If the end of the input stream was reached, field <a class="el" href="classaworx_1_1lib_1_1strings_1_1ReadLineFromIStream.html#ade6dbc4e4f8e0b45e0fbe023f5ed8ddd">IsEOF</a> of parameter <code>param</code> will be set to <code>true</code> what indicates that a next read operation would fail. </p><dl class="section note"><dt>Note</dt><dd>For setting field <em>IsEOF</em> the object will be casted to a non-constant reference. See <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for an explanation why it is OK to do so.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> object to read into. </td></tr>
    <tr><td class="paramname">param</td><td>The object holding the <b>std::istream</b> and some parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a259d311e0220dbf28a4eb0dcb26b5b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> This method converts the provided wide character string (zero-terminated array of wchar_t) and appends it to the <code>target</code>. The conversion is done using</p><ul>
<li><em>wcsnrtombs</em> on glibc platforms (e.g. Linux)</li>
<li><em>WideCharToMultiByte(CP_UTF8,...)</em> on Windows platform. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">src</td><td>The wide character string to append to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a4f19ceb8dc5cb5fb75e0e008fc0b62c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Tab.html">Format::Tab</a> &amp;&#160;</td>
          <td class="paramname"><em>tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Tab.html">Format::Tab</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">tab</td><td>The object to <em>apply</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="aeefaeb91f4a057ddf48252b58e7f168d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Field.html">Format::Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Field.html">Format::Field</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">field</td><td>The object to <em>apply</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a71883c7c0a41a97d63c3606296a07c80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int32.html">Format::Int32</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int32.html">Format::Int32</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">fmt</td><td>The format object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a26459c1c77708cf6f56a2419734d9978"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1ReadLineFromIStream.html">ReadLineFromIStream</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1ReadLineFromIStream.html">ReadLineFromIStream</a>. If the end of the input stream was reached, field <a class="el" href="classaworx_1_1lib_1_1strings_1_1ReadLineFromIStream.html#ade6dbc4e4f8e0b45e0fbe023f5ed8ddd">IsEOF</a> of parameter <code>param</code> will be set to <code>true</code> what indicates that a next read operation would fail. </p><dl class="section note"><dt>Note</dt><dd>For setting field <em>IsEOF</em> the object will be casted to a non-constant reference. See <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for an explanation why it is OK to do so.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> object to read into. </td></tr>
    <tr><td class="paramname">param</td><td>The object holding the <b>std::istream</b> and some parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a404410b1aaf03e4115c05414d6bbf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt32.html">Format::UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt32.html">Format::UInt32</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">fmt</td><td>The format object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a07f1969f5176f25927efd6c3b869dd69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int64.html">Format::Int64</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int64.html">Format::Int64</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">fmt</td><td>The format object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a10cbaebe29c1bc6e2147b1c25d6ba6ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt64.html">Format::UInt64</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt64.html">Format::UInt64</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">fmt</td><td>The format object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8fb47b820e77796083d2c3eb13d56b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This template function supports applying 'external' user defined types to objects of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>. It has a central role for using ALib in a <a class="el" href="namespaceaworx_1_1lib.html">non intrusive</a> way, by allowing to pass external string types just as the are when appending them to objects of type AString. Furthermore, a list of built-in operations on objects of type AString are implemented using the mechanism provided with this function and new, custom operations might be defined.</p>
<p>Partially specialized versions of this method are invoked by method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4dbe5fba1e5c5ed69d12d57b3eb49ef7">AString::Apply</a> with template parameter <code>src</code>.</p>
<p>To restrict the need for specializations of this method to a single variant of the external type, template type <code>T</code> will always be a "constant reference". As an example, if the external type was '<em>class MyString&gt;</em>' and a non-constant pointer to an object of that type was applied to an AString, the template parameter <code>T</code> would still be '<em>const MyString &amp;</em>'.</p>
<dl class="section note"><dt>Note</dt><dd>Some more complex applicable types might want to return extended information by setting own members during the application process. To achieve this, the corresponding implementations of <b>ApplyTo</b> have to cast the given const reference to a non-const reference. This is considered a good practice, as the const specifier most probably was added by the TMP operations of method <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#a4dbe5fba1e5c5ed69d12d57b3eb49ef7">AString::Apply</a> anyhow only for the reason to have one single template specialization per type.</dd></dl>
<p>The implementation itself may do 'whatever' is wanted' with the AString provided in parameter <code>target</code>. For string types, simple append operations are predefined. More complex operations format the string, convert integer and floating point numbers, etc.</p>
<p>For allowing static (compile time) assertions when user code tries to apply arbitrary types that are not supported with specializations of this method, it is necessary to implement struct <a class="el" href="structaworx_1_1lib_1_1strings_1_1IsApplicable.html">IsApplicable</a> whenever this method is specialized.</p>
<p>Optionally it is possible to also implement a sibling template function <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#abcd4a1d202f1c13b510ec14cd55d3a7a">ApplyTo_NC</a>. If function <em>ApplyTo_NC</em> is specialized in parallel to a specialization of this function, <em>ApplyTo_NC</em> will be used if a non-checking method of class AString is used to apply an object. See <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#alib_namespace_strings_nonchecking">'Non-Checking' Methods of ALib String Classes</a> for more information.</p>
<p>For basic user defined string types that get adopted to ALib string system using function <em>ToString</em>, it is advisable to also generate a specialization of this function and of struct <em>IsApplicable</em>. Therefore, the sample provided with method <em>ToString</em> demonstrates also this function. See template function <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7cfd45024bf9222b42febac98fdcc146">ToString</a> for that sample.</p>
<p>Built-in specializations of this function and according type definitions exist, as listed in reference documentation of class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>. As a sample, one type and according specialization is class <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Field.html">Format::Field</a>. The invocation is simple and nicely readable: </p><div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> centered;</div><div class="line">centered &lt;&lt; <span class="charliteral">&#39;*&#39;</span> &lt;&lt; Format::Field( <span class="stringliteral">&quot;Hello&quot;</span>, 15, Alignment::Center ) &lt;&lt; <span class="charliteral">&#39;*&#39;</span>;</div><div class="line">cout &lt;&lt; centered &lt;&lt; endl;</div></div><!-- fragment --><p> which produces: </p><div class="fragment"><div class="line">*     Hello     *</div></div><!-- fragment --><p> The next sample implements this function for ALib class <a class="el" href="classaworx_1_1lib_1_1time_1_1Ticks.html">Ticks</a> to print out a formatted date: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="alib_8hpp.html">alib/alib.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ticks_8hpp.html">alib/time/ticks.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// get support for  ostream operator&lt;&lt;() on String objects</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="std__string_8hpp.html">alib/compatibility/std_string.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="std__iostream_8hpp.html">alib/compatibility/std_iostream.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceaworx.html">aworx</a>;</div><div class="line"></div><div class="line"><span class="comment">// Partial template function implementation of ApplyTo for objects of type class Ticks</span></div><div class="line"><span class="comment">// (has to be declared in namespace aworx::lib::strings)</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceaworx.html">aworx</a> { <span class="keyword">namespace </span>lib { <span class="keyword">namespace </span>strings {</div><div class="line"></div><div class="line">    <span class="comment">// we have to define the helper struct IsApplicable. Its whole reason of existence is</span></div><div class="line">    <span class="comment">// to be able to throw compile time errors for types that do not have an ApplyTo</span></div><div class="line">    <span class="comment">// specialization</span></div><div class="line">    <span class="keyword">template</span>&lt;&gt;  <span class="keyword">struct       </span>IsApplicable&lt;const <a class="code" href="namespaceaworx.html">aworx</a>::<a class="code" href="classaworx_1_1lib_1_1time_1_1Ticks.html">lib::time::Ticks</a>&amp;&gt; : <span class="keyword">public</span> std::true_type {};</div><div class="line"></div><div class="line">    <span class="comment">// And now the ApplyTo specialization itself</span></div><div class="line">    <span class="keyword">template</span>&lt;&gt;  <span class="keyword">inline</span>   <span class="keywordtype">int</span> <a class="code" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a>( <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; target, <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1time_1_1Ticks.html">aworx::lib::time::Ticks</a>&amp; ticks )</div><div class="line">    {</div><div class="line">        <a class="code" href="namespaceaworx.html#a0607ccd659418fa7cb9922b2c4ba5f1d">time::TicksCalendarTime</a> calendarTime;</div><div class="line">        calendarTime.<a class="code" href="classaworx_1_1lib_1_1time_1_1TicksCalendarTime.html#aede0204d6bf28f6b7f2546f0d8c6370d">Set</a>( ticks, Timezone::UTC );</div><div class="line">        calendarTime.Format( <span class="stringliteral">&quot;yyyy-MM-dd HH:mm&quot;</span>, target );</div><div class="line">        <span class="keywordflow">return</span> 16; <span class="comment">// The exact number not too relevant. But has to be &gt; 0 if something was written!</span></div><div class="line">    }</div><div class="line"></div><div class="line">}}} <span class="comment">// closing namespace</span></div></div><!-- fragment --><p> With this definition included, user code might now do this: </p><div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> sample( <span class="stringliteral">&quot;Today is: &quot;</span> );</div><div class="line">sample &lt;&lt;  <a class="code" href="namespaceaworx.html#ad270463709a4ae7e7098df40e803e458">Ticks</a>();</div><div class="line">cout &lt;&lt; sample &lt;&lt; endl;</div></div><!-- fragment --><p> The output will be something like this:</p>
<div class="fragment"><div class="line">Today is: 2016-04-19 12:12</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>This sample is kept simple. In real life, class <a class="el" href="classaworx_1_1lib_1_1time_1_1TicksCalendarTime.html">TicksCalendarTime</a> should be used to implement more options.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object of type AString that will have object <code>src</code> applied. </td></tr>
    <tr><td class="paramname">src</td><td>The source object of arbitrary type will get applied to AString <code>target</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an append operation is implemented with a specialization, the number of characters that got appended should be returned ('should' here means that at least a non zero, positive value has to be returned) and -1 if the object <code>src</code> which is to be applied represented a <em>nulled</em> object. Returning -1 causes the <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> to be <em>nulled</em> if the apply operation was invoked through <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html#ab5e4f0275095724f12cb477527d2f33b">AString assignment operator</a>.</dd></dl>
<p>If nothing is supposed to be append, this method must return 0. </p>

</div>
</div>
<a class="anchor" id="a3166349c4945294de1c31b25b77da647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Double.html">Format::Double</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Double.html">Format::Double</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">fmt</td><td>The format object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="aaaeb23f90707241659667c910e61bbe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes a cstring to the given <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">src</td><td>The character string to append to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a51d3c0fe2a4125c45c804c1fb1509b3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> This method converts the provided wide character string (zero-terminated array of wchar_t) and appends it to the <code>target</code>. The conversion is done using</p><ul>
<li><em>wcsnrtombs</em> on glibc platforms (e.g. Linux)</li>
<li><em>WideCharToMultiByte(CP_UTF8,...)</em> on Windows platform. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">src</td><td>The wide character string to append to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="af0bcfa090927eb989e55774a396d73fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the words "true" or "false" to the given <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">b</td><td>The boolean to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a70a7ab6f429b5e5e3361d9758b6807d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9f3c28a2cb05bdcc618b542e49bfda3f">enums::Switch</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the values of enum class <b>Switch</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a17dfe1060a698974265db6b780c709fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Tab.html">Format::Tab</a> &amp;&#160;</td>
          <td class="paramname"><em>tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Tab.html">Format::Tab</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">tab</td><td>The object to <em>apply</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a99617b411c1009b148f37391abf0d789"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the values of enum class <b>Case</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a5874b01f193017660c4748a8a5fc1fde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Field.html">Format::Field</a> &amp;&#160;</td>
          <td class="paramname"><em>field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Field.html">Format::Field</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">field</td><td>The object to <em>apply</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fad3de9eb89a67a1bc095c3fd5ffc56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#acdfaca60ec19c0265bac2692d7982726">enums::Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the values of enum class <b>Alignment</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7cf6b7c301dca2c1b7efd7d9cf3fd1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int32.html">Format::Int32</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int32.html">Format::Int32</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">fmt</td><td>The format object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a829332713d7be0bbde5b1862e1ec837b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a217539925b78b2eed40ae7817d5bee52">enums::Inclusion</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the values of enum class <b>Inclusion</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="aff08105164bdbc38149bdea8526b0fe1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <em>int8_t</em>. Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int32.html">Format::Int32(value, 1)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a380a2e715c58148cf81b7e31c4ef1bd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4">enums::CurrentData</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the values of enum class <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4">CurrentData</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e06f646e714741651dbcc70c18f7277"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <em>uint8_t</em>. Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int32.html">Format::Int32(value, 1)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="af43cf0906d4f7d8f1b6ed6dd6454d361"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a8c800527afe0a8a6c71ae4cceda6bf9d">enums::Safeness</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the values of enum class <b>Safeness</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="aa619192ac17ef191b23c4a62c98c6b0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <em>int16_t</em>. Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int32.html">Format::Int32(value, 1)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="ad795b43f0a24b4c0e6147e223e051546"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab5305b978950ba3946cf79a4bccbf7af">enums::Responsibility</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the values of enum class <b>Responsibility</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a182592417855344b2161faa31b88745e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <em>uint16_t</em>. Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int32.html">Format::Int32(value, 1)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a0dcce3ad139fe6f9c313fdfe9be5fed2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9b1d8f31e178e17a8fef3a9e94bc4b2c">enums::Timezone</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the values of enum class <b>Timezone</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ebd14cfce8c2eda7ed1dcbca395a33c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <em>int32_t</em>. Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int32.html">Format::Int32(value, 1)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b71964dfcfc46db8bfe4369a60b48c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a00fc859257c8f09ff9198dde28121961">enums::LockMode</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the values of enum class <b>LockMode</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="af234ce05458a46a76cc5a593041895b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt32.html">Format::UInt32</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt32.html">Format::UInt32</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">fmt</td><td>The format object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a59c043f8dd398835f7266e1bb2c630bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ad4a46f9fb632511f6be7c53e05f330f7">enums::Whitespaces</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the values of enum class <b>Whitespaces</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="aff0544080e363cd67465fc12539c06c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <em>uint32_t</em>. Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt32.html">Format::UInt32(value, 1)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="abe6407ebad387df4da89aeed389e712e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a55781bd0c78c4e5d47ce433f4eeeee85">enums::Create</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the values of enum class <b>Create</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a68ce4d16395dd82846afb86689c512df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int64.html">Format::Int64</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int64.html">Format::Int64</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">fmt</td><td>The format object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a58b0f925b58b64d308bc299f3fe25281"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#aeae0c2d4659a32ef54bd221d1a3da4e6">enums::Propagation</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Writes the values of enum class <b>Propagation</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to <code>target</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c48317b4a34060b56d3e5c581e509e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <em>int64_t</em>. Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Int64.html">Format::Int64(value, 1)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a0683fedae1a6920e13588d534152f4da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt64.html">Format::UInt64</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt64.html">Format::UInt64</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">fmt</td><td>The format object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2e8c17181156fa7a4a2f3cb94dc15a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <em>uint64_t</em>. Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1UInt64.html">Format::UInt64(value, 1)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9a951e16433abb2461bca80d0c2ad8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Double.html">Format::Double</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Double.html">Format::Double</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">fmt</td><td>The format object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="abc006ddec9bb08e63d7e764a785e715b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <em>double</em>. Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Double.html">Format::Double(value, nullptr)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="aef0aaba9060d3dd6bcb3914d2b7cc538"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int aworx::lib::strings::ApplyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <em>float</em>. Invokes <a class="el" href="classaworx_1_1lib_1_1strings_1_1Format_1_1Double.html">Format::Double(value, nullptr)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object that <b>Apply</b> was invoked on. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters appended to target. </dd></dl>

</div>
</div>
<a class="anchor" id="a9293db3b9b449a46d07d91e1b8964183"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">aworx::lib::strings::ApplyTo</a>&lt; const <a class="el" href="classaworx_1_1lox_1_1core_1_1Logger.html">lox::core::Logger</a> &amp; &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lox_1_1core_1_1Logger.html">lox::core::Logger</a> &amp;&#160;</td>
          <td class="paramname"><em>logger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <b>std::string</b>. See <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for more information </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> to append <code>src</code> to. </td></tr>
    <tr><td class="paramname">logger</td><td>The logger to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the given string <code>src</code> which was appended to <code>target</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a46d2b8074d6fd76918018ca6704e7cfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">aworx::lib::strings::ApplyTo</a>&lt; const std::string &amp; &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for applicable type <b>std::string</b>. See <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for more information </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> to append <code>src</code> to. </td></tr>
    <tr><td class="paramname">src</td><td>The source string to take the buffer from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the given string <code>src</code> which was appended to <code>target</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="abcd4a1d202f1c13b510ec14cd55d3a7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ApplyTo_NC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This function can be optionally specialized for dedicated types, next to function <b>ApplyTo</b>. See <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The object of type AString that will get object <code>src</code> applied. </td></tr>
    <tr><td class="paramname">src</td><td>The object of type arbitrary type will get applied to AString <code>target</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If an append operation is implemented with a specialization, the number of characters that got appended should be returned and -1 if the object <code>src</code> to apply represented a <em>nulled</em> object. I nothing is supposed to be append, this method must return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8de1e5cfd3f85418261ced125aed661"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#abcd4a1d202f1c13b510ec14cd55d3a7a">aworx::lib::strings::ApplyTo_NC</a>&lt; const std::string &amp; &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Specialization of (optional) non-checking version of template method <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#abcd4a1d202f1c13b510ec14cd55d3a7a">ApplyTo_NC</a> for applicable type <b>std::string</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> to append <code>src</code> to. </td></tr>
    <tr><td class="paramname">src</td><td>The source string to take the buffer from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the given string <code>src</code> which was appended to <code>target</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c480abd39fa10f40a8af566cf1f4dda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; aworx::lib::strings::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Copies the contents of the given String to into the std::ostream given as reference. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The ostream object to write the given <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> into. </td></tr>
    <tr><td class="paramname">string</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> to write into the given ostream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ostream to allow concatenated operations. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a3fcc93b836b62a2ebbca22d3732520"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream* aworx::lib::strings::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Copies the contents of the given String to into the std::ostream given as pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The ostream object to write the given <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> into. </td></tr>
    <tr><td class="paramname">string</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> to write into the given ostream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ostream to allow concatenated operations. </dd></dl>

</div>
</div>
<a class="anchor" id="a357b7d2e804cb32ac765641afa415eee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; aworx::lib::strings::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Clears the given AString and extracts data from the std::istream into it. The extractions ends with either the end of the std::istream or when reading a newline character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The istream object to extract data from. </td></tr>
    <tr><td class="paramname">string</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> to receive data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ostream to allow concatenated operations. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b4a073d715b00201505dc87ffdcb73e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream* aworx::lib::strings::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> &amp;&#160;</td>
          <td class="paramname"><em>string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Clears the given AString and extracts data from the std::istream into it. The extractions ends with either the end of the std::istream or when reading a newline character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The istream object to extract data from. </td></tr>
    <tr><td class="paramname">string</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> to receive data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ostream to allow concatenated operations. </dd></dl>

</div>
</div>
<a class="anchor" id="acee8df0c9711c319807b3661f1046dfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; aworx::lib::strings::ToStdString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4">enums::CurrentData</a>&#160;</td>
          <td class="paramname"><em>targetData</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4adc30bc0c7914db5918da4263fce93ad2">enums::CurrentData::Clear</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Copies or appends a region of a given <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> into a std::string. The region is adjusted to the length of the String.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> to convert into a std::string. </td></tr>
    <tr><td class="paramname">target</td><td>A result std::string to copy the specified region into. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start index of the region to be copied. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The maximum length of the region to be copied. Defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>. </td></tr>
    <tr><td class="paramname">targetData</td><td>If <code>CurrentData::Keep</code>, the target <code>std::string</code> is not cleared before the result is written. Defaults to <code><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4adc30bc0c7914db5918da4263fce93ad2" title="Chooses to clear existing data. ">CurrentData::Clear</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (modified) std::string&amp; result that was provided (for concatenation of calls). </dd></dl>

</div>
</div>
<a class="anchor" id="a69456b076a8fce4982a9d3790796d424"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string aworx::lib::strings::ToStdString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regionLength</em> = <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Copies a region of a given <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> into a std::string which is created. The region is adjusted to the length of the String.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> to convert into a std::string. </td></tr>
    <tr><td class="paramname">regionStart</td><td>The start index of the region in this to create the std::string from. </td></tr>
    <tr><td class="paramname">regionLength</td><td>The maximum length of the region to be copied. Defaults to <a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that represents the specified sub region of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a039f938c7e403c09e0271e4f353123bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string aworx::lib::strings::ToStdString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>as</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Copies the contents of a given <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> into the given std::string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> to convert into a std::string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string that represents this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f1c5a17c57b3b54f2f46e58bef50487"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string&amp; aworx::lib::strings::ToStdString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4">enums::CurrentData</a>&#160;</td>
          <td class="paramname"><em>targetData</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4adc30bc0c7914db5918da4263fce93ad2">enums::CurrentData::Clear</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Copies the contents of a given <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> into the given std::string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> to convert into a std::string. </td></tr>
    <tr><td class="paramname">target</td><td>A target std::string to copy the contents of this String into. </td></tr>
    <tr><td class="paramname">targetData</td><td>If <code>CurrentData::Keep</code>, parameter <code>target</code> is not cleared before the result is written. Defaults to <code><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a9345007d67faa05253932092d54d10d4adc30bc0c7914db5918da4263fce93ad2" title="Chooses to clear existing data. ">CurrentData::Clear</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (modified) result that was provided (for concatenation of calls). </dd></dl>

</div>
</div>
<a class="anchor" id="a7cfd45024bf9222b42febac98fdcc146"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TReturn aworx::lib::strings::ToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This template function supports converting 'external' <em>user defined</em> to ALib string <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a>. It has a central role for using ALib in a <a class="el" href="namespaceaworx_1_1lib.html">non intrusive</a> way, by allowing to pass external string types just as the are when invoking ALib functions and methods.</p>
<p>Partially specialized versions of this method are invoked by constructor <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a2b1f593a0b9b71d210993cea0727b419">String(const T&amp;)</a> with template parameters <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a></code> and <code>TReturn</code> set to receive a pointer to the character buffer and the length of the external string type.</p>
<p>The type of the (external) string is given in parameter <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a></code>. To restrict need for specializations of this method to a single variant of the external type, <code>TSTring</code> will always be a "constant reference". As an example, if the external type was '<em>class MyString&gt;</em>' and a non-constant pointer to an object of that type was used to construct an String, the template parameter <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a></code> would be '<em>const MyString &amp;</em>'.</p>
<p>The second type that is given in parameter <code>TReturn</code> has two possible values when invoked from the constructor r of class String:</p><ul>
<li>'<em>const char*</em>' for returning the string buffer</li>
<li>'<em>int</em>' for returning the strings length</li>
</ul>
<p>This way, exactly two specializations of this template method <em>ToString</em> have to be provided when using ALib with external types: Both with <code><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a></code> being a constant reference to the user defined type, one with <code>TReturn</code> being <em>int</em>, the other with <code>TReturn</code> being <em>const char*</em>.</p>
<p>Finally, for allowing static (compile time) assertions when user code tries to provide arbitrary types to <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a2b1f593a0b9b71d210993cea0727b419">String(const T&amp;)</a> that are not supported with specializations of this method, it is necessary to implement <a class="el" href="structaworx_1_1lib_1_1strings_1_1ToStringDefined.html">ToStringDefined</a> for the external type as well.</p>
<p>The following sample demonstrates this. Please note, that the sample in addition provides an implementation of <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a>. This is a similar mechanism for 'applying' user defined string types to class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>. The general term '<em>applying to</em>' for external string types normally is implemented in a way that it means '<em>append to</em>'.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="alib_8hpp.html">alib/alib.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="std__iostream_8hpp.html">alib/compatibility/std_iostream.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// get support for using std::strings with ALib strings</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="std__string_8hpp.html">alib/compatibility/std_string.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceaworx.html">aworx</a>;</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// user defined string class sample</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">namespace </span>myns</div><div class="line">{</div><div class="line">    <span class="keyword">class </span>MyString</div><div class="line">    {</div><div class="line">        <span class="keyword">private</span>:</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">char</span>* theString= <span class="stringliteral">&quot;This is my string!&quot;</span>;</div><div class="line"></div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            <span class="keyword">inline</span>     <span class="keywordtype">bool</span>         IsNulled   ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div><div class="line">            constexpr  <span class="keyword">const</span> <span class="keywordtype">char</span>*  GetMyBuffer()<span class="keyword"> const </span>{ <span class="keywordflow">return</span>               theString;   }</div><div class="line">            <span class="keyword">inline</span>     <span class="keywordtype">int</span>          GetMyLength()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) strlen( theString ); }</div><div class="line">    };</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Partial template method implementation (has to be declared in namespace aworx::lib::strings)</span></div><div class="line"><span class="comment">// Use &quot;constexpr&quot; when possible, otherwise &quot;inline&quot;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceaworx.html">aworx</a> { <span class="keyword">namespace </span>lib { <span class="keyword">namespace </span>strings {</div><div class="line"></div><div class="line">    <span class="comment">// specialize ToStringDefined, to enable static_assert in String construction to success for MyString class</span></div><div class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct              </span>ToStringDefined &lt;const myns::MyString&amp;&gt; : <span class="keyword">public</span> std::true_type {};</div><div class="line"></div><div class="line">    <span class="comment">// the two implementations of ToString. One for providing the buffer, one for the length</span></div><div class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span>  <span class="keyword">const</span> <span class="keywordtype">char</span>* ToString        &lt;const myns::MyString&amp;&gt;( <span class="keyword">const</span> myns::MyString&amp; src )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span>  src.GetMyBuffer();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span>  <span class="keywordtype">int</span>         ToString        &lt;const myns::MyString&amp;&gt;( <span class="keyword">const</span> myns::MyString&amp; src )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span>  src.GetMyLength();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// to be capable of also using MyString for append operations with class AString, we</span></div><div class="line">    <span class="comment">// do a similar partial template method implementation for AString.</span></div><div class="line">    <span class="comment">// (These two usually go together)</span></div><div class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct              </span>IsApplicable&lt;const myns::MyString&amp;&gt; : <span class="keyword">public</span> std::true_type {};</div><div class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span>  <span class="keywordtype">int</span>         <a class="code" href="namespaceaworx_1_1lib_1_1strings.html#a40af8c9dcfc80a2b4a9e0d50ce506725">ApplyTo</a>( <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>&amp; target, <span class="keyword">const</span> myns::MyString&amp; src )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> ( src.IsNulled() )</div><div class="line">            <span class="keywordflow">return</span> -1;</div><div class="line"></div><div class="line">        target.<a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html#a45cb08597c96cf62edb8ece124d8e4fc">Append</a>&lt;<span class="keyword">false</span>&gt;( src.GetMyBuffer(), src.GetMyLength() );</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> src.GetMyLength();</div><div class="line">    }</div><div class="line"></div><div class="line">}}} <span class="comment">// namespace aworx::lib::strings</span></div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Defining a test method that takes a const reference to String</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Print( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a>&amp; text )</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Print: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Using it</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keywordtype">void</span> MyFunction()</div><div class="line">{</div><div class="line">    <span class="comment">// using method Print with core string types</span></div><div class="line">    Print( <span class="stringliteral">&quot;From string literal (no strlen() performed)&quot;</span> );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* cc= <span class="stringliteral">&quot;From &#39;char *&#39; (strlen() is performed)&quot;</span>;</div><div class="line">    Print( cc );</div><div class="line"></div><div class="line">    <span class="comment">// using method Print with std::string types. This is possible, because we included</span></div><div class="line">    <span class="comment">// &quot;alib/compatibility/std_string.hpp&quot; above</span></div><div class="line">    std::string std_string( <span class="stringliteral">&quot;From std::string&quot;</span> );</div><div class="line">    Print( std_string );</div><div class="line"></div><div class="line">    <span class="comment">// using method Print with MyString</span></div><div class="line">    myns::MyString myString;</div><div class="line">    Print( myString );</div><div class="line"></div><div class="line">    <span class="comment">// ...this also works with pointers</span></div><div class="line">    Print( &amp;myString );</div><div class="line"></div><div class="line">    <span class="comment">// Now, as we have also implemented &quot;IsApplicable&quot; and &quot;ApplyTo&quot; for MyString, we can easily</span></div><div class="line">    <span class="comment">// append them to objects of class AString</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> as;</div><div class="line">    as.<a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html#a05403e545a0fa8171456199085790c1c">_</a>(myString);</div><div class="line">    as &lt;&lt; myString;</div><div class="line">    as &lt;&lt; &amp;myString; <span class="comment">// again, works with pointers</span></div><div class="line">}</div></div><!-- fragment --><p> The output will be: </p><div class="fragment"><div class="line">Print: From <span class="keywordtype">string</span> literal (no strlen() performed)</div><div class="line">Print: From &#39;<span class="keywordtype">char</span> *&#39; (strlen() is performed)</div><div class="line">Print: From <a class="code" href="namespacestd.html">std</a>::<span class="keywordtype">string</span></div><div class="line">Print: This is my <span class="keywordtype">string</span>!</div><div class="line">Print: This is my <span class="keywordtype">string</span>!</div></div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Has to return a pointer to the buffer of object of type T, respectively its length. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d85e610e17c69e9ece8b558735519e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7cfd45024bf9222b42febac98fdcc146">aworx::lib::strings::ToString</a>&lt; const std::string &amp; &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template function <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7cfd45024bf9222b42febac98fdcc146">ToString</a> for type <b>std::string</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source string to take the buffer from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <em>src.c_str()</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0fc15801fea6b54738ca715ed192cf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7cfd45024bf9222b42febac98fdcc146">aworx::lib::strings::ToString</a>&lt; const std::string &amp; &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Specialization of template function <a class="el" href="namespaceaworx_1_1lib_1_1strings.html#a7cfd45024bf9222b42febac98fdcc146">ToString</a> for type <b>std::string</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source string to take the length from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of <code>src</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 19 2016 14:36:16 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
