<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALox: Enum Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1712 R. 0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--ALox Main Menu-->
<div style="background: #2f3a48; " >
<table  class="aworx-menutable"  >
 <tbody>
 <tr style="height: 36px;">
  <td> <a class="aworx-menu"    href="../index.html"                                   >Home</a>                     </td>
  <td> <a class="aworx-menu_hl" href="../cpp_ref/alox_cpp_mainpage.html"                >ALox for C++</a>             </td>
  <td> <a class="aworx-menu"    href="../cs_ref/alox_cs_mainpage.html"                  >ALox for C#</a>              </td>
  <td> <a class="aworx-menu"    href="../java_ref/alox_java_mainpage.html"              >ALox for Java</a>            </td>
  <td> <a class="aworx-menu"    href="https://github.com/AlexWorx/ALox-Logging-Library">Download</a></td>
 </tr>
 </tbody>
</table>
</div>
<!--end ALox Main Menu-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html">lang</a></li><li class="navelem"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Fields</a> &#124;
<a href="#pub-methods">Public Methods</a> &#124;
<a href="structaworx_1_1lib_1_1lang_1_1Enum-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Enum Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="enum_8hpp_source.html">enum.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Enum:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structaworx_1_1lib_1_1lang_1_1Enum__coll__graph.svg" width="163" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><hr/>
<p> The class is useful to store and pass around enum values of arbitrary C++ scoped enum types in a type-safe way. It is implemented to ease the use of C++ 11 scoped enums in situations where programmers otherwise tend to "fall back" to non-scoped (non type-safe enum types). This is the case, when enum elements of different types need to be processed.</p>
<p>In the constructor, enum elements of arbitrary type are accepted. The enum element is <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">boxed</a> and thus runtime type information is added. Having the "original" element stored in a box, has the following advantages:</p><ul>
<li>The box is useful to check the encapsulated enum type at runtime using <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">Box::IsType</a>.</li>
<li>The original element can be unboxed using <a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#a098ddd0b61d4db50bed59bc299743a01">Get</a> in a type-safe way. (This method is a shortcut to <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Box::Unbox&lt;TEnum&gt;()</a></li>
<li>The underlying integer type value of the enum element can be received easily.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The implementation of this class using <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">ALib Boxing</a> introduces a small memory overhead (usually 8 bytes per instance on 64-bit system), in respect to a possible alternative "direct" implementation. This is due to the fact that boxing allows one dimensional array types to be boxed as well as scalar types - which is never the case with this class.</dd>
<dd>
The advantage of doing so, is that the internal box element (which is exposed as a public field) may be used as if the enum element was just boxed, instead of being emplaced in this class. This way, custom boxing interfaces that exist for enum types, may be used with instances of this class.</dd>
<dd>
For example, this class already specializes <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">T_Apply</a> which appends a string representation of the enum element to an <b>AString</b>. Internally, built-in boxing interface <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a> is used.<br />
 This means, that if this interface is set for the boxed C++ 11 enum type already, then objects of this type can be applied without further (setup) effort of the user code. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Fields</h2></td></tr>
<tr class="memitem:a3f4cc83f58ce3f06ff56c19ca1115221"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#a3f4cc83f58ce3f06ff56c19ca1115221">box</a></td></tr>
<tr class="separator:a3f4cc83f58ce3f06ff56c19ca1115221"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr class="memitem:a7ee1a0d7d01e15a774c8c50c2e2b4c6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#a7ee1a0d7d01e15a774c8c50c2e2b4c6e">Enum</a> ()=delete</td></tr>
<tr class="separator:a7ee1a0d7d01e15a774c8c50c2e2b4c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054ba945878f6c0622d32b0f4a9d1176"><td class="memTemplParams" colspan="2">template&lt;typename TEnum , typename TEnableIf  = typename std::enable_if&lt;std::is_enum&lt;TEnum&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a054ba945878f6c0622d32b0f4a9d1176"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#a054ba945878f6c0622d32b0f4a9d1176">Enum</a> (TEnum element)</td></tr>
<tr class="separator:a054ba945878f6c0622d32b0f4a9d1176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098ddd0b61d4db50bed59bc299743a01"><td class="memTemplParams" colspan="2">template&lt;typename TEnum , typename TEnableIf  = typename std::enable_if&lt;std::is_enum&lt;TEnum&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a098ddd0b61d4db50bed59bc299743a01"><td class="memTemplItemLeft" align="right" valign="top">TEnum&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#a098ddd0b61d4db50bed59bc299743a01">Get</a> () const</td></tr>
<tr class="separator:a098ddd0b61d4db50bed59bc299743a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf382686a47103c1aadeface9ef947d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#aedf382686a47103c1aadeface9ef947d">IsSameType</a> (<a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a> const &amp;lhs) const</td></tr>
<tr class="separator:aedf382686a47103c1aadeface9ef947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9aae84b52f87145a2dc958185b1e82"><td class="memTemplParams" colspan="2">template&lt;typename TEnum , typename TEnableIf  = typename std::enable_if&lt;std::is_enum&lt;TEnum&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aeb9aae84b52f87145a2dc958185b1e82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#aeb9aae84b52f87145a2dc958185b1e82">IsType</a> () const</td></tr>
<tr class="separator:aeb9aae84b52f87145a2dc958185b1e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821773512beff3e662eb70c5fdfecfa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#a821773512beff3e662eb70c5fdfecfa6">operator!=</a> (<a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a> const &amp;lhs) const</td></tr>
<tr class="separator:a821773512beff3e662eb70c5fdfecfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae057f0da9955c95fece00c4d709e2f5c"><td class="memTemplParams" colspan="2">template&lt;typename TEnum , typename TEnableIf  = typename std::enable_if&lt;std::is_enum&lt;TEnum&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae057f0da9955c95fece00c4d709e2f5c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#ae057f0da9955c95fece00c4d709e2f5c">operator!=</a> (TEnum lhs) const</td></tr>
<tr class="separator:ae057f0da9955c95fece00c4d709e2f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce398a37a3b8326523465d467d4ba30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#a7ce398a37a3b8326523465d467d4ba30">operator&lt;</a> (<a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a> const &amp;lhs) const</td></tr>
<tr class="separator:a7ce398a37a3b8326523465d467d4ba30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d620337570b958bf5e70014da05ca60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#a6d620337570b958bf5e70014da05ca60">operator==</a> (<a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a> const &amp;lhs) const</td></tr>
<tr class="separator:a6d620337570b958bf5e70014da05ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd17007bb9bb2c84a4c96df9db38f864"><td class="memTemplParams" colspan="2">template&lt;typename TEnum , typename TEnableIf  = typename std::enable_if&lt;std::is_enum&lt;TEnum&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:acd17007bb9bb2c84a4c96df9db38f864"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#acd17007bb9bb2c84a4c96df9db38f864">operator==</a> (TEnum lhs) const</td></tr>
<tr class="separator:acd17007bb9bb2c84a4c96df9db38f864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ed6856fae3288e7d259bc756ef1382"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#ae3ed6856fae3288e7d259bc756ef1382">Value</a> () const</td></tr>
<tr class="separator:ae3ed6856fae3288e7d259bc756ef1382"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7ee1a0d7d01e15a774c8c50c2e2b4c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee1a0d7d01e15a774c8c50c2e2b4c6e">&#9670;&nbsp;</a></span>Enum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Deleted default constructor. </p>

</div>
</div>
<a id="a054ba945878f6c0622d32b0f4a9d1176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054ba945878f6c0622d32b0f4a9d1176">&#9670;&nbsp;</a></span>Enum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a> </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Implicit constructor which accepts arbitrary elements of scoped or non-scoped enum types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The external (user specific) enumeration element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>The external (user specific) enumeration type. </td></tr>
    <tr><td class="paramname">TEnableIf</td><td>Selects this constructor only for enum types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a098ddd0b61d4db50bed59bc299743a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098ddd0b61d4db50bed59bc299743a01">&#9670;&nbsp;</a></span>Get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TEnum Get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This is a shortcut to <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Box::Unbox&lt;TEnum&gt;()</a> to retrieve the original enum element in a type safe way.</p>
<p>Prior to invoking this, the boxed type can be checked with <a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#aeb9aae84b52f87145a2dc958185b1e82">IsType</a>. If the wrong type is tried to be received, an <b>ALib</b> assertion is raised.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>The external (user specific) enumeration type. </td></tr>
    <tr><td class="paramname">TEnableIf</td><td>Selects this method only for enum types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The underlying integer value of the encapsulated enum element. </dd></dl>

</div>
</div>
<a id="aedf382686a47103c1aadeface9ef947d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf382686a47103c1aadeface9ef947d">&#9670;&nbsp;</a></span>IsSameType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsSameType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Checks if the given other object encapsulates the same enumeration type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The right hand side argument of the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the encapsulated enum type of this object is the same as the one encapsulated in <code>lhs</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="aeb9aae84b52f87145a2dc958185b1e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9aae84b52f87145a2dc958185b1e82">&#9670;&nbsp;</a></span>IsType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Checks if the this instance has an enum element of type <code>TEnum</code> stored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEnum</td><td>The external (user specific) enumeration type. </td></tr>
    <tr><td class="paramname">TEnableIf</td><td>Selects this method only for enum types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the encapsulated enum type of type <code>TEnum</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a821773512beff3e662eb70c5fdfecfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821773512beff3e662eb70c5fdfecfa6">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Comparison operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The right hand side argument of the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object does not equal <code>lhs</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae057f0da9955c95fece00c4d709e2f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae057f0da9955c95fece00c4d709e2f5c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Comparison operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The right hand side argument of the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object does not equal <code>lhs</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a7ce398a37a3b8326523465d467d4ba30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce398a37a3b8326523465d467d4ba30">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Comparison operator. The sort order is primarily determined by the enum types that are boxed. If those are the same, then the underlying integer value of the enum elements is compared.</p>
<p>This leads to a nested sort order, with the type information being the outer order and the integer value of the enum being the inner one.</p>
<dl class="section note"><dt>Note</dt><dd>It is a matter of the compiler how the outer sort of types is performed and thus this can not be determined by the user code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The right hand side argument of the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the encapsulated type of this instance is the same as that of <code>lhs</code>, this methods <code>true</code> if <a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html#ae3ed6856fae3288e7d259bc756ef1382">Value()</a> of this object is smaller than the one of <code>lhs</code> and otherwise <code>false</code>. If the types are not the same, than the result is dependent on the tool chain used for compiling <b>ALib</b>. </dd></dl>

</div>
</div>
<a id="a6d620337570b958bf5e70014da05ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d620337570b958bf5e70014da05ca60">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structaworx_1_1lib_1_1lang_1_1Enum.html">Enum</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Comparison operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The right hand side argument of the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object equals <code>lhs</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="acd17007bb9bb2c84a4c96df9db38f864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd17007bb9bb2c84a4c96df9db38f864">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">TEnum&#160;</td>
          <td class="paramname"><em>lhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Comparison operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The right hand side argument of the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this object equals <code>lhs</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae3ed6856fae3288e7d259bc756ef1382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ed6856fae3288e7d259bc756ef1382">&#9670;&nbsp;</a></span>Value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the underlying integer value of the original enum element.</p>
<dl class="section see"><dt>See also</dt><dd>Namespace function <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a84494f1a492417b7b96bb8dfcd9c4c02">EnumValue</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The underlying integer value. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3f4cc83f58ce3f06ff56c19ca1115221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4cc83f58ce3f06ff56c19ca1115221">&#9670;&nbsp;</a></span>box</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a> box</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration element as a <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">boxed</a> value. Although the member name starts with a lower case letter, the value is still public (Bauhaus style). However, usually the element does not need to be accessed directly. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="enum_8hpp_source.html">enum.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 22 2017 22:23:15 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<!-- Start of StatCounter Code e -->
<script type="text/javascript">
var sc_project=11242602;
var sc_invisible=1;
var sc_security="5ac13373";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web statistics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11242602/0/5ac13373/1/" alt="web
statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
