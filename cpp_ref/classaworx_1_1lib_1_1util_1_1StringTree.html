<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALox: StringTree&lt; T, TKeyAllocator, TSeparator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1712 R. 0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--ALox Main Menu-->
<div style="background: #2f3a48; " >
<table  class="aworx-menutable"  >
 <tbody>
 <tr style="height: 36px;">
  <td> <a class="aworx-menu"    href="../index.html"                                   >Home</a>                     </td>
  <td> <a class="aworx-menu_hl" href="../cpp_ref/alox_cpp_mainpage.html"                >ALox for C++</a>             </td>
  <td> <a class="aworx-menu"    href="../cs_ref/alox_cs_mainpage.html"                  >ALox for C#</a>              </td>
  <td> <a class="aworx-menu"    href="../java_ref/alox_java_mainpage.html"              >ALox for Java</a>            </td>
  <td> <a class="aworx-menu"    href="https://github.com/AlexWorx/ALox-Logging-Library">Download</a></td>
 </tr>
 </tbody>
</table>
</div>
<!--end ALox Main Menu-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1util.html">util</a></li><li class="navelem"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html">StringTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Inner Classes</a> &#124;
<a href="#pub-methods">Public Methods</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Fields</a> &#124;
<a href="classaworx_1_1lib_1_1util_1_1StringTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">StringTree&lt; T, TKeyAllocator, TSeparator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="stringtree_8hpp_source.html">stringtree.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for StringTree&lt; T, TKeyAllocator, TSeparator &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1util_1_1StringTree__coll__graph.svg" width="278" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename TKeyAllocator = StringTreeDefaultKeyAllocator&lt;T&gt;, char TSeparator = '/'&gt;<br />
class aworx::lib::util::StringTree&lt; T, TKeyAllocator, TSeparator &gt;</h3>

<hr/>
<p> This class manages an object of internal type <a class="el" href="structaworx_1_1lib_1_1util_1_1StringTree_1_1Node.html">Node</a>, which consists of</p><ul>
<li>A value of custom (template) type <code>T</code>,</li>
<li>A pointer to a parent <b>Node</b> and</li>
<li>A hash table which recursively stores pointers to <b><a class="el" href="structaworx_1_1lib_1_1util_1_1StringTree_1_1Node.html">Node</a></b> objects, referred to by a string-type key.</li>
</ul>
<p>This recursive data structure is what comprises a graph with named edges. As this object does not allow insertion of nodes with circular dependencies, the graph is of tree type. The way from the root node to the leafs usually is called "path" and the class incorporates functionality to work with string representations of such paths where names of edges are concatenated and separated by a special separation character. Now, this explains why this class is called <b>StringTree</b>.</p>
<p>The search and creation of tree nodes by using aforementioned path strings, is very similar to what is well known from addressing files and folders in file systems. The difference is however, that this class does not differentiate between 'folders' and 'files', hence between 'nodes' and 'leafs'. Every node has the same value type <code>T</code> and may or may not have child nodes. If such differentiation - or other semantics - is wanted, this may be modeled in custom attributes provided in template type <code>T</code>.</p>
<p>The internal node structure is not exposed publically and the class has no direct interface to manipulate nodes. Instead, the interface is defined by three public inner types. Those are:</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html">Cursor</a>,</li>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a> (C++ version only) and</li>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Walker.html">Walker</a>.</li>
</ul>
<p>and are explained in the following paragraphs.</p>
<p><a class="anchor" id="cpp_alib_containers_stringtree_cursor"></a><b>Inner class Cursor: Inserting, Retrieving And Deleting Nodes</b><br />
 The class has no direct interface to manipulate nodes. The main interface into objects of this type is defined by public, inner type <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html">Cursor</a>. The only way to create an initial cursor is with method <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#aa82ebec74bb4a81000211e3dcdfdf9cc">Root</a>, which creates a cursor object referring to the root node of the tree. With this, string names and complete paths can be used to move the cursor along existing nodes of the tree or to create new child nodes or a whole path of children at once. Class cursor is quite lightweight as it contains just two pointers (to the <b>StringTree</b> and the current node). Hence, cursors can be cloned, assigned and passed around very efficiently.</p>
<p>Once a cursor is created it can traverse over the tree nodes using methods</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#ae96a4d518a6f17184d8e5a31565f8dfe">Cursor::MoveToChild</a>,</li>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#af240df28a6292c10753b81de82f40b47">Cursor::MoveToParent</a>,</li>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#a21206644be243178e0e95deade9b8414">Cursor::MoveTo</a> and</li>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#aedaf3d8965224d5bee561a01fcb66929">Cursor::MoveToExistingPart</a>.</li>
</ul>
<p>For the creation of new child nodes or a complete path of such, methods</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#a3c8dc99948de5c8c6cb02ef31324547d">Cursor::MoveToChildCreate</a> and</li>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#acb8e5ddc037c4ff8db8150ed5ccbc890">Cursor::MoveToAndCreateNonExistingPart</a></li>
</ul>
<p>are provided. Then, two methods for erasing nodes exist:</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#a7a295ee417e1a43185684997b60c1d2c">Cursor::DeleteChild</a> and</li>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#a63f4720668cc61ddf555b470b9eec188">Cursor::DeleteChildren</a></li>
</ul>
<p>Finally, class cursor can also be used like an iterator. But it explicitly and for good reason does <b>not</b> follow the concepts provided with <code>C++ std::iterator</code> types. The iterating feature comes with methods</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#a92b32ed64afe9459f6b6673712e990f1">Cursor::MoveToParentUnchecked</a> and</li>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#a9dcb9b43a3d0fa9003d4c1c9d921f6b2">Cursor::IsValid</a>.</li>
</ul>
<p>The first transitions the cursor to refer to the parent node. Using this method is (almost) the only way how a cursor can get invalidated. Hence a simple loop can be written that visits all nodes from a starting node, up to the root of the tree until <b>Cursor::IsValid</b> evaluates to <code>false</code>.</p>
<p><b>Inner class iterator: A std::iterator implementation</b><br />
 A second inner class is provided with <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a>. It implements the concept <a href="http://en.cppreference.com/w/cpp/concept/InputIterator">C++ InputIterator</a> and due to the implementation of methods</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#af76b3f0931ada73975a7d1dc15941f9e">StringTree::begin</a> and</li>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#a9ea1f4bf0ddd2e732a5552084cdecc45">StringTree::end</a>,</li>
</ul>
<p>this type can be used together with <em>C++ 11 ranged-for loops</em> as well as <code>std::for_each</code>. And these loops indicate already the typical use of class <b>StdIterator</b>: The implementation of algorithms that need to visit all nodes of a tree or a branch in an depth-first order, with unsorted child order.</p>
<p>With methods</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#a7794c681cde49fe79ce350908e021046">Cursor::begin</a> and</li>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#a9ea1f4bf0ddd2e732a5552084cdecc45">Cursor::end</a>,</li>
</ul>
<p><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a> objects may be initialized using a different start node than the root, which is chosen with the direct <b>StringTree</b> interface. Existing <b>StdIterator</b> object can also be reused: They can be freshly initialized with methods</p>
<ul>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html#af9bfedce967aba5eb6555765512bb65d">Cursor::SetIterator</a> and</li>
<li><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Walker.html#a99bcae7fcb22ef864d4117c7bff0aab8">Walker::SetIterator</a>.</li>
</ul>
<p>Please also note the paragraph about recursive iteration below.</p>
<p>Class <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a> is quite lightweight. Nevertheless, if frequently used, it might be advisable to reuse an exiting <b>StdIterator</b>, because internal buffers are allocated then only once. Of-course, re-using an instance is a showstopper for convenient <em>C++ 11 ranged-for loops</em>.</p>
<p><b>Inner class Walker: Sorted Iterations</b><br />
 Finally, with <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Walker.html">Walker</a>, a third <b>StdIterator</b> class is exposed. The rational for having this class is to provide a configurable and controlled way of iterating a tree or a branch. Some features of the class are:</p><ul>
<li>Can be created from (or reset to) the <b>StringTree</b> itself, <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html">Cursor</a> objects and from <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a> objects.</li>
<li>Can work recursively (with depth limitation) or just on the current nodes' direct children.</li>
<li>Has several sort options:<ul>
<li>built-in by path name, ascending/descending, case sensitive or ignoring</li>
<li>user defined by path name</li>
<li>user defined by template type</li>
</ul>
</li>
</ul>
<p>The class is rather 'heavy' and recursive iteration needs to allocate memory for a sorted vector of child nodes. Therefore it is recommended to reuse instances of the class with subsequent, similar iterations. In addition this explains why this class does not follow the concept of <code>std::iterator</code>, same as class <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html">Cursor</a> does not - but then unlike class <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a> which does!</p>
<p><a class="anchor" id="cpp_alib_containers_stringtree_iterator"></a><b>Recursive Iteration</b><br />
</p>
<p>Both inner types that provide depth-iteration, namely class <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a> and class <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Walker.html">Walker</a>, allow recursive iteration. There are two specialities to note on this topic which need explanation:</p>
<ol type="1">
<li><b>Skipping the Initial Node:</b><br />
 When the recursive iteration is limited, then the very first node (the root node of the iteration) is skipped. With unlimited recursion, the root node is included (as the first result). In the case, that the root node should not be included in an unlimited, recursive iteration, it has to be skipped 'manually'.</li>
<li><b>Default Recursion Depth:</b><br />
 There are different default values for the recursion limit, depending on the way a <b>StdIterator</b> is initialized. For example, method <b>StringTree::begin</b>() sets up an recursive <b>StdIterator</b>, while <b>Cursor::begin</b> limits the recursion to <code>1</code>, hence to iterate only the direct child nodes. This default behavior was identified to be reasonable for many situations.<br />
 If different recursiveness is wanted, a parameter needs to be passed to <b>begin</b>, which of course is then not applicable to nice and short <em>C++ 11 ranged-for loops</em>.</li>
</ol>
<p><b>Iterators And Changes Of The Underlying Container</b><br />
 As with container classes in namespace <code>std</code>, objects of iterator-like types of this class (i.e. <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html">Cursor</a>, <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a> and <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Walker.html">Walker</a>) may become invalid when the underlying <b>StringTree</b> object changes and have to be re-initialized after such change. I.e, there is no guarantee given that changes in the tree are not invalidating iterators that represent 'higher' nodes or or 'sibling' branches. Such invalid state can not be detected. As a result, all iterator like objects have to be reset or disposed on changes of the tree.</p>
<p><b>Key String Allocations:</b><br />
 The C++ version of this class implements user-defined allocation of the characters sequences stored as keys in the child hash tables of each node. For this, template parameter <code><a class="el" href="structaworx_1_1lib_1_1util_1_1StringTreeDefaultKeyAllocator.html">StringTreeDefaultKeyAllocator</a></code> is given which defaults to struct <a class="el" href="structaworx_1_1lib_1_1util_1_1StringTreeDefaultKeyAllocator.html">StringTreeDefaultKeyAllocator</a>, which just uses new and delete to allocate and free the space. This is done, because chances are good that</p><ul>
<li>either the key values provided in the child creation methods of class <b>Cursor</b> are permanently valid or</li>
<li>the templated value element <code>T</code> contains a "copy" of the key.</li>
</ul>
<p>If the first case applies, type <a class="el" href="structaworx_1_1lib_1_1util_1_1StringTreeConstKeyAllocator.html">StringTreeConstKeyAllocator</a> may be used, which does not allocate anything and does not copy the key even.<br />
 If the second case applies, a custom type may be provided which stores the key in <code>T</code> and returns this copy to be used. Note that for this reason, class <b><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html">StringTree</a></b> asserts that node elements and with them custom objects of type <code>T</code> are deleted always <b>after</b> they have been removed from the tree, so that the key memory can safely deallocated.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of elements stored in the nodes of the tree. </td></tr>
    <tr><td class="paramname">TKeyAllocator</td><td>Type with static allocation methods as defined in default struct <a class="el" href="structaworx_1_1lib_1_1util_1_1StringTreeDefaultKeyAllocator.html">StringTreeDefaultKeyAllocator</a>. </td></tr>
    <tr><td class="paramname">TSeparator</td><td>The separation character used with cursor paths. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Inner Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html">Cursor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1util_1_1StringTree_1_1Node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Walker.html">Walker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr class="memitem:a12c63bb97dceeb994767995edb79b8c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#a12c63bb97dceeb994767995edb79b8c9">StringTree</a> ()</td></tr>
<tr class="separator:a12c63bb97dceeb994767995edb79b8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54346dff967e9fde7e8be616275f1f6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#a54346dff967e9fde7e8be616275f1f6d">~StringTree</a> ()</td></tr>
<tr class="separator:a54346dff967e9fde7e8be616275f1f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76b3f0931ada73975a7d1dc15941f9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#af76b3f0931ada73975a7d1dc15941f9e">begin</a> ()</td></tr>
<tr class="separator:af76b3f0931ada73975a7d1dc15941f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71d36872f416feaa853788a7a7a7ef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#aa71d36872f416feaa853788a7a7a7ef8">Clear</a> ()</td></tr>
<tr class="separator:aa71d36872f416feaa853788a7a7a7ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea1f4bf0ddd2e732a5552084cdecc45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#a9ea1f4bf0ddd2e732a5552084cdecc45">end</a> ()</td></tr>
<tr class="separator:a9ea1f4bf0ddd2e732a5552084cdecc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ba1ae3b47dffcf2673093ec30b087d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html">Cursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#a26ba1ae3b47dffcf2673093ec30b087d">operator()</a> ()</td></tr>
<tr class="separator:a26ba1ae3b47dffcf2673093ec30b087d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82ebec74bb4a81000211e3dcdfdf9cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html">Cursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#aa82ebec74bb4a81000211e3dcdfdf9cc">Root</a> ()</td></tr>
<tr class="separator:aa82ebec74bb4a81000211e3dcdfdf9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a5ed481b3d67c031356e1868b7cb2ae03"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#a5ed481b3d67c031356e1868b7cb2ae03">TMap</a> = <a class="el" href="namespaceaworx.html#a426e54834656e7d1ebe38c4cae5246dd">UnorderedStringMap</a>&lt; <a class="el" href="structaworx_1_1lib_1_1util_1_1StringTree_1_1Node.html">Node</a> * &gt;</td></tr>
<tr class="separator:a5ed481b3d67c031356e1868b7cb2ae03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Fields</h2></td></tr>
<tr class="memitem:a3f7db53410d0f3007de60cc3d64a0c09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structaworx_1_1lib_1_1util_1_1StringTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#a3f7db53410d0f3007de60cc3d64a0c09">root</a></td></tr>
<tr class="separator:a3f7db53410d0f3007de60cc3d64a0c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5ed481b3d67c031356e1868b7cb2ae03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed481b3d67c031356e1868b7cb2ae03">&#9670;&nbsp;</a></span>TMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#a5ed481b3d67c031356e1868b7cb2ae03">TMap</a> =  <a class="el" href="namespaceaworx.html#a426e54834656e7d1ebe38c4cae5246dd">UnorderedStringMap</a>&lt;<a class="el" href="structaworx_1_1lib_1_1util_1_1StringTree_1_1Node.html">Node</a>*&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias to a map of nodes with string keys </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a12c63bb97dceeb994767995edb79b8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c63bb97dceeb994767995edb79b8c9">&#9670;&nbsp;</a></span>StringTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html">StringTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructor </p>

</div>
</div>
<a id="a54346dff967e9fde7e8be616275f1f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54346dff967e9fde7e8be616275f1f6d">&#9670;&nbsp;</a></span>~StringTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html">StringTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af76b3f0931ada73975a7d1dc15941f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76b3f0931ada73975a7d1dc15941f9e">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns an unlimited recursive StdIterator starting at the root node of this <b>StringTree</b>. </p><dl class="section return"><dt>Returns</dt><dd>An recursive StdIterator starting at the root node. </dd></dl>

</div>
</div>
<a id="aa71d36872f416feaa853788a7a7a7ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71d36872f416feaa853788a7a7a7ef8">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Clears all nodes and values. </p>

</div>
</div>
<a id="a9ea1f4bf0ddd2e732a5552084cdecc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea1f4bf0ddd2e732a5552084cdecc45">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1StdIterator.html">StdIterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns a <b>StdIterator</b> pointing to the first character behind this string. </p><dl class="section return"><dt>Returns</dt><dd>The end of this string. </dd></dl>

</div>
</div>
<a id="a26ba1ae3b47dffcf2673093ec30b087d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ba1ae3b47dffcf2673093ec30b087d">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html">Cursor</a> operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> A shortcut to method <a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree.html#aa82ebec74bb4a81000211e3dcdfdf9cc">Root</a>. </p><dl class="section return"><dt>Returns</dt><dd>A cursor pointing to the root node of this <b>StringTree</b>. </dd></dl>

</div>
</div>
<a id="aa82ebec74bb4a81000211e3dcdfdf9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82ebec74bb4a81000211e3dcdfdf9cc">&#9670;&nbsp;</a></span>Root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1util_1_1StringTree_1_1Cursor.html">Cursor</a> Root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Creates a cursor instance representing the root node. </p><dl class="section return"><dt>Returns</dt><dd>A cursor pointing to the root node of this <b>StringTree</b>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3f7db53410d0f3007de60cc3d64a0c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7db53410d0f3007de60cc3d64a0c09">&#9670;&nbsp;</a></span>root</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structaworx_1_1lib_1_1util_1_1StringTree_1_1Node.html">Node</a>* root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The root node. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="stringtree_8hpp_source.html">stringtree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 22 2017 22:23:16 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<!-- Start of StatCounter Code e -->
<script type="text/javascript">
var sc_project=11242602;
var sc_invisible=1;
var sc_security="5ac13373";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web statistics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11242602/0/5ac13373/1/" alt="web
statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
