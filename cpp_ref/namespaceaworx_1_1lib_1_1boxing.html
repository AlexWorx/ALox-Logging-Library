<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALox: aworx::lib::boxing Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1709 R. 0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--ALox Main Menu-->
<div style="background: #2f3a48; " >
<table  class="aworx-menutable"  >
 <tbody>
 <tr style="height: 36px;">
  <td> <a class="aworx-menu"    href="../index.html"                  >Home</a>                     </td>
  <td> <a class="aworx-menu_hl" href="../cpp_ref/cppmainpage.html"    >ALox for C++</a>             </td>
  <td> <a class="aworx-menu"    href="../cs_ref/csmainpage.html"      >ALox for C#</a>              </td>
  <td> <a class="aworx-menu"    href="../java_ref/javamainpage.html"  >ALox for Java</a>            </td>
  <td> <a class="aworx-menu"    href="https://github.com/AlexWorx/ALox-Logging-Library">Download</a></td>
 </tr>
 </tbody>
</table>
</div>
<!--end ALox Main Menu-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">boxing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Nested namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">aworx::lib::boxing Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Namespace Description</h2>
<div class="textblock"><hr/>
<p> This is namespace documentation includes a lengthy introduction and tutorial section.</p>
<p>Contents of the <b>reference documentation</b> section:</p>
<ul>
<li><a href="#namespaces">Nested Namespaces</a></li>
<li><a href="#nested-classes">Classes</a></li>
<li><a href="#typedef-members">Typedefs</a> and</li>
<li><a href="#func-members">Functions</a></li>
</ul>
<p>Contents of the <b>manual</b> section:</p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_prerequisites">1. Prerequisites</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_prereq_modules">1.1 Modularization of ALib</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_prereq_unittests">1.2 Unit Tests</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_prereq_reading">1.3 How To Read This Documentation</a> <br />
</p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_intro">2. Introduction to Boxing</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_intro_goals">2.1 Goals of ALib Boxing</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_intro_boxing">2.2 The Term 'Boxing'</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_intro_cpp">2.3 Boxing In C++?</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_intro_templated">2.4 Using A Templated Constructor</a> <br />
 <br />
 <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_basics">3. Basics Of ALib Boxing</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_basics_tmp">3.1 Perfect Auto-Boxing in C++ With Template Meta Programming</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_basics_boxer">3.2 Class Boxer: The Master Of A Boxed Type</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_basics_dots">3.3 Struct BoxData: The Values Stored in a Box</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_basics_dots">3.4 Connecting The Dots: Boxing And Unboxing</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_basics_nonbij">3.5 Non-Bijective Type Mapping</a> <br />
 <br />
 <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types">4. Arrays, Fundamental Types and Strictness of Unboxing</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_arrays">4.1 Boxing Arrays And Vectors</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_ftypes">4.2 Boxing Fundamental Types</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_nonunboxable">4.3 Non-unboxable Types</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_boxedas">4.5 Boxing Types As They Are</a> <br />
</p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_interfaces">5. Box Interfaces: Virtual Method Invocation on Boxes</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_interfaces_sample">5.1 A Simple Interface Sample</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_interfaces_default">5.2 Default Interfaces</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_interfaces_built-in">5.3 The Built-In Interface Classes</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_interfaces_change">5.4 Changing The Default Behavior</a> <br />
</p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_strings">6. Boxing Strings</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_strings_chararr">6.1 Strings As Character Arrays</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_strings_lw_vs_hvy">6.2 'Lightweight' And 'Heavy' String Types</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_strings_iapply">6.3 Interface IApply</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_strings_iformat">6.4 Interface IFormat</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_strings_custom">6.5 Boxing Custom String Types</a> <br />
</p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_variadic">7. Variadic Arguments</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_variadic_standard">7.1 Using Boxes With Variadic Arguments</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_variadic_class_boxes">7.2 Class Boxes</a> <br />
</p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_usage">8. Using The Library</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_usage_bootstrap">8.1 Bootstrapping ALib Boxing</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_usage_3rdparty">8.2 Built-In Support for 3rd Party Types</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_usage_lifecycle">8.3 Lifecycle Management And Data Deletion</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_usage_performance">8.4 Performance Considerations</a> <br />
 &#160;&#160; <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_usage_dump">8.5 Debugging ALib Boxing</a> <br />
</p>
<p><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_summary">9. Summary</a> <br />
</p>
<p><a class="anchor" id="alib_namespace_boxing_prerequisites"></a></p><h1>1. Prerequisites</h1>
<p><a class="anchor" id="alib_namespace_boxing_prereq_modules"></a></p><h2>1.1 Modularization of ALib</h2>
<p>Classes found in this namespace comprise what is called a <b>'module'</b> of the <b>ALib</b> class library. The term "module" here means, that this feature of <b>ALib</b> may be used independently from the <b>ALib</b> class library itself. We have designed module <b>ALib Boxing</b> to have (almost) <b>no</b> dependencies to other portions of <b>ALib</b> in respect to header file inclusion, the use of other common ALib types, macros and other sweet <b>ALib</b> sugar.</p>
<p>The rational for this effort lies in the fact that this way the community can use <b>ALib Boxing</b> without including the complete <b>ALib</b> stack of utilities.</p>
<p>The separated module classes, structured as a lean library are found at GitHub project <a href="https://github.com/AlexWorx/ALib-Boxing">ALib Boxing</a>.<br />
 Besides using this module or the full <b>ALib</b> class library, there is a third option, which is found with <a href="https://github.com/AlexWorx/ALib-Boxing-And-Strings">ALib Boxing &amp; Strings</a>. This is is module <b>ALib Boxing</b> packaged together with module <a href="https://github.com/AlexWorx/ALib-Strings">ALib Strings</a>. The rational for providing this mixed module package is that boxing and strings have some nice synergies, but still users of both might not want to use more of <b>ALib</b>.</p>
<p>The complete overview of available distributions/modules is given <a class="el" href="namespaceaworx_1_1lib.html">here</a>.</p>
<p><a class="anchor" id="alib_namespace_boxing_prereq_unittests"></a></p><h2>1.2 Unit Tests</h2>
<p>The <a href="https://github.com/AlexWorx/ALib-Boxing">single distribution version</a> of this module is not equipped with extensive unit tests. Instead, just some quick sample and test executables are available. Unit tests are placed in the <a href="https://github.com/AlexWorx/ALox">full ALib distribution</a> (currently bundled with ALox).</p>
<p><a class="anchor" id="alib_namespace_boxing_prereq_reading"></a></p><h2>1.3 How To Read This Documentation</h2>
<p>This documentation is a mix of a manual and tutorial and is probably too detailed and <em>time-consuming</em> for experienced C++ programmers.<br />
 If you just want to get to understand quickly what this library is about and how to use it, the short version is given in last chapter <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_summary">9. Summary</a>.</p>
<p>The <a href="https://github.com/AlexWorx/ALib-Boxing">single distribution version</a> of this module is not equipped with extensive unit tests. Instead, just some quick sample and test executables are available. Unit tests are placed in the <a href="https://github.com/AlexWorx/ALox">full ALib distribution</a> (currently bundled with ALox).</p>
<p><a class="anchor" id="alib_namespace_boxing_intro"></a></p><h1>2. Introduction to Boxing</h1>
<p><a class="anchor" id="alib_namespace_boxing_intro_goals"></a></p><h2>2.1 Goals of ALib Boxing</h2>
<p>The original motivation to implement <b>ALib Boxing</b> was the need to forward an arbitrary amount of function arguments of arbitrary type to other functions. Until here, C++ 11 has all mechanisms to implement this, using <a href="http://en.cppreference.com/w/cpp/language/parameter_pack">variadic template arguments</a>. The limitation of the template approach is of-course that all needs to happen at compile time what tremendously limits the concept - for the sake of gaining unrivalled performance!</p>
<p>We were searching for a way to pass arguments and interpret their type and value at runtime. With other programming languages which provide a superclass <code>Object</code> and <b>runtime type information</b> this is a no-brainer. In C++ it needs some effort to achieve this. This library provides a very generalized, extensible approach that is not limited to variadic function arguments.</p>
<p>Thinking further, it quickly becomes clear that identifying the original type of an object and retrieving its original value is not sufficient: With multiple-inheritance in place, it is often not interesting if an unknown object originates from a certain base type. The main purpose of multiple-inheritance is to be able to invoke an interface method that a second base type provides. (This statement is arguable: our justification for stating this is the observation that e.g. in programming language <em>Java</em>, multiple-inheritance is limited to implementing interface classes - a limitation that does not seem to be very severe for Java programmers!).</p>
<p>In C++, keyword <code>dynamic_cast</code> allows to convert pointers to target types and failures to do so (if the type is not convertible) are detected by having a <code>nullptr</code> as a result. Now, this works fine as long the original type is a pointer to a virtual class. Our goal was to support non-virtual classes as well as fundamental C++ types, e.g. <code>int</code> or <code>char*</code>. Furthermore, we wanted to support instances of 3rd party types. This means, objects of types that are instantiated in code parts that are not aware of the interfaces needed when we use them. For example we wanted to be able to pass a "window" object created in a windowing toolkit library or an object representing an open file, created in a library of the operating system.</p>
<p>Finally, there was a last goal: Passing and processing the values should be <em>"easy"</em>. The easiest way to to pass an object definitely is to pass it "as it is". We will show in this documentation what "easiness" means in respect to processing the values!</p>
<p><a class="anchor" id="alib_namespace_boxing_intro_boxing"></a></p><h2>2.2 The Term 'Boxing'</h2>
<p>In context of programming languages the term <em>"boxing"</em> describes the act of embedding a <em>'value'</em> that is defined by a <em>'type'</em> into a different type and probably a different way of physically storing the value in the memory of the machine. Together with this conversion, meta information may be added.</p>
<p>For example in programming languages <em>Java</em> and <em>C#</em> (that in this case share exactly the same syntax) the following simple line of code performs <em>boxing:</em> </p><pre class="fragment">    int i= 5;
    Object myInteger= i;
</pre><p>The boxing is performed <b>implicitly</b>. There is no "cast" syntax or other boxing syntax needed to tell the compiler what to do. Therefore, this is also called "auto boxing" and in fact the term boxing mostly is used when auto boxing is done.</p>
<p>Some IDEs are smart enough to provide information about where in the source code such 'auto-boxing' takes place, because it can be easily overseen by a programmer. A programmer should be aware of boxing, because some runtime effort for boxing a value is involved.</p>
<p><a class="anchor" id="alib_namespace_boxing_intro_cpp"></a></p><h2>2.3 Boxing in C++?</h2>
<p>In C++, a different concept exists that may be used to reach similar results. This mechanism is called <a href="http://www.cplusplus.com/doc/tutorial/typecasting/">Implicit type conversion with single-argument constructors</a>.</p>
<p>Let us look at a quick sample:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>IntegerBox</div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">int</span> intValue;</div><div class="line"></div><div class="line">    IntegerBox( <span class="keywordtype">int</span> intParam ) : intValue(intParam) {}</div><div class="line">};</div></div><!-- fragment --><p> With this class definition, we now can write:</p>
<div class="fragment"><div class="line">IntegerBox myInteger= 5;</div></div><!-- fragment --><p> In this sample, the C++ compiler includes an implicit constructor invocation and creates an object of type integer. This can be seen when 'stepping into' the line of code with a C++ debugger.<br />
 When function parameters are declared to take a constant parameter of a class type, the implicit constructor invocation is also inserted by the compiler along with the machine code of invoking the function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myFunction( <span class="keyword">const</span> IntegerBox&amp; param )</div><div class="line">{</div><div class="line">    <span class="comment">//...</span></div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">myFunction( 7 );</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><ul>
<li>While <code>const</code> is mandatory for parameters to support implicit constructor invocation, using reference types (<code>'&amp;'</code>) is not. The advantage of using reference types is that in the case the parameter is provided already as a value of the expected type (and therefore no implicit construction is needed).</li>
<li>If C++ keyword <code>explicit</code> used with constructor declarations instructs the compiler to suppress implicit invocations.</li>
<li>Implicit constructor invocation is only performed on <b>one direct level</b>. Possible nested invocations are not detected and need manual insertion of constructor calls.</li>
</ul>
</dd></dl>
<p><a class="anchor" id="alib_namespace_boxing_intro_templated"></a></p><h2>2.4 Using A Templated Constructor</h2>
<p>To extend the sample of class <b>IntegerBox</b> above to accept other types for implicit conversion, a dedicated constructor for such type is needed to be added. This quickly takes us to the idea to use a templated constructor. Let's move away from class <b>IntegerBox</b> and call it just <b>Box</b>, because we want to box arbitrary values, not only integer types:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a></div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TBoxable&gt;  <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#adea1928c15ca1eb88b6619bc554911b5">Box</a>( <span class="keyword">const</span> TBoxable&amp; value )</div><div class="line">    {</div><div class="line">        <span class="comment">//... store the value</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> And yeah, this works, the compiler has no problem with this code now:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>  box1= 5;</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>  box2= <span class="stringliteral">&quot;42&quot;</span>;</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>  box3= <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> intArray[2] = { 14, 5 };</div><div class="line"><a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>  box4= intArray;</div></div><!-- fragment --><p> Furthermore, with the following function defined:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> myFunction( <span class="keyword">const</span> <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp; box )</div><div class="line">{</div><div class="line">    <span class="comment">// do something with the box</span></div><div class="line">}</div></div><!-- fragment --><p> ...also the following code gets nicely compiled:</p>
<div class="fragment"><div class="line">myFunction( 5    );</div><div class="line">myFunction( <span class="stringliteral">&quot;42&quot;</span> );</div><div class="line">myFunction( <span class="keyword">true</span> );</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> intArray[4] = { 1,2,3,4 };</div><div class="line">myFunction( intArray );</div></div><!-- fragment --><p> The code above does not store the value. It is just the proof of concept that shows that the invocation of method <b>myFunction</b> without explicit conversion of values is accepted by the compiler.</p>
<p><a class="anchor" id="alib_namespace_boxing_basics"></a></p><h1>3. Basics Of ALib Boxing</h1>
<p><a class="anchor" id="alib_namespace_boxing_basics_tmp"></a></p><h2>3.1 Perfect Auto-Boxing in C++ With Template Meta Programming</h2>
<p>The solution of this library for implementing the templated constructor discussed above is the use of template meta programming (aka <a href="https://en.wikipedia.org/wiki/Template_metaprogramming">TMP</a>). <b>ALib</b> class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> utilizes TMP utilities found in standard library header <a href="http://www.cplusplus.com/reference/type_traits">type_traits</a> and secondly invokes template functions defined in this namespace, which can be specialized for supported types (aka boxable types). This way, the "supported types" have no need to be extended with a specific interface method. The types just do not "know" about the fact that their objects might be boxed and shipped to other places inside these boxes.</p>
<p>But before we talk about the details of these <em>'specialized template functions'</em> that a user of the library needs to implement to make a custom type <em>'boxable'</em>, we first need to discuss another important detail of the implementation of <b>ALib Boxing</b>. This detail is about how we interface into boxed values.</p>
<p><a class="anchor" id="alib_namespace_boxing_basics_boxer"></a></p><h2>3.2 Class Boxer: The Master of a Boxed Type</h2>
<p>Reading this introduction, it should have become clear, that class <b>Box</b> can not have virtual methods. The simple reason is, that for auto-boxing values, everything has to go into the same type of box. Therefore, class <b>Box</b> will never have derived types and virtual methods are not a way to proceed.</p>
<p>Consequently, the duties of virtualization need to be burdened to some other type. With <b>ALib Boxing</b> this type is implemented with class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html">Boxer</a>. Objects of this class are the true masters of a <b>Box</b>. Each boxed object, along with the data that it embeds, stores a pointer to "its" <b>Boxer</b>.</p>
<p>For each boxable type, a corresponding derived <b>Boxer</b> type is needed. Furthermore, derived boxer types follow the <b>strict singleton</b> design pattern. This means that</p><ul>
<li>a singleton instance of each boxer type exists</li>
<li>this instance is the only instance of this type.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Class <b>Boxer</b> is similar to <a href="https://en.wikipedia.org/wiki/Virtual_method_table">vtables</a> of instances of virtual C++ class types.</dd></dl>
<p>In the process of boxing a value, the right singleton of class <b>Boxer</b>, representing the boxed type needs to be chosen and added as a pointer to the boxed object.</p>
<p><a class="anchor" id="alib_namespace_boxing_basics_boxdata"></a></p><h2>3.3 Struct BoxData: The Values Stored in a Box</h2>
<p>Before we connect all dots, let us quickly discuss a final important point: What data do we store in a box? Remember, the constraints:</p><ul>
<li>Any type should be boxable.</li>
<li>We can not have different versions of class <b>Box</b>.</li>
</ul>
<p>The latter constraint disallows embedding different data fields for different types. We also want to disallow the creation of a heap-allocated, type-specific data object. Heap allocations in such situations are strict "no-go" for the <b>ALib</b> library. Its design rules clearly forbid that auto-boxing involved the allocation of heap memory.</p>
<p>This imposes, that all non-trivial types have to be boxed as pointers to their original object. While fundamental types are stored by value, the data that is to be stored needs to have as many bytes as the maximum of a) the biggest fundamental type and b) the size of a pointer on the target machine have. This type is defined with <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#aa3e009a14ed9d13b3f9cfac1ac29bee5">boxvalue</a>.</p>
<p>Besides this box value <b>ALib Boxing</b> stores a second value that is called <b>Length</b>. The Length is used when boxing C++ array types or std::vector types. Custom types might make use of this integer value differently and thus give it a completely different meaning (without being able to change the name).</p>
<p>Both values are aggregated in simple struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html">BoxData</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Although this library provides <b>Length</b> to represent the length of the first dimensions of arrays, this does not mean that multi-dimensional arrays can not be boxed. The decision to store the one array dimension explicitly is a compromise. The rational is:<ul>
<li>This allows convenient access to the first dimension of array elements.</li>
<li>This allows container types to offer an indexed access to elements of boxed values.</li>
<li>The overhead of storing a length value even for types that do not need it, is taken into account to just provide this convenience.</li>
</ul>
</dd></dl>
<p><a class="anchor" id="alib_namespace_boxing_basics_dots"></a></p><h2>3.4 Connecting The Dots: Boxing And Unboxing</h2>
<p>Let us summarize what was described so far about the classes and relationships:</p>
<ul>
<li>Class <b>Box</b> stores a pointer to a singleton of a type derived from class <b>Boxer</b> </li>
<li>In addition class <b>Box</b> incorporates a struct <b>BoxData</b> to store the boxed value. This struct in turn contains<ul>
<li>a value of type <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#aa3e009a14ed9d13b3f9cfac1ac29bee5">boxvalue</a></li>
<li>an integer value to store the length of arrays and container types.</li>
</ul>
</li>
</ul>
<p>Together, these are <b>three</b> values. On a typical 64-Bit machine, each value is 64-Bit long. The size of a boxed value hence there is 24 bytes.</p>
<p>Furthermore it was said, that class <b>Box</b> uses a templated constructor. This constructor needs to set the three values.</p>
<p>We have never talked yet about retrieving values back from a box. We call this process <b>unboxing</b>. Class <b>Box</b> provides template methods</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Box::Unbox</a> and</li>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a974225964bd92b7338e69557376719e1">Box::UnboxElement</a></li>
</ul>
<p>A sample shows how <b>Box::Unbox</b> can be used. Template parameter <code>TBoxable</code> of this method specifies the result type:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div><div class="line">{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keywordtype">int</span>      value;</div><div class="line"></div><div class="line">        MyClass( <span class="keywordtype">int</span> pValue )</div><div class="line">        : value(pValue)</div><div class="line">        {</div><div class="line">        }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> useBox( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box )</div><div class="line">{</div><div class="line">    MyClass* myClass= box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;MyClass*&gt;();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Value: &quot;</span> &lt;&lt; myClass-&gt;value &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> We can write:</p>
<div class="fragment"><div class="line">MyClass mc( 42 );</div><div class="line">useBox( mc );</div></div><!-- fragment --><p> what generates output:</p>
<div class="fragment"><div class="line">Value: 42</div></div><!-- fragment --><p> Fine! But this code is missing something very important: prior to unboxing a boxed value, it is needed to check the box type. This is done with template method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">Box::IsType</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> useBox( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box )</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a>&lt;MyClass*&gt;() )</div><div class="line">    {</div><div class="line">        MyClass* myClass= box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;MyClass*&gt;();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Value: &quot;</span> &lt;&lt; myClass-&gt;value &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Unknown boxed type&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> It is now OK to invoke function <b>useBox</b> with arbitrary types:</p>
<div class="fragment"><div class="line">MyClass mc( 42 );</div><div class="line">useBox( mc );</div><div class="line"></div><div class="line">useBox( <span class="stringliteral">&quot;Ooops&quot;</span> );</div></div><!-- fragment --><p> The output is:</p>
<div class="fragment"><div class="line">Value: 42</div><div class="line">Unknown boxed type</div></div><!-- fragment --><p> As can be seen from the sample, when template method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">Box::IsType</a> is used to determine the type of a boxed value, the type is specified with the template parameter of the method. The implementation of the method is very simple and thus performs fast: the method compares the pointer to the boxer singleton stored in the box with that boxer singleton that would be used if a value of template parameter <code>TBoxable</code> was boxed. Now, due to the template meta programming, this is quite all done by the compiler at compile time.</p>
<p><a class="anchor" id="alib_namespace_boxing_basics_nonbij"></a></p><h2>3.5 Non-Bijective Type Mapping</h2>
<p>There is another small but very important detail hidden in the sample code of the previous chapter: Although a reference of an object of type <b>MyClass</b> is passed to the implicit constructor call of class <b>Box</b>, what we are asking for when using the box, is a <b>pointer</b> to the class. So, what happens then if we pass a pointer?</p>
<p>With code: </p><div class="fragment"><div class="line">MyClass mc( 42 );</div><div class="line">useBox( mc );</div><div class="line">useBox( &amp;mc );</div></div><!-- fragment --><p> The output is:</p>
<div class="fragment"><div class="line">Value: 42</div><div class="line">Value: 42</div></div><!-- fragment --><p> Note that we have not changed the code of method <b>useBox</b> above. The interesting thing is that it seems to be irrelevant if we pass a reference or a pointer to an object when boxing it. At first sight, this might be confusing to a C++ programmer - but it is intended design. Mathematically spoken, <b>ALib Boxing</b> implements a <b>non-bijective</b> mapping of C++ types and boxed types. In other words: two different C++ types can be mapped and boxed to the same boxed type.</p>
<p>The benefit of this was demonstrated already: method <b>useBox</b> did not need to be extended to support a next type check. And furthermore, there is no need for the programmer to care about adding an ampersand <code>'&amp;'</code> when passing the object. Reconsidering the goals of <b>ALib Boxing</b>, this makes a lot of sense and still <b>ALib Boxing</b> is type safe!</p>
<p>Of-course, the drawback is, that once the object is boxed, you can not determine any more if it came from a pointer or an object.</p>
<p>What was observed is true for the default behaviour of boxing. Default in the sense that custom type <b>MyClass</b> was boxed without giving explicit instructions to <b>ALib Boxing</b> on how to do this. The default behavior maps</p><ul>
<li>Non-pointer types to pointer versions of the types (<code>T</code> &rarr; <code>T*</code>) and</li>
<li>Pointer types to itself (<code>T*</code> &rarr; <code>T*</code> ).</li>
</ul>
<p>But we can change the way any C++ type is boxed. Let us build a sample where a reference to a type is boxed as such:</p>
<div class="fragment"><div class="line"><span class="comment">// declare a class in our namespace</span></div><div class="line"><span class="keyword">namespace </span>dox_boxing_bijective {</div><div class="line"></div><div class="line">    <span class="keyword">class </span>MyBijBoxed</div><div class="line">    {</div><div class="line">        <span class="keyword">public</span>:</div><div class="line">            <span class="keywordtype">int</span>      value;</div><div class="line"></div><div class="line">            MyBijBoxed( <span class="keywordtype">int</span> pValue ) : value(pValue)    {}</div><div class="line">    };</div><div class="line"></div><div class="line">} <span class="comment">//namespace dox sample</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// specialize template struct/functions of namespace aworx::lib::boxing</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceaworx.html">aworx</a> { <span class="keyword">namespace </span>lib { <span class="keyword">namespace </span>boxing {</div><div class="line"></div><div class="line"><span class="comment">// define boxing for types MyBijBoxed and MyBijBoxed*</span></div><div class="line"><a class="code" href="group__GrpALibMacros.html#ga27d2168a54be432345fb17c4d3a5f614">ALIB_BOXING_SPECIALIZE_CB_CUB</a>( dox_boxing_bijective::MyBijBoxed , dox_boxing_bijective::MyBijBoxed , <span class="keyword">false</span>, <span class="keyword">true</span> );</div><div class="line"><a class="code" href="group__GrpALibMacros.html#ga8c3e36e52f60303e7639ae48b146f0d6">ALIB_BOXING_SPECIALIZE</a>(        dox_boxing_bijective::MyBijBoxed*, dox_boxing_bijective::MyBijBoxed*, <span class="keyword">false</span>, <span class="keyword">true</span> );</div><div class="line"></div><div class="line"><span class="comment">// define T_Boxing::Boxing and T_Boxing::Unboxing for type MyBijBoxed (not needed for MyBijBoxed*)</span></div><div class="line"><span class="keyword">inline</span>  <span class="keywordtype">void</span>  <a class="code" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#adfa6c5fa593667614c5c9346247b4c1d">T_Boxing&lt;dox_boxing_bijective::MyBijBoxed&gt;::Boxing</a>(<a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp; box, <span class="keyword">const</span> dox_boxing_bijective::MyBijBoxed&amp; o)</div><div class="line">{</div><div class="line">    box.data.Value= <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx_1_1lib_1_1boxing.html#aa3e009a14ed9d13b3f9cfac1ac29bee5">boxvalue</a> <span class="keyword">&gt;</span>( o.value );</div><div class="line">    box.data.Length= 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">inline</span>  dox_boxing_bijective::MyBijBoxed <a class="code" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a5dfd7dc3e9e72651fd2441d71bc56163">T_Boxing&lt;dox_boxing_bijective::MyBijBoxed&gt;::Unboxing</a>( <span class="keyword">const</span> <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp; box )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> dox_boxing_bijective::MyBijBoxed( static_cast&lt;int&gt;( box.data.Value ) );</div><div class="line">}</div><div class="line"></div><div class="line">}}} <span class="comment">// namespace aworx::lib::boxing</span></div><div class="line"></div><div class="line"><span class="comment">// back to our namespace</span></div><div class="line"><span class="keyword">namespace </span>dox_boxing_bijective {</div><div class="line"></div><div class="line"><span class="comment">// boxing test method</span></div><div class="line"><span class="keywordtype">void</span> useBox( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box )</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a>&lt;MyBijBoxed*&gt;() )</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Found a boxed pointer to MyBijBoxed&quot;</span>;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; Value: &quot;</span>  &lt;&lt; box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;MyBijBoxed*&gt;()-&gt;value  &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a>&lt;MyBijBoxed&gt;() )</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Found a boxed reference to MyBijBoxed&quot;</span>;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot; Value: &quot;</span>  &lt;&lt; box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;MyBijBoxed&gt;().value  &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">}<span class="comment">// namespace</span></div></div><!-- fragment --><p> Invoking the test method with a reference and with a pointer: </p><div class="fragment"><div class="line">MyBijBoxed mb(13);</div><div class="line">useBox( mb );</div><div class="line">useBox( &amp;mb );</div></div><!-- fragment --><p> ..leads to the following output: </p><div class="fragment"><div class="line">Found a boxed reference to MyBijBoxed Value: 13</div><div class="line">Found a boxed pointer to MyBijBoxed Value: 13</div></div><!-- fragment --><p> From the output we can see that now a pointer type is distinguished from a value or reference type when boxing an instance of class <b>MyBijBoxed</b>.<br />
 Some notes on the code:</p>
<ul>
<li>To define a custom mapping, struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">aworx::lib::boxing::T_Boxing</a> needs to be specialized. Helper macro <a class="el" href="group__GrpALibMacros.html#ga8c3e36e52f60303e7639ae48b146f0d6">ALIB_BOXING_SPECIALIZE</a> is used in this sample for doing this (which is in general recommended).</li>
<li>We need to specialize <b>T_Boxing</b> for both types, although the default implementation had mapped <b>MyBijBoxed*</b> already to identical type <b>MyBijBoxed*</b>. The reason for this is that if we only customized the mapping only for <b>MyBijBoxed</b>, then the default implementation had detected that and had boxed type <b>MyBijBoxed*</b> also as a value type!</li>
<li>For type <b>MyBijBoxed</b>, specializations of methods <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#adfa6c5fa593667614c5c9346247b4c1d">T_Boxing::Boxing</a> and <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a5dfd7dc3e9e72651fd2441d71bc56163">T_Boxing::Unboxing</a> are given. They copy the value of the object into the box.</li>
<li>For type <b>MyBijBoxed*</b>, <b>no</b> specialization for these methods are given. Here we can rely on the default implementation, which copies the pointer.</li>
</ul>
<p>Well, this sample, is really just a sample! It seldom makes sense - or is even possible - to box custom types as <b>values</b>. The reason is the very limited "data space" in class <b>Box</b>. We gave the sample because it is important to understand these basics for later chapters of this documentation:</p><ul>
<li>When it comes to boxing fundamental C++ types, the non-bijective approach is very helpful by greatly simplifying the use of boxed values.</li>
<li>In the area of boxing arbitrary string types (<code>char*</code>, <code>std::string</code>, <code>QTString</code>, <b>ALib Strings</b>, etc.), this mechanism does not only simplify things, it also allows to write methods that process extern types which are not "known" to them!</li>
</ul>
<p>Let us summarize and repeat the important takeaways of this chapter.<br />
 </p><dl class="section user"><dt>Important:</dt><dd><ol type="1">
<li>The mapping of types is not bijective: Two or more <b>C++ types</b> may be mapped (boxed) to the same resulting <b>"boxed type"</b>.</li>
<li>Only the resulting types (the boxed types), need to be checked and retrieved when using boxes.</li>
<li>The mapping of any C++ type is customizable.</li>
<li>By default, values (references) and pointers of a C++ type get both boxed to the pointer type (<code>T</code> &rarr; <code>T*</code>, <code>T*</code> &rarr; <code>T*</code>).<br />
 As a result (in the default case) there is no need to add either '&amp;' or '*'! when passing "something" to the constructor of class <b>Box</b>, while still everything is type-safe.</li>
<li>In respect to values and pointers of the same type, the following options for boxing are possible:<ul>
<li>No specialization: default (as described in point 4.)</li>
<li>Exclusive specialization of <code>T*</code>: Same result types as with no specialization, but optional custom boxing of the pointer.</li>
<li>Exclusive specialization of <code>T:</code> Both, <code>T</code> and <code>T*</code> get boxed as <code>T</code>. Optional custom boxing/unboxing of <code>T</code> applies to <code>T*</code> as well. If in this case <code>nullptr</code> is boxed, then the raw value of the boxed will become <code>0</code>. This possibility has to be taken into account on unboxing.</li>
<li>Specialization of both types: <code>T</code> gets boxed as <code>T</code>, and <code>T*</code> as <code>T*</code>. Both types can have custom boxing/unboxing as needed.</li>
</ul>
</li>
</ol>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In later chapter <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_boxedas">4.5 Boxing Types As They Are</a> a mechanism is shown that allows to suppress non-bijective boxing.</dd></dl>
<p><a class="anchor" id="alib_namespace_boxing_types"></a></p><h1>4. Arrays, Fundamental Types and Strictness of Unboxing</h1>
<p><a class="anchor" id="alib_namespace_boxing_types_arrays"></a></p><h2>4.1 Boxing Arrays and Vectors</h2>
<h3>4.1.1 C++ Arrays</h3>
<p>Before we talk about boxing fundamental types, let us quickly talk about boxing arrays. We modify the simple sample above to print the contents of <code>int</code> arrays.:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> useBox( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box )</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ad34718fb8f3109b7ee870650ae8dedbf">IsArrayOf</a>&lt;<span class="keywordtype">int</span>&gt;() )</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;int[&quot;</span> &lt;&lt; box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a>() &lt;&lt; <span class="stringliteral">&quot;]= {&quot;</span>;</div><div class="line">        <span class="keywordflow">for</span>( <a class="code" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">aworx::integer</a> i= 0; i &lt; box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a>(); ++i )</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> ( i != 0 ) std::cout &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">            std::cout &lt;&lt; box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a974225964bd92b7338e69557376719e1">UnboxElement</a>&lt;<span class="keywordtype">int</span>&gt;( i );</div><div class="line">        }</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;}&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> A test invocation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> intArray[3]= { 11, 12, 13 };</div><div class="line">useBox( intArray );</div></div><!-- fragment --><p> Leads to the following result:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>[3]= {11, 12, 13}</div></div><!-- fragment --><p>For array types, method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">Box::IsType</a> is not applicable. The reason is, that it would not be possible to ask for arrays of arbitrary size. The template parameter <b>TBoxable</b> might be <code>int</code>[3] or <code>int</code>[25], but can not be <code>int</code>[] or similar. This is not supported by C++. Therefore, we need to use template method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ad34718fb8f3109b7ee870650ae8dedbf">Box::IsArrayOf</a>, and in this case <code>IsArrayOf&lt;int&gt;()</code> to detect the array.</p>
<dl class="section note"><dt>Note</dt><dd>With method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#aebef9889d05411b93c68c9a7d9d773cf">Box::IsArray</a>, there is a second, more general method existing, which is not a template method and returns true if the box contains an array of arbitrary type.<br />
 In addition, method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a0a3c77489682d92eebd69ad2a5c0824e">Box::ArrayElementSize</a> returns the size of elements stored in the array.</dd></dl>
<p>Likewise method <b>Box::IsType</b>, method <b>Box::Unbox</b> is not applicable for array types. Instead, method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a974225964bd92b7338e69557376719e1">Box::UnboxElement</a> is to be used to unbox single elements of an array. The length of an array is received with <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a78a515bdd031a8d3b713bb05edcf126c">Box::Length</a>. Both methods are used in the sample above.</p>
<h3>4.1.2 Multi-Dimensional C++ Arrays</h3>
<p>As already mentioned, <b>ALib Boxing</b> does not provide a similar solution for multi-dimensional arrays. When multi-dimensional arrays are boxed and unboxed, the sizes of the higher dimensions need to be known:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> mArray[2][3] = {{ 1,2,3 },{ 4,5,6 } };</div><div class="line"><a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a> box( mArray );</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Is int[][3]: &quot;</span> &lt;&lt; box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ad34718fb8f3109b7ee870650ae8dedbf">IsArrayOf</a>&lt;<span class="keywordtype">int</span>[3]&gt;() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">int (&amp;arraySlice)[3]= box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a974225964bd92b7338e69557376719e1">UnboxElement</a>&lt;<span class="keywordtype">int</span>[3]&gt;(1);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;array[1][2]= &quot;</span> &lt;&lt; arraySlice[2] &lt;&lt; std::endl;</div></div><!-- fragment --><p> Output:</p>
<div class="fragment"><div class="line">Is <span class="keywordtype">int</span>[][3]: 1</div><div class="line">array[1][2]= 6</div></div><!-- fragment --><p> If more dimensions need to be boxed and unboxed with keeping the (runtime) information of the sizes of the higher dimensions, then those arrays have to be wrapped in a custom (template) type that allows to retrieve the sizes prior to boxing them and restores them on unboxing. We do not consider this a huge drawback for the boxing library, especially when reconsidering its <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_intro_goals">goals</a>. Also, we do not provide a built-in implementation for this.</p>
<dl class="section note"><dt>Note</dt><dd>Of-course, alike the sampled arrays of type <code>int</code>, any element type can be boxed in the same way.</dd></dl>
<h3>4.1.3 Rationale and Technical Background</h3>
<p>The special treatment of arrays with <b>ALib Boxing</b> imposes advantages and disadvantages and hence is the result of a design decision. Alternatives to this implementations are:</p>
<ol type="1">
<li>Storing arrays as pointers to the element type with forgetting their length, or</li>
<li>storing even multi-dimensional arrays the way it is done with one-dimensional arrays.</li>
</ol>
<p>The advantages of the approach taken are:</p><ul>
<li>One-dimensional arrays can be accessed in a type safe way: <b>ALib Boxing</b> distinguishes between a simple pointer to a type and an array of a type.</li>
<li>The length of the first dimension of an array - if known to the compiler - is automatically stored.</li>
</ul>
<p>The disadvantages are:</p><ul>
<li>An extra field for the length of the array needs to be stored with every <b>Box</b> object, even if the type does not represent an array.</li>
<li>Multi-dimensional arrays loose the size of the dimensions starting with the second, even if known to the compiler when boxing.</li>
<li>The Complexity of the API and its use increases, e.g. with extra interface methods <b>Box::IsArray</b>, <b>Box::IsArrayOf</b>, <b>Box::ArrayElementSize</b> and <b>Box::UnboxElement</b>.</li>
</ul>
<p>Technically, arrays are always stored as a pointer to the first element and the length of the array. While the process of boxing and unboxing values in general is customizable, this not true for boxing C++ arrays and not true unboxing any type that was boxed as an array.</p>
<p>This has the following consequences:</p>
<ul>
<li>Standard or custom collection types can only be boxed as arrays, if they organize their values in a block of memory, like class <code>std::vector</code> does.</li>
<li><p class="startli">To avoid receiving each element one by one using <b>Box::UnboxElement</b>, the address of the first element can be taken and pointer arithmetic is allowed. The sample from above hence can also be (more efficiently!) written as:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> useBoxAlternativeImplementation( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box )</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> ( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ad34718fb8f3109b7ee870650ae8dedbf">IsArrayOf</a>&lt;<span class="keywordtype">int</span>&gt;() )</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;int[&quot;</span> &lt;&lt; box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a>() &lt;&lt; <span class="stringliteral">&quot;]= {&quot;</span>;</div><div class="line">        <span class="keywordtype">int</span>* intArr= &amp;box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a974225964bd92b7338e69557376719e1">UnboxElement</a>&lt;<span class="keywordtype">int</span>&gt;( 0 );          <span class="comment">// &lt;- changed here...</span></div><div class="line">        <span class="keywordflow">for</span>( <a class="code" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">aworx::integer</a> i= 0; i &lt; box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a>(); ++i )</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> ( i != 0 ) std::cout &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div><div class="line">            std::cout &lt;&lt; intArr[i];                        <span class="comment">// &lt;- ...and here.</span></div><div class="line">        }</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;}&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></li>
</ul>
<h3>4.1.4 Boxing Vectors</h3>
<p>The term "Vectors" here means collection type <code>std::vector&lt;T, std::allocator&lt;T&gt;&gt;</code> and similar custom (3rd party) types that store their elements in a single memory sequence. <b>ALib Boxing</b> provides built-in support for class <code>std::vector</code>. Objects of the type are boxed to arrays of the element type, by requesting a vectors' allocated memory (method <code>std::vector::data</code>) and storing this pointer besides its size. Consequently, the vector object itself can not be unboxed from the type! The advantage of this approach is (as with any non-bijective type mapping) that the code that processes boxes needs to check for arrays of a certain element type only. Separated checks for other vector types are not needed.</p>
<p>This behavior can be switched off with compilation symbol <a class="el" href="group__GrpALibCompilerSymbols.html#ga61f9e13ca92fd465552273e26d7f1356">ALIB_FEAT_BOXING_STD_VECTOR_OFF</a>.</p>
<p>The following code snippet is taken from header file <code>"boxing.hpp"</code> and is all that is needed. Struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">T_Boxing</a> is specialized using a template! The code can be used as a recipe on how to box other custom vector-like collection types:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#if ALIB_FEAT_BOXING_STD_VECTOR</span></div><div class="line"><span class="comment">    /**</span></div><div class="line"><span class="comment">     * Specialization of struct \b %T_Boxing for template type &lt;c&gt;std::vector&lt;T, std::allocator&lt;T&gt;&gt;&lt;/c&gt;</span></div><div class="line"><span class="comment">     * Instead of boxing a pointer to the vector object, a boxed array is stored, hence a pointer</span></div><div class="line"><span class="comment">     * to the first element contents and the array length.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * To suppress this default boxing behavior for type \c std::vector, use compilation</span></div><div class="line"><span class="comment">     * symbol \ref ALIB_FEAT_BOXING_STD_VECTOR_OFF.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TElem&gt;  <span class="keyword">struct </span>T_Boxing&lt;<a class="code" href="namespacestd.html">std</a>::vector&lt;TElem&gt; &gt; : std::true_type</div><div class="line">    {<span class="comment"></span></div><div class="line"><span class="comment">        /** The vector type becomes boxed array type. */</span></div><div class="line">        <span class="keyword">using</span> <a class="code" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a92442bdba7916947a2e91658a44f79db">Type</a>= TElem;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        /** Boxing as array.</span></div><div class="line"><span class="comment">         *  @return Constant \c true */</span></div><div class="line">        <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> <a class="code" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#afd706fcc8338f6c74664e37ff9c672bb">IsArray</a>()           { <span class="keywordflow">return</span> <span class="keyword">true</span>;  }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        /** The type is not unboxable.</span></div><div class="line"><span class="comment">         *  @return Constant \c false */</span></div><div class="line">        <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> <a class="code" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a480f352bde129b4856313c6b2c77eafa">IsUnboxable</a>()       { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        /** Denotes that default boxing is  overwritten.</span></div><div class="line"><span class="comment">         *  @return Constant \c true */</span></div><div class="line">        <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> <a class="code" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#aefb0e0f2f3b71d443b0f590698407367">HasCustomBoxing</a>()   { <span class="keywordflow">return</span> <span class="keyword">true</span>;  }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        /** Denotes that default Unboxing is not overwritten</span></div><div class="line"><span class="comment">         *  @return Constant \c false */</span></div><div class="line">        <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> <a class="code" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a7c300d564618b287a95515308e0dc5fd">HasCustomUnboxing</a>() { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        /**</span></div><div class="line"><span class="comment">         * Implementation of custom boxing for template class std::vector</span></div><div class="line"><span class="comment">         * @param box   The target box.</span></div><div class="line"><span class="comment">         * @param value The vector value to box.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">static</span> <span class="keywordtype">void</span>           <a class="code" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#adfa6c5fa593667614c5c9346247b4c1d">Boxing</a>(<a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp; box, <span class="keyword">const</span> std::vector&lt;TElem&gt;&amp; value);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        /**</span></div><div class="line"><span class="comment">         * Declaration of unboxing. Needed for TMP compilation, while no implementation is given.</span></div><div class="line"><span class="comment">         * @param box   Never used, as never invoked.</span></div><div class="line"><span class="comment">         * @return Never invoked.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">static</span> std::vector&lt;TElem&gt; <a class="code" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a5dfd7dc3e9e72651fd2441d71bc56163">Unboxing</a>(<span class="keyword">const</span> <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp; box);</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> TElem&gt;</div><div class="line">    <span class="keywordtype">void</span> T_Boxing&lt;std::vector&lt;TElem&gt; &gt;<a class="code" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#adfa6c5fa593667614c5c9346247b4c1d">::Boxing</a>( <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp; box, std::vector&lt;TElem&gt; <span class="keyword">const</span>&amp; value )</div><div class="line">    {</div><div class="line">        <span class="comment">// initialize memory. (It is unexpected to be executed on any supported platform)</span></div><div class="line">        <span class="keywordflow">if</span>( <span class="keyword">sizeof</span>(TElem*) &lt; <span class="keyword">sizeof</span>( <a class="code" href="namespaceaworx_1_1lib_1_1boxing.html#aa3e009a14ed9d13b3f9cfac1ac29bee5">boxvalue</a>) )</div><div class="line">            box.data.Value= <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceaworx_1_1lib_1_1boxing.html#aa3e009a14ed9d13b3f9cfac1ac29bee5">boxvalue</a> <span class="keyword">&gt;</span>( 0 );</div><div class="line"></div><div class="line">        <span class="comment">// copy the pointer using memcpy (must not be done by casting!)</span></div><div class="line">        <span class="keyword">const</span> TElem* pData= value.data();</div><div class="line">        memcpy( &amp;box.data.Value, &amp;pData, <span class="keyword">sizeof</span>(TElem*) );</div><div class="line"></div><div class="line">        <span class="comment">// set the length</span></div><div class="line">        box.data.Length=  (<a class="code" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>) value.size();</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p><a class="anchor" id="alib_namespace_boxing_types_ftypes"></a></p><h2>4.2 Boxing Fundamental Types</h2>
<p>In the previous chapters enough information was given, to now start boxing C++ fundamental types. All that is needed to do, is to specialize struct <b>T_Boxing</b> for the types. But as we have seen in chapter <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_basics_nonbij">Non-Bijective Type Mapping</a>, there are different options to do that: We are free to choose different target types when boxing one certain type. This is why the built-in code for boxing fundamental types is just one of many possible ways to do it. Thus, module <b>ALib Boxing</b> allows to set a custom version in place that may assign the types differently. A reason to do so might be, to be able to distinguish between various original fundamental types when using the boxes.</p>
<dl class="section note"><dt>Note</dt><dd>This freedom of choice is <b>limited</b> depending on the distribution of <b>ALib Boxing</b>. See <a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1ftypes.html">namespace ftypes</a> for further information.</dd></dl>
<p>To understand the built-in boxing of fundamental types, it may be easiest to look at a code sample that uses it:</p>
<div class="fragment"><div class="line"><span class="comment">// This method prints type and value for 12 different boxed types</span></div><div class="line"><span class="keywordtype">void</span> useBox( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box )</div><div class="line">{</div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> t( <span class="stringliteral">&quot;  Type: &quot;</span> );</div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> v( <span class="stringliteral">&quot;  Value: &quot;</span> );</div><div class="line"></div><div class="line">         <span class="keywordflow">if</span>( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a>&lt;<span class="keywordtype">bool</span>             &gt;() ) { t &lt;&lt; <span class="stringliteral">&quot;bool       &quot;</span>; v &lt;&lt; (box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<span class="keywordtype">bool</span>             &gt;() ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span> ); }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a>&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">aworx::boxed_int</a> &gt;() ) { t &lt;&lt; <span class="stringliteral">&quot;boxed_int  &quot;</span>; v &lt;&lt;  box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">aworx::boxed_int</a> &gt;(); }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a>&lt;<a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">aworx::boxed_uint</a>&gt;() ) { t &lt;&lt; <span class="stringliteral">&quot;boxed_uint &quot;</span>; v &lt;&lt;  box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">aworx::boxed_uint</a>&gt;(); }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a>&lt;<span class="keywordtype">double</span>           &gt;() ) { t &lt;&lt; <span class="stringliteral">&quot;double     &quot;</span>; v &lt;&lt;  box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<span class="keywordtype">double</span>           &gt;(); }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a>&lt;<span class="keywordtype">char</span>             &gt;() ) { t &lt;&lt; <span class="stringliteral">&quot;char       &quot;</span>; v &lt;&lt;  box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<span class="keywordtype">char</span>             &gt;(); }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a>&lt;<span class="keywordtype">wchar_t</span>          &gt;() ) { t &lt;&lt; <span class="stringliteral">&quot;wchar_t    &quot;</span>; v &lt;&lt;  box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<span class="keywordtype">wchar_t</span>          &gt;(); }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a>&lt;char16_t         &gt;() ) { t &lt;&lt; <span class="stringliteral">&quot;char16_t   &quot;</span>; v &lt;&lt;  box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;char16_t         &gt;(); }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a>&lt;char32_t         &gt;() ) { t &lt;&lt; <span class="stringliteral">&quot;char32_t   &quot;</span>; v &lt;&lt;  box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;char32_t         &gt;(); }</div><div class="line"></div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ad34718fb8f3109b7ee870650ae8dedbf">IsArrayOf</a>&lt;<span class="keywordtype">char</span>          &gt;() ) { t &lt;&lt; <span class="stringliteral">&quot;char[]     &quot;</span>; v &lt;&lt;  box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;std::string      &gt;(); }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ad34718fb8f3109b7ee870650ae8dedbf">IsArrayOf</a>&lt;<span class="keywordtype">wchar_t</span>       &gt;() ) { t &lt;&lt; <span class="stringliteral">&quot;wchar_t[]  &quot;</span>; v &lt;&lt;  box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;std::wstring     &gt;(); }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ad34718fb8f3109b7ee870650ae8dedbf">IsArrayOf</a>&lt;char16_t      &gt;() ) { t &lt;&lt; <span class="stringliteral">&quot;char16_t[] &quot;</span>; v &lt;&lt;  box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;std::u16string   &gt;(); }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span>( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ad34718fb8f3109b7ee870650ae8dedbf">IsArrayOf</a>&lt;char32_t      &gt;() ) { t &lt;&lt; <span class="stringliteral">&quot;char32_t[] &quot;</span>; v &lt;&lt;  box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;std::u32string   &gt;(); }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;UNKNOWN TYPE&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assert(0);</div><div class="line">    }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; t &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The sample uses classes <code>std::string</code>, <code>std::wstring</code>, <code>std::u16string</code> and <code>std::u32string</code> for unboxing character arrays. To be able to to this, header file <code>"alib/compatibility/std_string.hpp"</code> needs to be included. All details of boxing and unboxing character arrays and string types are discussed in later chapter <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_strings">6. Boxing Strings</a>.</dd></dl>
<p>With the these invocations:</p>
<div class="fragment"><div class="line"><span class="comment">// We are boxing 34 different fundamental types here:</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;bool:&quot;</span> &lt;&lt; std::endl;</div><div class="line">{ <span class="keywordtype">bool</span>      val= <span class="keyword">true</span>;  useBox(  val ); useBox( &amp;val ); }</div><div class="line"></div><div class="line">std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;integer types:&quot;</span> &lt;&lt; std::endl;</div><div class="line">{         int8_t   val=  -1;   useBox(  val ); useBox( &amp;val ); }</div><div class="line">{         int16_t  val=  -2;   useBox(  val ); useBox( &amp;val ); }</div><div class="line">{         int32_t  val=  -3;   useBox(  val ); useBox( &amp;val ); }</div><div class="line">{         int64_t  val=  -4;   useBox(  val ); useBox( &amp;val ); }</div><div class="line">{  <a class="code" href="namespaceaworx.html#adea1bda61bf659bfe398c7f2f13242df">aworx::intGap_t</a> val=  -5;   useBox(  val ); useBox( &amp;val ); }</div><div class="line">{        uint8_t   val=   1;   useBox(  val ); useBox( &amp;val ); }</div><div class="line">{        uint16_t  val=   2;   useBox(  val ); useBox( &amp;val ); }</div><div class="line">{        uint32_t  val=   3;   useBox(  val ); useBox( &amp;val ); }</div><div class="line">{        uint64_t  val=   4;   useBox(  val ); useBox( &amp;val ); }</div><div class="line">{ <a class="code" href="namespaceaworx.html#a34d1e1a0600952dbf9f562aed36b873f">aworx::uintGap_t</a> val=   5;   useBox(  val ); useBox( &amp;val ); }</div><div class="line"></div><div class="line"></div><div class="line">std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;float/double:&quot;</span> &lt;&lt; std::endl;</div><div class="line">{ <span class="keywordtype">float</span>     val= 3.14f;useBox(  val );  useBox( &amp;val ); }</div><div class="line">{ <span class="keywordtype">double</span>    val= 3.14; useBox(  val );  useBox( &amp;val ); }</div><div class="line"></div><div class="line"></div><div class="line">std::cout &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Character types: Must not be passed as pointers!&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"><span class="keywordtype">char</span>      c=    <span class="charliteral">&#39;a&#39;</span>;        useBox( c   );</div><div class="line"><span class="keywordtype">wchar_t</span>   wc=  L<span class="stringliteral">&#39;\u03B2&#39;</span>;   useBox( wc  );</div><div class="line">char16_t  u16= u<span class="stringliteral">&#39;\u03B3&#39;</span>;   useBox( u16 );</div><div class="line">char32_t  u32= U<span class="stringliteral">&#39;\u03B4&#39;</span>;   useBox( u32 );</div><div class="line"></div><div class="line"></div><div class="line">std::cout &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;...instead character pointer types get boxed to character arrays!&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"><span class="keyword">const</span>  <span class="keywordtype">char</span>    *     cString=   <span class="stringliteral">&quot;abc&quot;</span>;                 useBox(    cString );</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">wchar_t</span>  *    wCString=  L<span class="stringliteral">&quot;\u03B1\u03B2\u03B3&quot;</span>;  useBox(   wCString );</div><div class="line"><span class="keyword">const</span>  char16_t*  u16CString=  u<span class="stringliteral">&quot;\u03B4\u03B5\u03B6&quot;</span>;  useBox( u16CString );</div><div class="line"><span class="keyword">const</span>  char32_t*  u32CString=  U<span class="stringliteral">&quot;\u03B7\u03B8\u03B9&quot;</span>;  useBox( u32CString );</div></div><!-- fragment --><p> the following output is generated:</p>
<div class="fragment"><div class="line">bool:</div><div class="line">  Type: <span class="keywordtype">bool</span>           Value: <span class="keyword">true</span></div><div class="line">  Type: <span class="keywordtype">bool</span>           Value: <span class="keyword">true</span></div><div class="line"></div><div class="line"><a class="code" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> types:</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>      Value: -1</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>      Value: -1</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>      Value: -2</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>      Value: -2</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>      Value: -3</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>      Value: -3</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>      Value: -4</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>      Value: -4</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>      Value: -5</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">boxed_int</a>      Value: -5</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">boxed_uint</a>     Value: 1</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">boxed_uint</a>     Value: 1</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">boxed_uint</a>     Value: 2</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">boxed_uint</a>     Value: 2</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">boxed_uint</a>     Value: 3</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">boxed_uint</a>     Value: 3</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">boxed_uint</a>     Value: 4</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">boxed_uint</a>     Value: 4</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">boxed_uint</a>     Value: 5</div><div class="line">  Type: <a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">boxed_uint</a>     Value: 5</div><div class="line"></div><div class="line"><span class="keywordtype">float</span>/double:</div><div class="line">  Type: <span class="keywordtype">double</span>         Value: 3.140000104904175</div><div class="line">  Type: <span class="keywordtype">double</span>         Value: 3.140000104904175</div><div class="line">  Type: <span class="keywordtype">double</span>         Value: 3.14</div><div class="line">  Type: <span class="keywordtype">double</span>         Value: 3.14</div><div class="line"></div><div class="line">Character types: Must not be passed as pointers!</div><div class="line">  Type: <span class="keywordtype">char</span>           Value: a</div><div class="line">  Type: <span class="keywordtype">wchar_t</span>        Value: β</div><div class="line">  Type: char16_t       Value: γ</div><div class="line">  Type: char32_t       Value: δ</div><div class="line"></div><div class="line">...instead character pointer types <span class="keyword">get</span> boxed to character arrays!</div><div class="line">  Type: <span class="keywordtype">char</span>[]         Value: abc</div><div class="line">  Type: <span class="keywordtype">wchar_t</span>[]      Value: αβγ</div><div class="line">  Type: char16_t[]     Value: δεζ</div><div class="line">  Type: char32_t[]     Value: ηθι</div></div><!-- fragment --><p> Method <b>useBox</b> of the sample checks and processes only <b>12 boxed types</b>, while it is able to 'fetch' <b>34 C++ fundamental types</b>. This demonstrates that the fundamental types of C++ get aggregated to a much smaller set of destination types when they are boxed.<br />
 The rules of aggregation can be described as follows:</p><ul>
<li>Integer Types<ul>
<li>Signed integer types (namely <code>int_8</code>, <code>int_16</code>, <code>int_32</code>, <code>int_64</code>, and <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#af9eb8b6fb1aab7d526e9419b10fd5363">intGap_t</a>) are boxed as <a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1ftypes.html#ae01feb126fdae1ecf8a72a70abb605d2">ftypes::boxed_int</a>.</li>
<li>Corresponding unsigned integer types are boxed as <a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1ftypes.html#a5fcdb87abc3548c14049e3c9b6dee7b7">ftypes::boxed_uint</a>.</li>
</ul>
</li>
<li>Type <code>bool</code> remains <code>bool</code> </li>
<li>Type <code>float</code> is converted to <code>double</code>, while <code>double</code> remains <code>double</code>.</li>
<li>Types <code>char</code>, <code>wchar_t</code>, <code>char16_t</code> and <code>char32_t</code> remain identical.</li>
<li>Pointers to these four built-in character types, are boxed to arrays of those types.</li>
</ul>
<p>To summarize, the built-in implementation of boxing fundamental types is providing simplification in respect to using the types while taking into account that information about the originating type gets lost. The most important loss is probably with type <code>float</code> as boxing this types involves an arithmetic conversion to type <code>double</code>, with all its drawbacks.</p>
<p>While this sample already demonstrates the benefit of this simplification, in later chapters <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_interfaces">5. Box Interfaces: Virtual Method Invocation on Boxes</a> and <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_strings">6. Boxing Strings</a> more advantage are shown.</p>
<p><a class="anchor" id="alib_namespace_boxing_types_nonunboxable"></a></p><h1>4.3 Non-Unboxable Types</h1>
<p>In the previous chapters, the principle of <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_basics_nonbij">Non-Bijective Type Mapping</a> was explained and it was demonstrated how the various C++ fundamental types are reduced to only a few target types. As shown, the benefit lies in a simplification and performance gain of the code that is using boxes. Instead of checking for various types of a similar kind, only one boxed type needs to be processed.</p>
<p>Designing <b>ALib Boxing</b>, the question came up if it should still be allowed to receive the original type back when unboxing a type, even if it was converted on boxing:</p><ul>
<li>The advantage if it was allowed would be that no extra conversion (e.g. cast) is needed after unboxing a type that is <b>not</b> the boxed type.</li>
<li>The advantage if it was <b>not</b> allowed would be that <b>unnecessary code</b> that performs type checks and unboxing can be easily avoided, as it is just forbidden!</li>
</ul>
<p>The decision was taken to make this customizable. In general there are three cases:</p>
<p><b>1. Unboxing is impossible and therefore forbidden:</b><br />
 A sample where unboxing a type is not (easily) possible was already shown in chapter <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_arrays">4.1 Boxing Arrays and Vectors</a>. Objects of class <code>std::vector</code> are boxed as arrays: their data is received (using method <code>std::vector::data</code>) together with its length. The original vector object is not stored. Therefore, it can not be unboxed. If unboxing the type should be allowed, then a new object would need to be created, and the values copied into it. This is not in alignment with the goals of <b>ALib Boxing</b> and therefore not implemented.</p>
<p><b>2. Unboxing would be easily possible but still is forbidden:</b><br />
 This is the common practice with the default implementation of boxing C++ fundamental types. For example, type <code>int16_t</code> is boxed as <a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1ftypes.html#ae01feb126fdae1ecf8a72a70abb605d2">boxed_int</a> (an alias to <code>int64_t</code>). Unboxing would just need to cast the value stored "down". However, it makes no difference in performance to add the cast to the value returned from unboxing the <b>boxed_int</b>. By disallowing to unbox all possible source types that lead to the same boxed type, the code that uses a box becomes more efficient.</p>
<p>Here is a quick sample:</p>
<div class="fragment"><div class="line">    <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>         box( (int16_t) 5 );                  <span class="comment">// &#39;int16_t&#39; gets boxed to type &#39;boxed_int&#39;</span></div><div class="line"></div><div class="line">    <span class="comment">// unboxing to allowed type &quot;aworx::boxed_int&quot; is always OK</span></div><div class="line">    <a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">aworx::boxed_int</a>   unboxed=      box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">aworx::boxed_int</a>&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// Unboxing original type is not allowed (would give compilation error):</span></div><div class="line"><span class="comment">//  int16_t     unboxed16=               box.Unbox&lt;int16_t&gt;();</span></div><div class="line"></div><div class="line">    <span class="comment">// unbox allowed &quot;destination&quot; type and then cast to type needed</span></div><div class="line">    int16_t     unboxed16=    (int16_t)  box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">aworx::boxed_int</a>&gt;();</div><div class="line"></div></div><!-- fragment --><p><b>3. Unboxing of a type is allowed:</b><br />
 Sometimes it is very helpful to allow unboxing a certain boxed type back to several possible source types. We will learn later in this documentation details about boxing string types. What we will see is that various string types, like string literals, character pointers, <code>std::string</code>, <b>ALib Strings </b>, QT-Strings, etc., are all boxed to the same destination type, namely array of characters. Now, the implementation allows to unbox all of the named custom string types from boxed character arrays. This means: A function accepting boxed strings, may be invoked with any sort of custom string type, while internally it uses solely "its preferred" type by unboxing into it and processing the string in the format of desire!</p>
<p>Struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">aworx::lib::boxing::T_Boxing</a> includes method <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a480f352bde129b4856313c6b2c77eafa">T_Boxing::IsUnboxable</a> that is used to create compilation errors if unboxing is forbidden. The errors are raised (using <code>static_assert</code>) when invoking template methods <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">Box::IsType</a> or <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Box::Unbox</a> for a "forbidden" type if this method returns <code>false</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Even if unboxing is not allowed, still the declarations of methods <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a7c300d564618b287a95515308e0dc5fd">T_Boxing::HasCustomUnboxing</a> and <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a5dfd7dc3e9e72651fd2441d71bc56163">T_Boxing::Unboxing</a> have to be given in the specialization of the struct with an empty definition. This (odd) fact is a matter of the <a href="https://en.wikipedia.org/wiki/Template_metaprogramming">TMP</a> used.</dd></dl>
<p><a class="anchor" id="alib_namespace_boxing_types_boxedas"></a></p><h1>4.4 Boxing Types As They Are</h1>
<p>There might be situations, where the bijective, simplifying nature of <b>ALib Boxing</b> should be suppressed an a type that usually would be converted when boxed, passed as is. To do so, a wrapper class is needed. Such class is provided with template <a class="el" href="classaworx_1_1lib_1_1boxing_1_1BoxedAs.html">BoxedAs&lt;Type&gt;</a>. The class is very simple and stores a reference to the type while accepting references and pointers in its constructors. The only restriction is that no <code>nullptr</code> values must be passed.</p>
<p>In the reference documentation of the class, a <a class="el" href="classaworx_1_1lib_1_1boxing_1_1BoxedAs.html">source code sample</a> is given.</p>
<p>Using this mechanism should be done only if it can not be avoided because the unifying nature of <b>ALib Boxing</b> is <em>undermined</em> this way: Methods that accept boxes as parameters and process them, need dedicated type detection and unboxing code for boxed type <b>BoxedAs&lt;Type&gt;</b>.</p>
<p><a class="anchor" id="alib_namespace_boxing_interfaces"></a></p><h1>5. Box Interfaces: Virtual Method Invocation on Boxes</h1>
<p>In the previous chapters it was shown how <b>ALib Boxing</b> uses C++ techniques like implicit constructor invocation and template meta programming to be able convert any C++ into an object of type <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a>. Reconsidering the <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_intro_goals">goals</a> given in the introduction, then we have met most of them already. But one is missing: Detect the support for interface methods without knowing what type we have in front of us!</p>
<p>To reach this goal, <b>ALib Boxing</b> enables the definition and invocation of virtual methods on boxes. This is very similar to normal virtual method invocations, but as this is working on boxes and class <b><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a></b> can not be virtualized using the normal C++ techniques, we have to defer this task to the singleton of class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html">Boxer</a> which is attached to each box.</p>
<p>In the previous samples, the code that is using a box (methods <b>useBox</b> of the samples), checks for different "known" types, extracts these values of the types and does some type-specific things. With virtual methods, this code is shortened to just one invocation of the virtual method on the box, no matter what type it has.</p>
<p>Module <b>ALib Boxing</b> introduces class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a> which, similar to the boxers, use the singleton design pattern. During the bootstrap (initialization) of a process, interface singletons are attached to boxer singletons. This way, one interface singleton is responsible to implement one or more interface methods for a dedicated boxed type.</p>
<p><a class="anchor" id="alib_namespace_boxing_interfaces_sample"></a></p><h1>5.1 A Simple Interface Sample</h1>
<p>Again it is easiest to explain by using some sample code. Imagine a method is supposed to store boxed objects in a certain format. And this now should be done wit boxed objects of arbitrary type, by invoking a virtual interface method on those.</p>
<p><b>Step 1: Creating the <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a> Type:</b><br />
 What we first need is a new type which represents the interface class. This is created using three pieces of information:</p>
<ol type="1">
<li>The type needs to be derived from class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a>:</li>
<li>In the constructor implementation, the <code>typeid</code> of the class itself has to be passed to the parent constructor .</li>
<li>One abstract virtual method named <b>Invoke</b> has to be added. The first parameter of this virtual method needs to be of type <code>const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">aworx::Box</a>&amp;</code>. It will receive the boxed object that the interface method is invoked on. Other parameters and the return type may be chosen as needed.</li>
</ol>
<p>Here is the interface class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>IStoreInMyFormat : <span class="keyword">public</span> <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">aworx::Interface</a></div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line"></div><div class="line">    IStoreInMyFormat() : <a class="code" href="namespaceaworx.html#aef105b1e431c10dcbb5691cb9814cac8">Interface</a>( typeid(IStoreInMyFormat) ) {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Invoke( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box, <span class="keywordtype">int</span> fileID )   = 0;</div><div class="line">};</div></div><!-- fragment --><p> <b>Step 2: Creating Derived Types Of The New Interface:</b><br />
 Now, let us assume that this interface should be implemented for integer types and literal strings. We need two specializations of the interface class. These specializations in addition inherit from class <a class="el" href="classaworx_1_1lib_1_1lang_1_1Singleton.html">Singleton</a> so that we can get a singleton instance for each of them:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>IStoreInMyFormat_TcharArr : <span class="keyword">public</span> IStoreInMyFormat,</div><div class="line">                                  <span class="keyword">public</span> <a class="code" href="classaworx_1_1lib_1_1lang_1_1Singleton.html">aworx::Singleton</a>&lt;IStoreInMyFormat_TcharArr&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Invoke( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box, <span class="keywordtype">int</span> myFileID )</div><div class="line">    {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Writing value to file(&quot;</span> &lt;&lt; myFileID &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;std::string&gt;()</div><div class="line">             &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>IStoreInMyFormat_Tint : <span class="keyword">public</span> IStoreInMyFormat,</div><div class="line">                              <span class="keyword">public</span> <a class="code" href="classaworx_1_1lib_1_1lang_1_1Singleton.html">aworx::Singleton</a>&lt;IStoreInMyFormat_Tint&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Invoke( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box, <span class="keywordtype">int</span> myFileID )</div><div class="line">    {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Writing value to file(&quot;</span> &lt;&lt; myFileID &lt;&lt; <span class="stringliteral">&quot;): &quot;</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">IsType</a>&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">aworx::boxed_int</a>&gt;())  cout &lt;&lt; box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">aworx::boxed_int</a>&gt;();</div><div class="line">        <span class="keywordflow">else</span>                                 cout &lt;&lt; box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Unbox</a>&lt;<a class="code" href="namespaceaworx.html#a7ce7b3f615ad2b8992291d1692b8691e">aworx::boxed_uint</a>&gt;();</div><div class="line"></div><div class="line">        cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> We decided to have <b>2</b> interface classes that are obviously responsible for <b>3</b> boxed types. This is reached by doing a type check in method <b>IStoreInMyFormat_Tint::Invoke</b>.</p>
<p>In the bootstrap section of our process the singletons of the two interface classes need to be attached to the right boxers. The easiest way to do this is using templated namespace function <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#aa1f769d5f1032bc1cc569f4353f9ccd8">DefineInterface</a>:</p>
<div class="fragment"><div class="line"><span class="comment">// This is to be executed once at bootstrap, e.g. at the start of the main() function</span></div><div class="line">aworx::lib::boxing::DefineInterface&lt;aworx::boxed_int , false, IStoreInMyFormat_Tint    &gt;();</div><div class="line">aworx::lib::boxing::DefineInterface&lt;aworx::boxed_uint, false, IStoreInMyFormat_Tint    &gt;();</div><div class="line">aworx::lib::boxing::DefineInterface&lt;char             , true , IStoreInMyFormat_TcharArr&gt;();</div></div><!-- fragment --><p> This is all that was needed for preparation. Now we can define a function that</p><ul>
<li>is accepting boxed values</li>
<li>checks the availability of an interface specialization on the box using <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#af00a56f400aaf960349d00e50d8effd5">Box::HasInterface</a>, and</li>
<li>invokes the interface.</li>
</ul>
<p>Such method is sampled here:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> storeData( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box )</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> fileID= 5;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ( box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#af00a56f400aaf960349d00e50d8effd5">HasInterface</a>&lt;IStoreInMyFormat&gt;() )</div><div class="line">        box.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ae828c5649908bb8346f1187bb4187936">Invoke</a>&lt;IStoreInMyFormat&gt;( fileID );</div><div class="line"></div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Error: Boxed type does not support interface &#39;IStoreInMyFormat&#39;&quot;</span></div><div class="line">             &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> When we invoke as follows:</p>
<div class="fragment"><div class="line">    storeData( 42 );</div><div class="line">    storeData( <span class="stringliteral">&quot;Hello Boxing&quot;</span> );</div><div class="line">    storeData( 3.14 );</div></div><!-- fragment --><p> ...we will see this result: </p><div class="fragment"><div class="line">Writing value to file(5): 42</div><div class="line">Writing value to file(5): Hello Boxing</div><div class="line"><a class="code" href="namespaceaworx_1_1lib_1_1lang.html#a28287671eaf7406afd604bd055ba4066a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>: Boxed type does not support interface <span class="stringliteral">&#39;IStoreInMyFormat&#39;</span></div></div><!-- fragment --><p> We see, the first two invocations obviously invoked the virtual method, while the third one produced an error. This is correct, as we have no interface defined for boxed type <code>double</code>.</p>
<p>There are some interesting things to note here:</p><ul>
<li>The interface method of the demonstrated custom interface class <b>IStoreInMyFormat</b> has to be named like <b>Invoke</b>. Furthermore, the first parameter has to be a of type <code>const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">aworx::Box</a>&amp;</code>. The other parameter(s) are user specific, the same as the return type is, in our case <code>void</code>.<br />
 This method must not be mixed up with method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ae828c5649908bb8346f1187bb4187936">Box::Invoke</a>. The latter is the templated built-in method of class <b>Box</b>. It takes variadic template arguments of type <b>Arg&amp;&amp;</b> which are passed inside the method together with the reference to the box itself to the custom method <b>Invoke</b>. This is done with so called <a href="http://en.cppreference.com/w/cpp/utility/forward">C++ 11 perfect forwarding</a>, using <code>std::forward</code>.</li>
<li>If the return type of our method was different to <code>void</code>, this return type needed to be specified as a second template parameter (which otherwise defaults to <code>void</code>). For example, if our method returned <code>bool</code>, the invocation would be: <pre class="fragment">      bool result= box.Invoke&lt;IStoreInMyFormat, bool&gt;( fileID );
</pre></li>
<li>The code would perform slightly faster, if we had split the specialization type <b>IStoreInMyFormat_Tint</b> into a signed and an unsigned version. The way it was demonstrated here we have to user an otherwise unnecessary <code>if-statement</code> in the generalized version. At the end of the day, this is a matter of taste and constraints. The disadvantage would of course be the extra class introduced.<br />
 It is important to understand however, that it is possible to attach one interface singleton to more than only one boxable type! In more complicated cases it might be quite reasonable to aggregated several types into one specialization.</li>
</ul>
<p>Because a specialized version of a custom interface class (method) is needed for every type, the fact that <b>ALib Boxing</b> is not bijective as explained <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_basics_nonbij">previously</a>, may be great relief: If C++ types are nicely aggregated to fewer boxed types, then fewer interface specializations are needed.</p>
<p>Advanced users may have a look at class <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply__TApplicable.html">IApply_TApplicable</a> provided with module <b>ALib Strings</b> if packaged together with <b>ALib Boxing</b>. This specialization of interface class <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a> is templated and this way allows to be attached to all types of boxes which represents types that have a built-in or custom support of applying them to objects of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>. This way, this templated interface class can be registered with <b>ALib Boxing</b> in the bootstrap section of a process as follows:</p>
<div class="fragment"><div class="line">    aworx::lib::boxing::DefineInterface&lt;bool      , false, IApply_TApplicable&lt;bool      &gt;&gt;();</div><div class="line">    aworx::lib::boxing::DefineInterface&lt;char      , false, IApply_TApplicable&lt;char      &gt;&gt;();</div><div class="line">    aworx::lib::boxing::DefineInterface&lt;wchar_t   , false, IApply_TApplicable&lt;wchar_t   &gt;&gt;();</div><div class="line">    aworx::lib::boxing::DefineInterface&lt;char16_t  , false, IApply_TApplicable&lt;char16_t  &gt;&gt;();</div><div class="line">    aworx::lib::boxing::DefineInterface&lt;char32_t  , false, IApply_TApplicable&lt;char32_t  &gt;&gt;();</div><div class="line">    aworx::lib::boxing::DefineInterface&lt;boxed_int , false, IApply_TApplicable&lt;boxed_int &gt;&gt;();</div><div class="line">    aworx::lib::boxing::DefineInterface&lt;boxed_uint, false, IApply_TApplicable&lt;boxed_uint&gt;&gt;();</div><div class="line">    aworx::lib::boxing::DefineInterface&lt;double    , false, IApply_TApplicable&lt;double    &gt;&gt;();</div></div><!-- fragment --><p> The same can be done in custom bootstrap code with every applicable custom type!</p>
<p><a class="anchor" id="alib_namespace_boxing_interfaces_default"></a></p><h1>5.2 Default Interfaces</h1>
<p>Sometimes it is useful to have a default interface in place that becomes used in the case that no type specific version of an interface is provided. This concept is similar to C++ virtual methods that are not "pure abstract" and this way are only optionally overwritten in descendant classes. <b>ALib Boxing</b> supports this concept with method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html#a6228b2d41176a6f8fd6489b150dfc5c3">Boxer::DefineDefaultInterface</a>, or preferably with templated namespace function <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a37543d2ad623b3940e735b122fe5d586">DefineDefaultInterface</a> which is a convenience function and internally invokes the first method named.</p>
<p>A useful sample is found with module <b>ALib Strings</b>. If packaged together with <b>ALib Boxing</b>, interface class <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a> becomes available. Specializations of this interface are supposed to append the contents of a box to a given <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>. If no type specific version is registered, the default implementation is used, which writes the type name (using C++ RTTI) and the memory address of the object in hexadecimal format into the string.</p>
<p>The information whether a default implementation of an interface is provided or not, should be documented with each custom interface and is considered "static" piece of information that does never change. If a default implementation is provided, the corresponding interface can be invoked without prior checking for the availability. If an instance of class <b>Box</b> named <b>myBox</b> exists, it is safe to invoke:</p>
<div class="fragment"><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> myAString;</div><div class="line">    myBox.Invoke&lt;<a class="code" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">aworx::IApply</a>&gt;( myAString );</div></div><!-- fragment --><p> which writes the contents of <code>myBox</code> int <code>myAString</code>.</p>
<p>In most cases, method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#af00a56f400aaf960349d00e50d8effd5">Box::HasInterface</a> must not even be used for checking, as it returns <code>true</code> if and only if a type specific interface version is defined. This means that this code:</p>
<div class="fragment"><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> myAString;</div><div class="line">    <span class="keywordflow">if</span>( myBox.HasInterface&lt;<a class="code" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">aworx::IApply</a>&gt;() )</div><div class="line">        myBox.Invoke&lt;<a class="code" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">aworx::IApply</a>&gt;( myAString );</div></div><!-- fragment --><p> will <b>not</b> invoke the virtual box interface for those types that have only the default implementation in place!</p>
<p>While this might be irritating in the first moment, the benefit of this approach is that default interface implementations can be identified and treated differently in the user code:</p>
<div class="fragment"><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> myAString;</div><div class="line">    <span class="keywordflow">if</span>( myBox.HasInterface&lt;<a class="code" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">aworx::IApply</a>&gt;() )</div><div class="line">        myBox.Invoke&lt;<a class="code" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">aworx::IApply</a>&gt;( myAString );</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        myAString &lt;&lt; <span class="stringliteral">&quot;We do not like the default behavior. We exit...&quot;</span>;</div><div class="line">        assert(0);</div><div class="line">    }</div></div><!-- fragment --><p><a class="anchor" id="alib_namespace_boxing_interfaces_built-in"></a></p><h1>5.3 The Built-In Interface Classes</h1>
<dl class="section note"><dt>Note</dt><dd>A quick warning: <b>ALib Boxing</b> is no programming language: It neither provides inheritance, nor polymorphism, and much, much more is missing. Maybe we should not even talk about "virtual method
  invocation" as we do when it comes to boxing interfaces. It is really something different, but it is language and words that we understand and therefore we use it, knowing that we are talking on boxes not on objects!</dd></dl>
<p><b>ALib Boxing</b> interface classes which are available as "default interfaces" may be compared to methods available to root class <b>Object</b> of programming languages like C# or Java. There are three of such default interfaces provided.</p>
<p><b>IEquals:</b> <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a> <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IEquals.html">IEquals</a> is defined to return <b>true</b>, if the contents of a box equals the given parameter. The parameter to provided is declared as <code>const Box%</code>. Using this 'trick', compared values are boxed prior to compare them. This way, the implementation already works quite well in some respect as here simply the type and value of two boxes get compared. For custom class types, which by default get stored as a pointer to an object of the custom class, this way a pointer comparison is made. If necessary, a specialization of this interface for custom types may be provided, which does a logical comparison of the contents of such types. Later in this document, we will talk about boxing string types. Here, such deeper look into the contents of the various boxable string types (including 3rd party library strings) may make sense. It all depends on if such comparison is needed the methods that are processing boxes or not.</p>
<p>The built-in <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_ftypes">boxing of fundamental types</a> adds some specialization already:</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1ftypes_1_1IEquals__Tdouble.html">IEquals_Tdouble</a> to compare floating point values.</li>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1ftypes_1_1IEquals__TcharArr.html">IEquals_TcharArr</a> and <a class="el" href="classaworx_1_1lib_1_1boxing_1_1ftypes_1_1IEquals__Twchar__tArr.html">IEquals_Twchar_tArr</a> to character arrays.</li>
</ul>
<p>This is no specialization for integer types and other array types given. Consequently, in the area of fundamental types, the following rules apply:</p><ul>
<li>If two integer types have the same signedness and the same value, <b>IEquals</b> returns <code>true</code>. However, it will return <code>false</code> if the signedness of the originating type is different, even of both share the same value, for example <code>0</code>.</li>
<li>Only if two arrays have the same C++ fundamental element type, the same length and share the same pointer to the data array, this method returns <code>true</code>. It will return <code>false</code> in all other cases, even if the value represented by the array elements are the same.</li>
</ul>
<p>This behavior can be changed (extended) if needed: as it was explained, specializations for fundamental of any interface may be added even if the built-in boxing of fundamental types is chosen (which is mandatory for all <b>ALib</b> distributions apart from the pure <b>ALib Boxing</b> module).</p>
<p><b>IIsNull:</b> <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a> <b>IIsNull</b> introduces the concept of <em>"nullable"</em> types to <b>ALib Boxing</b>. This concept is useful for pointer types or string types and may be adopted for custom types as well. For information on how the default implementation of <b>Alib Boxing</b> defines this concept, by default, refer to the <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsNull.html">reference documentation of class IIsNull</a>.</p>
<p><b>IIsEmpty:</b> <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a> <b>IIsEmpty</b> introduces the concept of <em>"emptiness"</em> to <b>ALib Boxing</b>. This concept is useful for array types or string types and may be adopted for custom types as well. For information on how the default implementation of <b>Alib Boxing</b> defines this concept, by default, refer to the <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsEmpty.html">reference documentation of class IIsEmpty</a>.</p>
<p><a class="anchor" id="alib_namespace_boxing_interfaces_change"></a></p><h1>5.4 Changing The Default Behavior</h1>
<p>The description of <b>ALib Boxing</b> so far showed that - while the core concept is straightforward, lean and clean - different boxing behavior is possibly implemented for C++ types. The degrees of freedom are in three areas:</p><ul>
<li>Mapping of C++ types to boxed types (see <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_basics_nonbij">3.5 Non-Bijective Type Mapping</a>),</li>
<li>the "strictness" about unboxing types that are mapped to other types (see <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_nonunboxable">4.3 Non-Unboxable Types</a>) and</li>
<li>the availability of invokable interfaces.</li>
</ul>
<p>Technically the first two items are not changeable without using preprocessor switches or leaving out header files. Here, specializations of template structs and functions are used and C++ does not allow to change such in later header files. Therefore, <b>ALib</b> provides compilation symbols <a class="el" href="group__GrpALibCompilerSymbols.html#gaac13faf1a75cc977147511eca3c354cb">ALIB_FEAT_BOXING_FTYPES_OFF</a> and <a class="el" href="group__GrpALibCompilerSymbols.html#ga61f9e13ca92fd465552273e26d7f1356">ALIB_FEAT_BOXING_STD_VECTOR_OFF</a> to tweak the behaviour during compilation.</p>
<p>The third one, the definition of interfaces <b>allows</b> overriding an already set interface! It is no problem, to specify a different interface implementation class in a repeated invocation of <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#aa1f769d5f1032bc1cc569f4353f9ccd8">DefineInterface</a> and <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a37543d2ad623b3940e735b122fe5d586">DefineDefaultInterface</a>.</p>
<p>This way, a user of <b>ALib Boxing</b> might replace the default interfaces to suit an applications' need. The warning here is: Changes of interfaces change runtime behavior. This means that the whole process, including library code is affected!</p>
<dl class="section note"><dt>Note</dt><dd>All interface definitions should be made in the bootstrap section of a process. First, built-in definitions should be performed and then custom initializations which extend (or overwrite) then existing definitions. Later chapter <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_usage_bootstrap">8.1 Bootstrapping ALib %Boxing</a> of this document elaborates more on this topic.</dd></dl>
<p><a class="anchor" id="alib_namespace_boxing_strings"></a></p><h1>6. Boxing Strings</h1>
<p><a class="anchor" id="alib_namespace_boxing_strings_chararr"></a></p><h1>6.1 Strings As Character Arrays</h1>
<p>Simple string types are nothing more than an array of characters. Hence, to describe them, a pointer to the beginning of the array is needed and a length. So called <em>C-strings</em> which are generated by the C++ compiler for string literals like <code>"ABC"</code>, are using termination character <code>'\0'</code> instead of a length. A C++ string literal, has a an array type with the array length being the length the string <b>plus 1</b>. For example, literal <code>"ABC"</code> has type <code>char</code>[4] or <code>u"12345"</code> has type <code>char16_t[6]</code>). When boxed, the length of the array is evaluated using TMP and stored in field <a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html#a5f38f944ed993ecb18fb7bbcee7c8f9e">BoxData::Length</a>. However, because with literals the trailing <code>'\0'</code> is counted in the type declaration by the compiler, the stored length has to be decreased by one. This is achieved with partially specialized template method <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a8a046ed78c26c56f05dfe236e40c136b">T_SetArraySize</a>. The whole reason to have this method is to fix the length of literals! Consequently the default implementation of boxing fundamental types, specializes this method for each of the four C++ C-string literal types.</p>
<p>In the moment a literal is assigned to a <b>pointer</b> to the character type, the information about the array length is lost! It may not be clear to all C++ programmers, but in this line of code: </p><pre class="fragment">    const char* cstring= "ABC";
</pre><p>uses an implicit conversion from <code>char</code>[4] to <code>const char*</code>! Along with this conversion, the information that the pointer is a pointer to a zero-terminated string array (C-string) is lost.<br />
</p>
<p>Now, in the following sample: </p><pre class="fragment">    Box box1( "ABC" );
    const char* cstring= "ABC";
    Box box2( cstring )
</pre><p>objects <code>box1</code> and <code>box2</code> share the same boxed type. Unfortunately, as the compiler has casted away the array size, when boxing object <code>cstring</code>, the length of the array is not known when boxing.</p>
<p>A lazy mechanism is implemented to detect the array length:</p><ul>
<li>The length is set to <code>0</code> if a <code>nullptr</code> was boxed or if the first character in the array equals termination character <code>'\0'</code>.</li>
<li>Otherwise, the length is set to <code>-1</code>!</li>
</ul>
<p>By using this approach, built-in interfaces <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsNull.html">IIsNull</a> and <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsEmpty.html">IIsEmpty</a> already work well. Only when needed, for example with specialization of interface <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IEquals.html">IEquals</a> for character array, types, it is checked if the size is <code>-1</code>. If it is, then the true length of the string is evaluated using <code>std::strlen</code>, respectively <code>std::wcslen</code>.</p>
<p>We conclude all assumtions and rules as follows:</p><ul>
<li>All character pointers and string types are boxed to arrays of the corresponding character type.</li>
<li>If the length of the array is known, it is stored with field <b><a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html#a5f38f944ed993ecb18fb7bbcee7c8f9e">BoxData::Length</a></b>.</li>
<li>If the length of the array is not known (when boxing a pointer to a character type), field <b><a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html#a5f38f944ed993ecb18fb7bbcee7c8f9e">BoxData::Length</a></b> is set to <b>-1</b> and it is assumed that the character is zero-terminated!</li>
</ul>
<p>These rules apply to the following parts of <b>ALib Boxing</b></p>
<ol type="1">
<li>The default implementation of <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_ftypes">boxing fundamental types</a>.</li>
<li>The implementation of boxing <a class="el" href="namespaceaworx_1_1lib_1_1strings.html">ALib Strings</a>.</li>
<li>The implementation of boxing 3rd-party types provided with optionally includable header files.<br />
 Among the supported types are <code>std::string</code> (and siblings) and string classes of the <a href="https://www.qt.io">QT Class Library</a>.</li>
</ol>
<p>This is why the use of complete <b>ALib</b> or combined module <b>ALib Boxing and Strings</b> are missing the freedom of choice to use compiler symbol <a class="el" href="group__GrpALibCompilerSymbols.html#gaac13faf1a75cc977147511eca3c354cb">ALIB_FEAT_BOXING_FTYPES_OFF</a> to switch off the built-in boxing of fundamental types!</p>
<dl class="section note"><dt>Note</dt><dd>It is important to understand, that <b>ALib</b> assumes that boxed pointers to character arrays are pointers to zero terminated character arrays! </dd>
<dd>
If character pointers should be boxed that do <b>not</b> point to zero-terminated C-strings, those have to be wrapped in a custom class (with optionally custom boxing and interfaces). Otherwise, unboxing those values and the invocation of certain interface methods lead to undefined behavior.</dd></dl>
<p>The sample of chapter <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_ftypes">4.2 Boxing Fundamental Types</a> used classes <code>std::string</code>, <code>std::wstring</code>, <code>std::u16string</code> and <code>std::u32string</code> for unboxing character arrays and pointers to characer types. Now we will explain how this works.</p>
<p><a class="anchor" id="alib_namespace_boxing_strings_lw_vs_hvy"></a></p><h1>6.2 'Lightweight' And 'Heavy' String Types</h1>
<p>In the moment <b>ALib Boxing</b> is used in combination with module <a class="el" href="namespaceaworx_1_1lib_1_1strings.html">ALib Strings</a>, classes <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::AString</a> become available. The first is a "lightweight" class: It is non-virtual and stores solely the pointer and the length of the string. Class <b>AString</b> instead is 'heavy' in the respect that though it is still not virtual, it provides its own memory management. Both types get boxed to the same destination type, <code>char</code>[], ust as "fundamental" C-strings are.</p>
<p>The advantage of boxing all string types, including custom, 3rd-party types as proposed is that they can be handled in one <code>if</code>-statement:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span>( myBox.IsArrayOf&lt;<span class="keywordtype">char</span>&gt;() )</div><div class="line">    {</div><div class="line">        <span class="comment">// process string...</span></div><div class="line">    }</div></div><!-- fragment --><p> Furthermore, if for all lightweight string types a corresponding mechanism for unboxing such type from a character array is in place, then each of these types may be unboxed, no matter what the original string type was:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span>( myBox.IsArrayOf&lt;<span class="keywordtype">char</span>&gt;() )</div><div class="line">    {</div><div class="line">        <a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a> aworxString= myBox.Unbox&lt;<a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a>&gt;();</div><div class="line">        std::string     stdString= myBox.Unbox&lt;std::string  &gt;();</div><div class="line">    }</div></div><!-- fragment --><p> This is a great simplification and enables code that processes strings to unbox any string to just a (lightweight) string type type of choice.</p>
<p>Of-course, there is a disadvantage: In case of "heavy" string types, it is not possible to unbox the original type. For example, by storing just the buffer and length when boxing objects of class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>, of-course the object itself is lost and is not unboxable. If a an object of a "heavy" string type is needed to be boxed in its original type (e.g. for the purpose of modifying its contents inside the function that processes the box), such objects need to be wrapped as explained in <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_boxedas">4.5 Boxing Types As They Are</a>. The <a class="el" href="classaworx_1_1lib_1_1boxing_1_1BoxedAs.html">documentation of class BoxedAs</a> shows a sample of how to do this with objects of class <b>AString</b>.</p>
<p>In a later chapter, a step by step sample of how boxing custom string types should be implemented is given. But let us first elaborate further what boxing of <b>ALib Strings</b> provides in addition.</p>
<p><a class="anchor" id="alib_namespace_boxing_strings_iapply"></a></p><h1>6.3 Interface IApply</h1>
<p>Class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">AString</a> already supports a TMP-based mechanism to append any sort of custom objects in a string representation (see <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">T_Apply</a>). However, for boxing we can not use this. The reason is obvious: once a type is boxed, the compiler looses information about the boxed type. Therefore, of-course, no template programming allows to append (in <b>AString-terminology</b> to "apply") boxed values.</p>
<p>Consequently, we need a box interface that is invokable on a boxed object and writes the box contents to a given instance of class <b>AString</b>. Such interface is provided with class <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a>. Dedicated specializations exist for character and wide character array types.</p>
<p>For all types which already implement <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">T_Apply</a>, an existing templated specialization can be used! This is provided with template class <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply__TApplicable.html">IApply_TApplicable</a>. As a result, there are two ways of implementing interface <b>IApply</b> for a custom boxable type:</p><ol type="1">
<li>As with other boxing interfaces: Derive the interface class and implement the writing of values of the boxed type to the AString in a custom way. Then attach this interface to the boxing system.</li>
<li><p class="startli">Make the type <em>"applicable"</em> to class <b>AString</b> (as instructed <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">here</a>) and then attach the templated, generic interface <b>IApply_TApplicable</b> to the <b>ALib Boxing</b> system using the following line of code to the bootstrap section of your software: </p><pre class="fragment"> aworx::lib::boxing::DefineInterface&lt;MyType*, false, aworx::lib::strings::boxing::IApply_TApplicable&lt;MyType*&gt;&gt;();
</pre><p class="startli">A simple preprocessor macro is defined with <a class="el" href="group__GrpALibMacros.html#gafe870d103ad063d0ad15942df79d75ff">ALIB_BOXING_DEFINE_IAPPLY_FOR_APPLICABLE_TYPE</a>, which allows to shorten this definition code to: </p><pre class="fragment">  ALIB_BOXING_DEFINE_IAPPLY_FOR_APPLICABLE_TYPE(MyType*)
</pre><p class="startli">(Replace <em>'MyType'</em> with the name of your type in both cases.)</p>
</li>
</ol>
<p>The second approach has the advantage, that this way, the custom type is then directly applicable to class <b>AString</b> - independent from boxing. Therefore, this is the recommended way to proceed.</p>
<p>To close the circle, class <b>Box</b> is made applicable to <b>AString</b>. This means, any box can be applied to <b>AString</b> objects using operator <code>'&lt;&lt;'</code> or method <code>_()</code> (apply). The implementation simply invokes box interface <b>IApply</b> on the <b>AString</b> object. Here is a quick sample code:</p>
<div class="fragment"><div class="line">    <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a> box1( <span class="stringliteral">&quot;The answer is: &quot;</span> );</div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a> box2( 42 );</div><div class="line"></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> aString;</div><div class="line">    aString &lt;&lt; box1 &lt;&lt; box2;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; aString &lt;&lt; std::endl;</div></div><!-- fragment --><p> which produces the output:</p>
<div class="fragment"><div class="line">The answer is: 42</div></div><!-- fragment --><p><a class="anchor" id="alib_namespace_boxing_strings_iformat"></a></p><h1>6.4 Interface IFormat</h1>
<p>Box interface <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a>, introduced in the previous chapter, is used to simply append the contents of a boxed value to an <b>AString</b>. There are no options on formatting the value available.</p>
<p>This is changed with interface <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IFormat.html">IFormat</a> which is very similar to <b>IApply</b> but takes an additional parameter <code>formatSpec</code>, which is a string value providing information about how the contents is written. The format specification is fully type and implementation specific.</p>
<p>For example, <b>ALIb</b> class <a class="el" href="classaworx_1_1lib_1_1time_1_1TicksCalendarTime.html">TicksCalendarTime</a> provides (native) method <a class="el" href="classaworx_1_1lib_1_1time_1_1TicksCalendarTime.html#a9dc9d4b7ee288deeefc5795f562c0ac7">TicksCalendarTime::Format</a> to write time and date values in a human readable, customizable way. This method also requires a format specification. Because <b>TicksCalendarTime</b> is only a helper class, the boxing interface class that invokes <a class="el" href="classaworx_1_1lib_1_1time_1_1TicksCalendarTime.html#a9dc9d4b7ee288deeefc5795f562c0ac7">TicksCalendarTime::Format</a>, is available for boxed values of type <a class="el" href="classaworx_1_1lib_1_1time_1_1Ticks.html">Ticks</a>. The interface attached to boxed values of this type is found with boxing interface class <a class="el" href="classaworx_1_1lib_1_1time_1_1IFormat__TTicks.html">IFormat_TTicks</a>. The implementation of the interface method <b>Invoke</b> is therefore again rather simple:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> IFormat_TTicks::Invoke( <span class="keyword">const</span> <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp; box, <span class="keyword">const</span> <a class="code" href="namespaceaworx.html#ad13481d84c6e592a41d07c64f747c95d">String</a>&amp; formatSpec, <a class="code" href="namespaceaworx.html#a51ace28d988aa0a7ab391f6aaec35f60">AString</a>&amp; target )</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceaworx.html#a0607ccd659418fa7cb9922b2c4ba5f1d">TicksCalendarTime</a> tct( *(box.Unbox&lt;<a class="code" href="namespaceaworx.html#ad270463709a4ae7e7098df40e803e458">Ticks</a>*&gt;()) );</div><div class="line">    tct.Format( formatSpec, target );</div><div class="line">}</div></div><!-- fragment --><p> Boxing interface <b>IFormat</b> is used by <b>ALib</b> internally in module <b>ALib Strings</b> with class <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1Formatter.html">Formatter</a> which is used to format the contents of <b>AString</b> objects. The whole class relies on <b>ALib Boxing</b> and therefore it is not included with the single module distribution of <b>ALib Strings</b> (which excludes boxing).</p>
<p><a class="anchor" id="alib_namespace_boxing_strings_custom"></a></p><h1>6.5 Boxing Custom String Types</h1>
<p>The previous four chapters have shown how fundamental C++ strings types (C-strings), "lightweight" class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a> and rather "heavy" class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> are boxed.</p>
<p>Furthermore, interfaces <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a> and <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IFormat.html">IFormat</a> have been introduced.</p>
<p>ALib provides built-in support for 3rd party string libraries already:</p><ul>
<li>Classes <code>std::string</code>, <code>std::wstring</code>, <code>std::u16string</code> and <code>std::u32string</code>.<br />
 (These types may not really be named "3rd party", but from the <b>ALib</b> perspective, they are because they are not used internally.)</li>
<li>For string types found in <a href="https://www.qt.io">QT Class Library</a>.<br />
</li>
</ul>
<p>More information about support for boxing third party types is given with the documentation of namespace <a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1thirdparty.html">aworx::lib::boxing::thirdparty</a>.</p>
<p>This following chapter wants to provide a recipe on how to implement boxing for a 3rd party "lightweight" string so that it smoothly fits into this setup. We are doing the exercise by walking through the source code from the <code>std::string</code> support as a step by step sample.</p>
<p><b>Step 1:</b><br />
 Within namespace <code>aworx::lib::boxing</code>, we specialize template struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">T_Boxing</a>. The recommended way to do this, is the use of macro <a class="el" href="group__GrpALibMacros.html#ga27d2168a54be432345fb17c4d3a5f614">ALIB_BOXING_SPECIALIZE_CB_CUB</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="group__GrpALibMacros.html#ga27d2168a54be432345fb17c4d3a5f614">ALIB_BOXING_SPECIALIZE_CB_CUB</a>( std::string, <span class="keywordtype">char</span>, <span class="keyword">true</span>, <span class="keyword">true</span> );</div></div><!-- fragment --><p> With this mapping, type <code>std::string</code> is boxed to <code>char</code>[]. And because no specialization for type <code>std::string*</code> is given, this pointer type is treated the same as the value/reference type.</p>
<p>The 4th parameter <code>true</code> of the macro denotes that unboxing of the type is allowed. The version of the macro with suffix <code>"_CB_CUB"</code> specializes struct <b>T_Boxing</b> in a way that custom implementation for boxing and unboxing get declared.</p>
<p><b>Step 2:</b><br />
 Define method <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#adfa6c5fa593667614c5c9346247b4c1d">T_Boxing&lt;std::string&gt;::Boxing</a> for the specialized type struct. This function performs the boxing and receives the address of the string buffer as well as the string length:</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span>   <span class="keywordtype">void</span>  <a class="code" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#adfa6c5fa593667614c5c9346247b4c1d">T_Boxing&lt;std::string&gt;::Boxing</a>( <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp; box,  <span class="keyword">const</span> std::string&amp;  value )</div><div class="line">{</div><div class="line">    box.data.Value=  <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="namespaceaworx_1_1lib_1_1boxing.html#aa3e009a14ed9d13b3f9cfac1ac29bee5">boxvalue</a><span class="keyword">&gt;</span>( value.c_str()  );</div><div class="line">    box.data.Length= static_cast     &lt;<a class="code" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&gt;( value.length() );</div><div class="line">}</div></div><!-- fragment --><p> <b>Step 3:</b><br />
 Define method <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a5dfd7dc3e9e72651fd2441d71bc56163">T_Boxing&lt;std::string&gt;::Unboxing</a>. This function performs the unboxing and returns a value of type <code>std::string:</code> </p>
<div class="fragment"><div class="line"><span class="keyword">inline</span>  std::string    <a class="code" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a5dfd7dc3e9e72651fd2441d71bc56163">T_Boxing&lt;std::string&gt;::Unboxing</a>( <span class="keyword">const</span> <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>&amp; box )</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span>  std::string( (<span class="keyword">const</span> <span class="keywordtype">char</span>*) box.data.Value,</div><div class="line">                          box.data.Length &gt;= 0 ? static_cast&lt;size_t&gt;(box.data.Length)</div><div class="line">                                               : strlen( (<span class="keyword">const</span> <span class="keywordtype">char</span>*) box.data.Value )</div><div class="line">                       );</div><div class="line">}</div></div><!-- fragment --><p> Note the check for negative array length! This might happen, because the box that gets unboxed using this method is not necessarily created from an object of type <code>std::string</code>! In case it was created from type <code>char*</code>, the string length is not known. This was explained in previous chapter <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_strings_chararr">6.1 Strings As Character Arrays</a>.</p>
<p>With these three little pieces code in place, we are already done! To summarize, all we needed to do is</p><ul>
<li>tell the boxing system that type <code>std::string</code> is mapped to <code>char</code>[] and that unboxing the original type is allowed.</li>
<li>specify how boxing and unboxing values is performed.</li>
</ul>
<p>Once a <code>std:string</code> is boxed, the box is not distinguishable from a similar box that was created using</p><ul>
<li>a string literal,</li>
<li>a <code>char*</code> </li>
<li>an object of type <b>aworx::String</b> </li>
<li>a std::string or</li>
<li>an other custom string type that is boxed using this recipe.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The consequence is quite helpful: A function that accepts string types as a boxed parameter, can be implemented by testing for and unboxing <b>only one</b> custom string type, while still a user of the function might pass any other string type, even types that the processing code does not even "know" about!<br />
 In addition, using this recipe, no specializations of the standard interface methods (e.g. <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IEquals.html">IEquals</a>) are needed, because they are implemented for destination type <code>char</code>[] already.</dd></dl>
<p>Here is some sample code on boxing <b>std::string</b> with this setup:</p>
<div class="fragment"><div class="line">    std::string stdString( <span class="stringliteral">&quot;TEST_STRING&quot;</span> );</div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a> box1(  stdString );</div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a> box2( &amp;stdString );</div><div class="line"></div><div class="line">    <span class="comment">// test types</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;box1.IsArrayOf&lt;char&gt;: &quot;</span> &lt;&lt; box1.IsArrayOf&lt;<span class="keywordtype">char</span>&gt;()  &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;box2.IsArrayOf&lt;char&gt;: &quot;</span> &lt;&lt; box2.IsArrayOf&lt;<span class="keywordtype">char</span>&gt;()  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// compare</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;box1.equals(box2):          &quot;</span>   &lt;&lt; box1.Invoke&lt;<a class="code" href="namespaceaworx.html#ad2a6bc6649fc6c466eea78e6cc2adaf3">aworx::IEquals</a>, <span class="keywordtype">bool</span>&gt;( box2 )          &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;box2.equals(\&quot;TEST_STRING\&quot;): &quot;</span> &lt;&lt; box2.<a class="code" href="classaworx_1_1lib_1_1boxing_1_1IEquals.html#ab221412b546bb3d4325a73b3e288a3ea">Invoke</a>&lt;<a class="code" href="namespaceaworx.html#ad2a6bc6649fc6c466eea78e6cc2adaf3">aworx::IEquals</a>, <span class="keywordtype">bool</span>&gt;( <span class="stringliteral">&quot;TEST_STRING&quot;</span> ) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// get a standard string back:</span></div><div class="line">    std::string std_back1= box1.Unbox&lt;std::string&gt;();</div><div class="line">    std::string std_back2= box2.Unbox&lt;std::string&gt;();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Unboxed 1 as std::string:   &quot;</span> &lt;&lt; std_back1 &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Unboxed 2 as std::string:   &quot;</span> &lt;&lt; std_back2 &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// get as aworx::String</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a> awx_back1= box1.Unbox&lt;<a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a>&gt;();</div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a> awx_back2= box2.Unbox&lt;<a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a>&gt;();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Unboxed 1 as aworx::String: &quot;</span> &lt;&lt; awx_back1 &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Unboxed 2 as aworx::String: &quot;</span> &lt;&lt; awx_back2 &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// invoke IApply</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html">aworx::AString</a> aString(<span class="stringliteral">&quot;IApply:         &quot;</span>);</div><div class="line">    box1.Invoke&lt;<a class="code" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">aworx::IApply</a>&gt;( aString );</div><div class="line">    std::cout &lt;&lt; aString &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// indirectly invoke IApply by applying the Box to the AString</span></div><div class="line">    aString.<a class="code" href="classaworx_1_1lib_1_1strings_1_1AString.html#ae4d5af65574550e39830297e4496f81b">Clear</a>()  &lt;&lt; <span class="stringliteral">&quot;AString &lt;&lt; Box: &quot;</span> &lt;&lt; box2;</div><div class="line">    std::cout &lt;&lt; aString &lt;&lt; std::endl;</div></div><!-- fragment --><p> This produces the output:</p>
<div class="fragment"><div class="line">box1.IsArrayOf&lt;<span class="keywordtype">char</span>&gt;: 1</div><div class="line">box2.IsArrayOf&lt;<span class="keywordtype">char</span>&gt;: 1</div><div class="line">box1.equals(box2):          1</div><div class="line">box2.equals(<span class="stringliteral">&quot;TEST_STRING&quot;</span>): 1</div><div class="line">Unboxed 1 as std::string:   TEST_STRING</div><div class="line">Unboxed 2 as std::string:   TEST_STRING</div><div class="line">Unboxed 1 as <a class="code" href="namespaceaworx.html#ad13481d84c6e592a41d07c64f747c95d">aworx::String</a>: TEST_STRING</div><div class="line">Unboxed 2 as <a class="code" href="namespaceaworx.html#ad13481d84c6e592a41d07c64f747c95d">aworx::String</a>: TEST_STRING</div><div class="line"><a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a>:         TEST_STRING</div><div class="line"><a class="code" href="namespaceaworx.html#a51ace28d988aa0a7ab391f6aaec35f60">AString</a> &lt;&lt; <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">Box</a>: TEST_STRING</div></div><!-- fragment --><p> <b>Boxing "Heavy" String Types</b><br />
</p>
<p>"Heavy" string types are boxed to <code>char</code>[] without the possibility of unboxing the original type and hence, they can be unboxed to a "lightweight" string type only.</p>
<p>Therefore, adding support for boxing of "heavy" string types is even more simple:</p><ul>
<li>In <b>Step 1</b> macro <a class="el" href="group__GrpALibMacros.html#gab85931d9bdbae09c0b79ad32105f95da">ALIB_BOXING_SPECIALIZE_CB</a> is used. This declares a custom boxing method but no custom unboxing.</li>
<li><b>Step 2</b> remains the same.</li>
<li><b>Step 3</b> is omitted. You're done.</li>
</ul>
<p>Optionally, to be complete, one thing might be done for "heavy" string types: As explained already, to alternatively box such types without loosing the object, wrapper class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1BoxedAs.html">BoxedAs</a> might be used (see chapter <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_boxedas">4.5 Boxing Types As They Are</a>). Now, it might be useful to add support for <b>ALib Strings</b> for this boxed type. I.e. to implement interface <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a> for values of this <b><a class="el" href="classaworx_1_1lib_1_1boxing_1_1BoxedAs.html">BoxedAs</a></b> type. A ready to use templated incarnation of interface <b>IApply</b> exists with class <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply__BoxedAs__TApplicable.html">IApply_BoxedAs_TApplicable</a>. As its name suggests, it may be used only with types that implement <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__Apply.html">T_Apply</a>. But this support is suggested to be added anyhow for custom string types (as noted in chapter <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_strings_iapply">6.3 Interface IApply</a>).</p>
<p>As a consequence, support for applying custom types wrapped in <b><a class="el" href="classaworx_1_1lib_1_1boxing_1_1BoxedAs.html">BoxedAs</a></b> is a matter of a single line of bootstrap code. Again, we are using the original source from <code>std::string</code> support to sample this:</p>
<div class="fragment"><div class="line">aworx::lib::boxing::DefineInterface&lt;BoxedAs&lt;std::string   &gt;  , false , strings::boxing::IApply_BoxedAs_TApplicable&lt;std::string   &gt;&gt;();</div></div><!-- fragment --><p><a class="anchor" id="alib_namespace_boxing_variadic"></a></p><h1>7. Variadic Arguments</h1>
<p><a class="anchor" id="alib_namespace_boxing_variadic_standard"></a></p><h2>7.1 Using Boxed Objects With Variadic Template Arguments</h2>
<p>With class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> in place, it becomes possible to define functions and methods that take an arbitrary value as an argument. The need for this is often combined with the need for the possibility to allow an arbitrary number of such arbitrary arguments. C++ 11 introduced <a href="http://en.cppreference.com/w/cpp/language/variadic_arguments">variadic template arguments</a> for this.</p>
<p>Class <b>Box</b> might greatly simplify the use of this language feature and provide a <b>type-safe</b> and <b>indexed</b> way to access variadic arguments. (Of-course it does, this was the original <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_intro_goals">goal</a>!)</p>
<p>The following quick sample demonstrates this:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt; <span class="keywordtype">void</span> VariadicFunction( <span class="keyword">const</span> T&amp;... args )</div><div class="line">{</div><div class="line">    <span class="comment">// fetch the arguments into an array of boxes</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a> boxes[]= { args... };</div><div class="line"></div><div class="line">    <span class="comment">// do something</span></div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i= 0; i &lt; <span class="keyword">sizeof</span>...(T) ; ++i )</div><div class="line">    {</div><div class="line">        <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box= boxes[i];</div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> With this function definition, it can be called like this:</p>
<div class="fragment"><div class="line">VariadicFunction( 7, <span class="stringliteral">&quot;ALib&quot;</span>, 3.14 );</div></div><!-- fragment --><p> It is only a single, simple line of code that fetches all function parameters and puts them into an array of boxes.</p>
<p>Of-course, the classical recursive approach to process template arguments using class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> may also be implemented but avoiding the recursion makes the code easier and more readable.</p>
<p>The sample above can be slightly modified to use <a href="http://en.cppreference.com/w/cpp/utility/forward">C++ 11 Perfect Forwarding</a> which in some situations is a little more efficient and produces smaller code. The following code snippet uses this technique and may be copied as a recipe on how to implement variadic template functions with <b>ALib Boxing</b>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt; <span class="keywordtype">void</span> VariadicRecipe( T&amp;&amp;... args )</div><div class="line">{</div><div class="line">    <span class="comment">// fetch the arguments into an array of boxes</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a> boxes[]= { std::forward&lt;T&gt;( args )... };</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="alib_namespace_boxing_variadic_class_boxes"></a></p><h2>7.2 Class Boxes</h2>
<p>In the previous chapter it was demonstrated how simple the use of variadic template arguments gets with <b>ALib Boxing</b>. The recipe given, uses a single line of code to let the compiler create an array of objects of class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a>. This is sufficient in many cases, but obviously using container class <code>std::vector&lt;aworx::Box&gt;</code> instead of a simple array would give more flexibility: It allows to add and remove boxes from the array and to pass the array to other (non-templated functions) without passing its size in an extra parameter.</p>
<p>For this and more purposes, class <a class="el" href="namespaceaworx.html#a13da4402eea5d25b5fbddc19c3605e22">Boxes</a> is provided. It publically inherits from <code>std::vector&lt;aworx::Box&gt;</code> and provides a constructor and method <b>Add</b>, each accepting templated variadic arguments. This way, its use is as simple as this:</p>
<div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1boxing_1_1Boxes.html">aworx::Boxes</a> boxes( 7, <span class="stringliteral">&quot;ALib&quot;</span>, 3.14 );</div><div class="line">boxes.Add( 42, <span class="stringliteral">&quot;Yipee-yeah&quot;</span> );</div></div><!-- fragment --><p> In this sample, three boxed objects are added to the vector in the constructor and then two more are added using method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxes.html#a671d6542680b4e4400b81efc6b2d1ec3">Boxes::Add</a>. All methods of parent class <code>vector</code> are available, e.g. this code:</p>
<div class="fragment"><div class="line">boxes.clear();</div><div class="line">boxes.Add( <span class="stringliteral">&quot;New&quot;</span>, <span class="stringliteral">&quot;Values&quot;</span> );</div></div><!-- fragment --><p> clears the array and adds two new boxed objects to it.</p>
<p>Using this class instead of a simple C++ array in a function using variadic template arguments then looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt; <span class="keywordtype">void</span> VariadicFunction( T&amp;&amp;... args )</div><div class="line">{</div><div class="line">    <span class="comment">// fetch the arguments into a Boxes object</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Boxes.html">aworx::Boxes</a> boxes( std::forward&lt;T&gt;( args )... );</div><div class="line"></div><div class="line">    <span class="comment">// do something</span></div><div class="line">    <span class="keywordflow">for</span>( <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box : boxes )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span>( box.IsType&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">aworx::boxed_int</a>&gt;() )</div><div class="line">            std::cout &lt;&lt; box.Unbox&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">aworx::boxed_int</a>&gt;() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; Unknown Argument Type &quot;</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">};</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The only change to the recipe given at the end of the previous chapter is the use of class <b><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxes.html">Boxes</a></b> instead of an array. The advantage of the recipe version is that the array is created on the <b>"stack"</b>. In contrast to this class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxes.html">Boxes</a>, being derived from <code>std::vector</code>, uses <b>"heap memory"</b> to store the boxes.<br />
 This is a disadvantage of using class <b>Boxes</b> that should not be underestimated. (Programmers generally tend to underestimate the performance impact of heap allocations.) Hence, its use is only recommended if the flexibility of using a vector is needed.</dd></dl>
<p>Besides providing variadic template arguments, method <b>Boxes::Add</b> uses some template meta programming to "flatten" the array in the case that another instance of class <b>Boxes</b> is added. In other words, if an instance of class <b>Boxes</b> is passed to <b>Boxes::Add</b>, the boxes contained in this instance are copied into the destination vector! Due to this fact, when using the sample method from above, the invocation:</p>
<div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1boxing_1_1Boxes.html">aworx::Boxes</a> boxes( 2, 3 );</div><div class="line">VariadicFunction( 1, boxes, 4 );</div></div><!-- fragment --><p>produces the following output: </p><div class="fragment"><div class="line">1  2  3  4  </div></div><!-- fragment --><p> The reason why this is implemented like this, is that the user of a method has a next benefit: He/she has the freedom of choice to either pass all parameters just inside the function call or to collect all objects prior to the call in an own instance of class <b>Boxes</b> and then just pass this instance as a single argument (or together with other, fixed arguments).</p>
<p>This makes the use of the function more flexible, without the need of providing an overloaded version that accepts and processes an object of <b>Boxes</b> directly.</p>
<p>Finally, besides detecting objects of class <b>Boxes</b> inside method <b>Boxes::Add</b>, it is also detected if an object of class <b>Boxes</b> is passed as a boxed object. Let us first look at a sample and its result:</p>
<div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1boxing_1_1Boxes.html">aworx::Boxes</a> boxes( 2, 3 );</div><div class="line"><a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>   box( boxes );</div><div class="line">VariadicFunction( 1, box, 4 );</div></div><!-- fragment --><div class="fragment"><div class="line">1  2  3  4  </div></div><!-- fragment --><p> Looking at this sample a reader might think "Wow, this is cool, but where is the use case for this?". Generally spoken, this is useful when a method has several overloaded versions with different parameters, and still should support to accept an arbitrary amount of any type of arguments. In this moment, it might get quite complicated (or impossible!) to define the methods properly in the sense that no ambiguities may occur when invoking them. A solution here is to declare the method to accept just exactly one <code>const aworx::Box&amp;</code> argument instead of a variadic list of arguments.</p>
<p>If inside the method this box is passed into a local instance of class <b>Boxes</b>, a user might invoke the method with just a single argument of arbitrary type (which gets boxed), or with an arbitrary amount of arguments, by collecting those in class <b>Boxes</b>. This might be done right in the invocation.<br />
 To demonstrate this, we use the method from above, but instead of accepting variadic template arguments, it accepts now just a single argument of type <code>const Box&amp;</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> HeavilyOverloadedFunction( <span class="keyword">const</span> <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; boxOrBoxes )</div><div class="line">{</div><div class="line">    <span class="comment">// pass the single box into a Boxes object. This way, if another boxes object gets passed,</span></div><div class="line">    <span class="comment">// its elements are added to the list!</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Boxes.html">aworx::Boxes</a> boxes( std::forward&lt;const aworx::Box&gt;( boxOrBoxes ) );</div><div class="line"></div><div class="line">    <span class="comment">// do something</span></div><div class="line">    <span class="keywordflow">for</span>( <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a>&amp; box : boxes )</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span>( box.IsType&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">aworx::boxed_int</a>&gt;() )</div><div class="line">            std::cout &lt;&lt; box.Unbox&lt;<a class="code" href="namespaceaworx.html#ae3275727f1c6ee612615d3c881610d61">aworx::boxed_int</a>&gt;() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; Unknown Argument Type &quot;</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">};</div></div><!-- fragment --><p> This can be invoked as follows:</p>
<div class="fragment"><div class="line">HeavilyOverloadedFunction( 1 );</div><div class="line">HeavilyOverloadedFunction( <a class="code" href="classaworx_1_1lib_1_1boxing_1_1Boxes.html">aworx::Boxes</a>(1, 2, 3) );</div></div><!-- fragment --><p> ...which produces:</p>
<div class="fragment"><div class="line">1  </div><div class="line">1  2  3  </div></div><!-- fragment --><p> A real world sample can be found in the logging library <a class="el" href="namespaceaworx_1_1lox.html">ALox</a> which is built on <b>ALib</b> and makes a lot of use of <b>ALib Boxing</b>. While straightforward methods <a class="el" href="classaworx_1_1lox_1_1Lox.html#a06ea69bd0319ab11bc8dab5241fe88ae">Lox::Info</a>, <a class="el" href="classaworx_1_1lox_1_1Lox.html#a6eabd60bb346393885053a79b0878062">Lox::Verbose</a>, etc. accept variadic template arguments as objects to be logged, method <a class="el" href="classaworx_1_1lox_1_1Lox.html#a6461dec7c62cad4cb618ac730bac95a9">Lox::Once</a> is more complicated: Various overloaded versions exist that interpret the term "once" differently. Therefore, each overloaded version accepts only one object to log - which is often enough for a simple log message. However, this is no restriction of <b>ALox</b>: If multiple objects should be logged "once", e.g. to provide a formatted output of custom objects, then those multiple objects may be passed by wrapping them in class <b>Boxes</b>.</p>
<p><a class="anchor" id="alib_namespace_boxing_usage"></a></p><h1>8. Using The Library</h1>
<p><a class="anchor" id="alib_namespace_boxing_usage_bootstrap"></a></p><h2>8.1 Header Inclusion And Bootstrapping ALib Boxing</h2>
<h3>8.1.1 Header Inclusion</h3>
<p>To make <b>ALib Boxing</b> available in a compilation unit, header file <code>"alib/alib.hpp"</code> has to be included. Depending on the <b>ALib</b> distribution that is used (complete <b>ALib</b> vs. the use of just a module of <b>ALib</b> that incorporates the boxing facilities), this header will include the provided variant of header <code>"alib/distribution.hpp"</code> to select the right (available) portions.</p>
<dl class="section note"><dt>Note</dt><dd>A direct inclusion of headers of namespace <b>aworx::lib::boxing</b> is forbidden and will throw a <code>#pragma</code> error.</dd></dl>
<p>If pure module <a href="https://github.com/AlexWorx/ALib-Boxing">ALib Boxing</a> is used, compilation symbol <a class="el" href="group__GrpALibCompilerSymbols.html#gaac13faf1a75cc977147511eca3c354cb">ALIB_FEAT_BOXING_FTYPES_OFF</a> may be given to suppress the use of the built-in <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_ftypes">default implementation of boxing fundamental C++ types</a>.</p>
<p>If combined module <a href="https://github.com/AlexWorx/ALib-Boxing-And-Strings">ALib Boxing &amp; Strings</a> is used, the provision of compilation symbol <a class="el" href="group__GrpALibCompilerSymbols.html#gaac13faf1a75cc977147511eca3c354cb">ALIB_FEAT_BOXING_FTYPES_OFF</a> will suppress the the default implementation of boxing <b>ALib String</b> types as well, and consequently will not allow to use class <a class="el" href="classaworx_1_1lib_1_1strings_1_1format_1_1Formatter.html">Formatter</a> and associated types.</p>
<p>Besides header <code>"alib/alib.hpp"</code>, no other header needs to be included, apart from what is documented in chapter <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_usage_3rdparty">8.2 Built-In Support For 3rd Party Types</a>.</p>
<h3>8.1.2 Bootstrapping ALib Boxing</h3>
<p>Bootstrapping means the creation of singletons of derived <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a> types and the assignment of those to the right singletons of class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html">Boxer</a>. This needs to be done only once and preferably in the moment a process is created, especially before boxing is used and before parallel execution threads are started.</p>
<p>For bootstrapping <b>ALib Boxing</b> all that is needed to do is to invoke method <a class="el" href="classaworx_1_1lib_1_1ALIB.html#a53d8c6754ea7c4d7a0432cdb5f5b6371">ALIB::Init</a> on bootstrap. This method will do the bootstrapping for all alib portions that are included in the <b>ALib</b> distribution.</p>
<dl class="section note"><dt>Note</dt><dd>As explained <a class="el" href="namespaceaworx_1_1lib.html">here</a>, currently the full <b>ALib</b> distribution is bundled together with the <b>ALox Logging Library</b>, hence as a replacement, method <a class="el" href="classaworx_1_1lox_1_1ALox.html#a4c4ba727bf8ffe104f310aca32519e36">ALox::Init</a> might be invoked (which in turn invokes <b>ALIB::Init</b>).</dd></dl>
<p>The following shows the excerpt from method <b>ALIB::Init</b> which considers boxing: </p><div class="fragment"><div class="line"><span class="comment">//############### Initialize boxing ###############</span></div><div class="line"><span class="preprocessor">#if ALIB_MODULE_BOXING</span></div><div class="line">    <a class="code" href="namespaceaworx_1_1lib_1_1boxing.html#a1e3b6d38df0786ccf7f938d60e386aae">aworx::lib::boxing::Init</a>();</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#if ALIB_MODULE_STRINGS</span></div><div class="line">    <a class="code" href="namespaceaworx_1_1lib_1_1strings.html#a78e0a4c7f228e5a0c57dff644b017570">aworx::lib::strings::Init</a>();</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#if ALIB_MODULE_CONFIGURATION</span></div><div class="line">    <a class="code" href="namespaceaworx_1_1lib_1_1time.html#a517ec5f65ee095a2331bb050b02a96c3">aworx::lib::time::InitBoxing</a>();</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>We see three invocations of namespace functions:</p><ol type="1">
<li><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a1e3b6d38df0786ccf7f938d60e386aae">aworx::lib::boxing::Init<br />
</a> It is obvious, that this is the only function to be invoked if pure module <a href="https://github.com/AlexWorx/ALib-Boxing">ALib Boxing</a> is used.</li>
<li><a class="el" href="namespaceaworx_1_1lib_1_1strings_1_1boxing.html#a1e3b6d38df0786ccf7f938d60e386aae">aworx::lib::strings::boxing::Init<br />
</a> This function needs to be invoked with combined module <a href="https://github.com/AlexWorx/ALib-Boxing-And-Strings">ALib Boxing &amp; Strings</a>.</li>
<li><a class="el" href="namespaceaworx_1_1lib_1_1time.html#a517ec5f65ee095a2331bb050b02a96c3">aworx::lib::time::InitBoxing<br />
</a> This function enables boxing of types found in namespace <a class="el" href="namespaceaworx_1_1lib_1_1time.html">aworx::lib::time</a>.</li>
</ol>
<p>If a software defines own types of class <b>Interface</b> for custom boxable types, such interfaces have to be registered within the bootstrap section likewise. See chapter <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_interfaces_sample">5.1 A Simple Interface Sample</a> for more information on how to do this.</p>
<p><a class="anchor" id="alib_namespace_boxing_usage_3rdparty"></a></p><h2>8.2 Built-In Support for 3rd Party Types</h2>
<p>ALib provides built-in support for boxing a few 3rd party types, among them are various <code>std::string</code> types and string types of the <a href="https://www.qt.io">QT Class Library</a>. This support is documented in <a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1thirdparty.html">aworx::lib::boxing::thirdparty</a> (which is not a "real" namespace but used for collecting such documentation).</p>
<p><a class="anchor" id="alib_namespace_boxing_usage_lifecycle"></a></p><h2>8.3 Lifecycle Management And Data Deletion</h2>
<p>This chapter now can be kept really short: <b>ALib Boxing</b> does not provide lifecycle management or data deletion mechanisms in respect to values (objects) that get boxed.</p>
<p>The rationale for this is simple: It is always a good design pattern to keep the responsibility for the deletion (destruction) of objects in the hands of those code parts, which create the object. Now, <b>ALib Boxing</b> does not create objects. Instead it just "boxes" already existing ones.</p>
<p>Of-course, if a box contains a pointer to data (which is the default when custom types are boxed), then the pointer (and data) has to be valid until the box is not used anymore.</p>
<p>When reconsidering the <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_intro_goals">goals</a> of this software library, the main use case is to enable functions and methods to accept just anything possible as a parameter. Now, as long as such "receiving" functions and methods do not store the contents of the box, everything is very safe: The box is created on the program stack (implicitly constructed by the compiler) and when the receiving function (method) returns, the stack is <a href="https://en.wikipedia.org/wiki/Call_stack#Unwinding">unwinded</a> and the box object is gone. In this standard use case, the only thing that might happen is that a parallel thread destroyed data that the box points to. But this is really all standard C++ behavior. </p><dl class="section user"><dt>Again in short:</dt><dd>There are no destructors, no delete statements, shared pointer or other mechanisms provided for the life-cycle management of boxed data.</dd></dl>
<p>As a final note, boxes are rather "immutable" objects. Unless custom interface methods do so, there is no method that overwrites or otherwise changes the contents of a box. And for the same reasons as mentioned above, there is no need for providing such. In the (unlikely) case that a new value should be written into an existing box instance, the standard assignment operator might be used. As the box is a POD-type class, standard compiler implementation with move semantics is used if possible.<br />
 Here is an example on how to change the contents (and type!) of a box: </p><div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a> box(5);</div><div class="line">box= <a class="code" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">aworx::Box</a>(3.14); <span class="comment">// assign a new value AND type (uses move semantics)</span></div></div><!-- fragment --><p> In the moment an instance of class <b><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a></b> is boxed, the TMP constructor detects this and copies the contents of the given box. As a result, the originating box may be deleted while the "new" box object remains valid. Of-course the boxed data of the originating box may not be deleted while the new box is still used.</p>
<p><a class="anchor" id="alib_namespace_boxing_usage_performance"></a></p><h2>8.4 Performance Considerations</h2>
<p>The reason why the effort of implementing this library is needed is the C++ language design principle to be as performant and close to the hardware as possible. Other programming languages are designed for other goals. E.g. in languages Java or C# the principle "everything is an object" is (almost) implemented. In these languages, all class types have runtime type information and the only types that do not have that are plain arithmetic types like <code>char</code>, <code>int</code> or <code>double</code>. (In C++ we have non-virtual classes, structs and POD types.) And what do these languages do when a plain type is passed to a method that expects an object? Right: The compilers perform "auto-boxing" of the values to pre-defined class types <code>Char</code>, <code>Integer</code> or <code>Double</code>!</p>
<p>Therefore it is indicated to have do quick analysis of the memory and performance impact of using <b>ALib Boxing</b>. We do this in a rather loose order:</p>
<h3>8.4.1 A General Note On C++ RTTI</h3>
<p>It is a widespread misunderstanding that using RTTI (runtime type information) with C++ has a huge performance impact. In fact the impact to get information on a type using keyword <code>typeid</code> is "almost zero" (it is constant, in <a href="https://en.wikipedia.org/wiki/Big_O_notation">Big O notation</a>: O(1)). It is just about copying a pointer to a static struct residing in the fixed data segment of a compilation unit.</p>
<h3>8.4.2 Boxer And Interface Singletons</h3>
<p>For each (destination!) type that is boxed, a singleton of a type derived from class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html">Boxer</a> is created. This is almost irrelevant and comparable to the singletons of <a href="https://en.wikipedia.org/wiki/Virtual_method_table">vtables</a> which are created by the compiler for each virtual class.</p>
<p>Likewise, for each derived version of type <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a> one instance has to be created.</p>
<h3>8.4.3 Footprint Of Class Box</h3>
<p>Class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> contains three members: A pointer to the boxer singleton and the data struct (which consists of two). For example on a standard 64-Bit platform each is 8 bytes wide, hence an instance of class <b>Box</b> on those platforms has a size of 24 bytes. In most cases, such boxes are created in "stack memory" which allocates and deallocates in zero time (yes, its less than "O(1)", it is just nothing). Once created, to pass them to another function or store them in a container like <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxes.html">Boxes</a>, these 24 bytes have to be copied. Well, this is three times more than copying just a pointer.</p>
<h3>8.4.4 Creation Of A Box</h3>
<p>When a value is boxed, hence an object of class <b>Box</b> is created, two things have to be done. First the right boxer is identified. This is done using (inlined) TMP code and "magically" this is reduced to the inlined retrieval of a singleton.</p>
<dl class="section note"><dt>Note</dt><dd>The reader might assume that the retrieval of a singleton in inlined template code is reduced to a single assembly statement that copies a pointer to a static object. Unfortunately at least when support for Windows OS DLLs is needed, this gets a little more complicated due to the nature of the DLL design on this operating system. The good news is that it still is very performant, the bad news is that the code that is inlined is much larger than expected.<br />
 Details are given in documentation of class <a class="el" href="classaworx_1_1lib_1_1lang_1_1Singleton.html">aworx::lib::lang::Singleton</a>.</dd></dl>
<p>Secondly, field <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ae873c14aa392d71bf9d5b0c4a28f4af5">Box::data</a> has to be set. Again, this is inlined TMP code and when optimized should in most cases be as fast and short as copying a pointer and an integer value.</p>
<h3>8.4.5 Box::IsType And Box::IsArrayOf</h3>
<p>Template method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">Box::IsType</a> compares the internal pointer to the singleton of class <b>Boxer</b> with the singleton of class <b>Boxer</b> that would be chosen if the given type (the template parameter) was boxed. Therefore, the impact is the same as boxing a value - excluding the process of boxing the data itself - plus a pointer comparison.</p>
<p>Template method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ad34718fb8f3109b7ee870650ae8dedbf">Box::IsArrayOf</a> performs even faster: Just two simple pointer comparisons are needed.</p>
<h3>8.4.6 Box::HasInterface, Box::GetInterface And Box::Invoke</h3>
<p>Template method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#af00a56f400aaf960349d00e50d8effd5">Box::HasInterface</a> performs a lookup in a hash table (<a href="http://en.cppreference.com/w/cpp/container/unordered_map">std::unordered_map</a>) and returns <code>true</code> if the interface was found, <code>false</code> otherwise. The key is the C++ RTTI struct <code>type_info</code> of the given template type, a static value for the compiler. The lookup is also performed in O(1) - if you believe in computer science! - which in reality means "almost no time".</p>
<p>Template method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#aff845e5a76eb0fab90db26cda997c70b">Box::GetInterface</a> has double the work: if the interface is not found with the search in the hash table for type-specific interfaces, then a next lookup is done in a different hash table, the one used to store default interfaces.</p>
<p>Finally, template method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ae828c5649908bb8346f1187bb4187936">Box::Invoke</a> first uses <b>GetInterface</b> to receive the interface. Then, a standard C++ virtual function call is performed. Passing the templated parameters "twice" should be irrelevant, due to "perfect forwarding". In the case that no interface method is found a default value of the return type <code>TReturn</code> is created. Depending on the type, this might invoke a constructor.</p>
<h3>8.4.7 Compile Times</h3>
<p>There is another negative 'performance' impact when using <b>ALib Boxing</b>: Due to the use of TMP methods and need for the inclusion of standard header <code>&lt;type_traits&gt;</code> that provides support for that, the time to compile a code unit increases with the use of <b>ALib Boxing</b>. This increase can be quite "dramatic" in the case that otherwise such techniques are not used (with other includes or the compilation unit itself).</p>
<h3>8.4.8 Conclusion</h3>
<p>Honestly, we consider the implementation of <b>ALib Boxing</b> to be as performant as possible. The impact on code size when invoking methods that do auto-boxing of arguments is relatively higher than the impact on execution performance. Inlining is used wherever reasonable and the library chooses generally to take preference of performance over code size.</p>
<p>Most important, no heap memory allocations are performed with boxing types. The only exclamation is with the use of class <a class="el" href="namespaceaworx.html#a13da4402eea5d25b5fbddc19c3605e22">Boxes</a>. Therefore, methods that "emplace" arbitrary arguments in this container, might choose to reuse such object, e.g. by making it a protected field of the class that offers the method.</p>
<p><a class="anchor" id="alib_namespace_boxing_usage_dump"></a></p><h2>8.5 Debugging ALib Boxing</h2>
<p>In debug compilations, a few debug methods are available that allow a little insight into the setup of <b>ALib Boxing</b>. Class <b>Box</b> provides method</p>
<ul>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a4b392c2a1e4836b39e9dd06ff8cecf6c">Box::DbgGetBoxerType</a></li>
</ul>
<p>which returns the type of the boxer that the box points to. From this type, the content type of the box can be deduced. Also, the type can be passed to static method</p>
<ul>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html#a84052e2906651204a5686664bc20b862">Boxer::DbgGetInterfaces</a></li>
</ul>
<p>which returns a list of types representing the <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a>(s) attached to the box type.</p>
<p>Then, class <b>Boxer</b> exposes the static methods used to get information about the overall setup of <b>ALib Boxing</b>:</p>
<ul>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html#a62f9dbdd875dd7cf0df25f8ab142d306">Boxer::DbgGetKnownBoxers</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html#a2a7a4ea24bd3d70233f2f70a2bb19fe0">Boxer::DbgGetKnownInterfaces</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html#a2d7232559a770f142bd3e930a4e9fe61">Boxer::DbgGetDefaultInterfaces</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html#adbb10fb051c27c536311e7f5c8501241">Boxer::DbgGetKnownInterfaceImpl</a></li>
</ul>
<p>All these methods are quite basic as they are returning one or a vector of <code>std::typeinfo</code> structs. Class <a class="el" href="classaworx_1_1lib_1_1debug_1_1TypeDemangler.html">TypeDemangler</a>, which is also only available in debug compilations, is a very simple helper to "demangle" type names returned by <code>std::typeinfo.name()</code>.</p>
<p>When module <b>ALib Boxing</b> is used with a distribution that includes module <b>ALib Strings</b>, things become more "handy". Module <b>ALib Strings</b> injects class</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1debug_1_1Boxing.html">Boxing</a></li>
</ul>
<p>into namespace <b>aworx::lib::debug</b> that uses the functions listed above and does a little formatting and conversion. Please consult the reference documentation of class <a class="el" href="classaworx_1_1lib_1_1debug_1_1Boxing.html">Boxing</a> for detailed information. At this point, we want to conclude with some quick samples.</p>
<p>Let us start with template method <a class="el" href="classaworx_1_1lib_1_1debug_1_1Boxing.html#af1f24407901f6084d1c0678648411373">Boxing::GetBoxingInfo</a>, which collects information about how C++ types are boxed. The type is passed as a template parameter:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if ALIB_DEBUG</span></div><div class="line">    std::cout &lt;&lt; <a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html">aworx::lib::debug::Boxing</a>().<a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html#af1f24407901f6084d1c0678648411373">GetBoxingInfo</a>&lt;<span class="keywordtype">float</span>            &gt;() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html">aworx::lib::debug::Boxing</a>().<a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html#af1f24407901f6084d1c0678648411373">GetBoxingInfo</a>&lt;<span class="keywordtype">char</span>*            &gt;() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html">aworx::lib::debug::Boxing</a>().<a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html#af1f24407901f6084d1c0678648411373">GetBoxingInfo</a>&lt;<a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::String</a>    &gt;() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html">aworx::lib::debug::Boxing</a>().<a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html#af1f24407901f6084d1c0678648411373">GetBoxingInfo</a>&lt;std::vector&lt;int&gt; &gt;() &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p> The output is:</p>
<div class="fragment"><div class="line">Boxing information <span class="keywordflow">for</span> type: <span class="keywordtype">float</span></div><div class="line">  Customized:      Yes</div><div class="line">  Target Type:     <span class="keywordtype">double</span></div><div class="line">  Custom Boxing:   Yes</div><div class="line">  Unboxable:       No</div><div class="line"></div><div class="line">Boxing information <span class="keywordflow">for</span> type: <span class="keywordtype">char</span>*</div><div class="line">  Customized:      Yes</div><div class="line">  Target Type:     <span class="keywordtype">char</span>[]</div><div class="line">  Custom Boxing:   Yes</div><div class="line">  Unboxable:       No</div><div class="line"></div><div class="line">Boxing information <span class="keywordflow">for</span> type: <a class="code" href="classaworx_1_1lib_1_1strings_1_1String.html">aworx::lib::strings::String</a></div><div class="line">  Customized:      Yes</div><div class="line">  Target Type:     <span class="keywordtype">char</span>[]</div><div class="line">  Custom Boxing:   Yes</div><div class="line">  Unboxable:       Yes</div><div class="line">  Custom Unboxing: Yes</div><div class="line"></div><div class="line">Boxing information <span class="keywordflow">for</span> type: std::vector&lt;int, std::allocator&lt;int&gt; &gt;</div><div class="line">  Customized:      Yes</div><div class="line">  Target Type:     <span class="keywordtype">int</span>[]</div><div class="line">  Custom Boxing:   Yes</div><div class="line">  Unboxable:       No</div><div class="line"></div></div><!-- fragment --><p>To inspect the type of a box, the following code may be used:</p>
<div class="fragment"><div class="line"><a class="code" href="classaworx_1_1lib_1_1boxing_1_1Box.html">aworx::Box</a> box( <span class="stringliteral">&quot;Character Array&quot;</span> );</div><div class="line"></div><div class="line"><span class="preprocessor">#if ALIB_DEBUG</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html">aworx::lib::debug::Boxing</a> dbgBoxing;</div><div class="line">    cout &lt;&lt; dbgBoxing.<a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html#a17a1460cf2ac70b6f81b0bd2cdd0c5cd">GetType</a>( box  ) &lt;&lt; endl;</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p> The output is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>[]</div></div><!-- fragment --><p> Now, to inspect which interfaces are invokable on a box, these can be listed as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if ALIB_DEBUG</span></div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html">aworx::lib::debug::Boxing</a> dbgBoxing;</div><div class="line">    <a class="code" href="classaworx_1_1lib_1_1strings_1_1util_1_1StringTuples.html">aworx::Strings</a>&amp; strings= dbgBoxing.<a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html#a0392377b4c3ecc654c4cf78540ce97ce">GetInterfaces</a>( <span class="stringliteral">&quot;abc&quot;</span> );</div><div class="line">    <span class="keywordflow">for</span>( <span class="keyword">auto</span> it : strings )</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; std::get&lt;0&gt;(it) &lt;&lt; endl;</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p> Note that in this sample, the box is created once more implicitly, as a string literal is passed to the method!<br />
 The output will be:</p>
<div class="fragment"><div class="line">  dox_boxing_sample_if::IStoreInMyFormat</div><div class="line">  <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line">  <a class="code" href="namespaceaworx.html#ad2a6bc6649fc6c466eea78e6cc2adaf3">IEquals</a></div></div><!-- fragment --><p> Method <a class="el" href="classaworx_1_1lib_1_1debug_1_1Boxing.html#a1fa86a53923b665f496cd35491765ff5">Boxing::Dump</a> aggregates all of the above and provides overview about the boxed types and their. Invoked like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#if ALIB_DEBUG</span></div><div class="line">    std::cout &lt;&lt; <a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html">aworx::lib::debug::Boxing</a>().<a class="code" href="classaworx_1_1lib_1_1debug_1_1Boxing.html#a1fa86a53923b665f496cd35491765ff5">Dump</a>() &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p> It produces an output similar to this:</p>
<div class="fragment"><div class="line">ALib Boxing: Boxed Types and Associated Interfaces:</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">  <span class="keywordtype">bool</span></div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line"></div><div class="line">  BoxedAs&lt;AString&gt; </div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line"></div><div class="line">  BoxedAs&lt;float&gt; </div><div class="line"></div><div class="line">  BoxedAs&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; </div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line"></div><div class="line">  BoxedAs&lt;std::__cxx11::basic_string&lt;char16_t, std::char_traits&lt;char16_t&gt;, std::allocator&lt;char16_t&gt; &gt; &gt; </div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line"></div><div class="line">  BoxedAs&lt;std::__cxx11::basic_string&lt;char32_t, std::char_traits&lt;char32_t&gt;, std::allocator&lt;char32_t&gt; &gt; &gt; </div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line"></div><div class="line">  BoxedAs&lt;std::__cxx11::basic_string&lt;wchar_t, std::char_traits&lt;wchar_t&gt;, std::allocator&lt;wchar_t&gt; &gt; &gt; </div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line"></div><div class="line">  <a class="code" href="namespaceaworx.html#a13da4402eea5d25b5fbddc19c3605e22">Boxes</a>*</div><div class="line"></div><div class="line">  <span class="keywordtype">char</span></div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line"></div><div class="line">  char16_t</div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line"></div><div class="line">  char16_t[]</div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line">    <a class="code" href="namespaceaworx.html#ad2a6bc6649fc6c466eea78e6cc2adaf3">IEquals</a></div><div class="line"></div><div class="line">  char32_t</div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line"></div><div class="line">  char32_t[]</div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line">    <a class="code" href="namespaceaworx.html#ad2a6bc6649fc6c466eea78e6cc2adaf3">IEquals</a></div><div class="line"></div><div class="line">  <span class="keywordtype">char</span>[]</div><div class="line">    dox_boxing_sample_if::IStoreInMyFormat</div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line">    <a class="code" href="namespaceaworx.html#ad2a6bc6649fc6c466eea78e6cc2adaf3">IEquals</a></div><div class="line"></div><div class="line">  <a class="code" href="namespaceaworx.html#a8ec4a1b5f5786befe04b9f08d5417cdc">core::Logger</a>*</div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line"></div><div class="line">  decltype(<span class="keyword">nullptr</span>)</div><div class="line"></div><div class="line">  double</div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line">    <a class="code" href="namespaceaworx.html#ad2a6bc6649fc6c466eea78e6cc2adaf3">IEquals</a></div><div class="line">    <a class="code" href="namespaceaworx.html#a95b27610e38c813268b4a843ef5ef173">IIsNull</a></div><div class="line"></div><div class="line">  dox_boxing_bijective::MyBijBoxed</div><div class="line"></div><div class="line">  dox_boxing_bijective::MyBijBoxed*</div><div class="line"></div><div class="line">  dox_boxing_sample_1::MyClass*</div><div class="line"></div><div class="line">  dox_boxing_sample_2::MyClass*</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> [3][]</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span>[]</div><div class="line"></div><div class="line">  <span class="keywordtype">long</span></div><div class="line">    dox_boxing_sample_if::IStoreInMyFormat</div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line">    <a class="code" href="namespaceaworx.html#a95b27610e38c813268b4a843ef5ef173">IIsNull</a></div><div class="line"></div><div class="line">  <a class="code" href="namespaceaworx.html#ad270463709a4ae7e7098df40e803e458">Ticks</a>*</div><div class="line">    IFormat</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span></div><div class="line">    dox_boxing_sample_if::IStoreInMyFormat</div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line">    <a class="code" href="namespaceaworx.html#a95b27610e38c813268b4a843ef5ef173">IIsNull</a></div><div class="line"></div><div class="line">  <span class="keywordtype">wchar_t</span></div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line"></div><div class="line">  <span class="keywordtype">wchar_t</span>[]</div><div class="line">    <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line">    <a class="code" href="namespaceaworx.html#ad2a6bc6649fc6c466eea78e6cc2adaf3">IEquals</a></div><div class="line"></div><div class="line">ALib Boxing: Interfaces (all known):</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">  dox_boxing_sample_if::IStoreInMyFormat</div><div class="line">  <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line">  <a class="code" href="namespaceaworx.html#ad2a6bc6649fc6c466eea78e6cc2adaf3">IEquals</a></div><div class="line">  IFormat</div><div class="line">  <a class="code" href="namespaceaworx.html#ae6997e75801a3dcdc3a80cec77b1a62f">IIsEmpty</a></div><div class="line">  <a class="code" href="namespaceaworx.html#a95b27610e38c813268b4a843ef5ef173">IIsNull</a></div><div class="line"></div><div class="line">ALib Boxing: Default Interfaces:</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">  <a class="code" href="namespaceaworx.html#af231913c4b88a341cf804f9fedf38adb">IApply</a></div><div class="line">  <a class="code" href="namespaceaworx.html#ad2a6bc6649fc6c466eea78e6cc2adaf3">IEquals</a></div><div class="line">  <a class="code" href="namespaceaworx.html#ae6997e75801a3dcdc3a80cec77b1a62f">IIsEmpty</a></div><div class="line">  <a class="code" href="namespaceaworx.html#a95b27610e38c813268b4a843ef5ef173">IIsNull</a></div><div class="line"></div><div class="line">ALib Boxing: <a class="code" href="namespaceaworx.html#aef105b1e431c10dcbb5691cb9814cac8">Interface</a> Implementations:</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">  dox_boxing_sample_if::IStoreInMyFormat_TcharArr</div><div class="line">  dox_boxing_sample_if::IStoreInMyFormat_Tint</div><div class="line">  IApply_BoxedAs_TApplicable&lt;<a class="code" href="namespaceaworx.html#a51ace28d988aa0a7ab391f6aaec35f60">AString</a>&gt;</div><div class="line">  IApply_BoxedAs_TApplicable&lt;<a class="code" href="namespacestd.html">std</a>::__cxx11::basic_string&lt;<span class="keywordtype">char</span>, <a class="code" href="namespacestd.html">std</a>::char_traits&lt;<span class="keywordtype">char</span>&gt;, <a class="code" href="namespacestd.html">std</a>::allocator&lt;<span class="keywordtype">char</span>&gt; &gt; &gt;</div><div class="line">  IApply_BoxedAs_TApplicable&lt;<a class="code" href="namespacestd.html">std</a>::__cxx11::basic_string&lt;char16_t, <a class="code" href="namespacestd.html">std</a>::char_traits&lt;char16_t&gt;, <a class="code" href="namespacestd.html">std</a>::allocator&lt;char16_t&gt; &gt; &gt;</div><div class="line">  IApply_BoxedAs_TApplicable&lt;<a class="code" href="namespacestd.html">std</a>::__cxx11::basic_string&lt;char32_t, <a class="code" href="namespacestd.html">std</a>::char_traits&lt;char32_t&gt;, <a class="code" href="namespacestd.html">std</a>::allocator&lt;char32_t&gt; &gt; &gt;</div><div class="line">  IApply_BoxedAs_TApplicable&lt;<a class="code" href="namespacestd.html">std</a>::__cxx11::basic_string&lt;<span class="keywordtype">wchar_t</span>, <a class="code" href="namespacestd.html">std</a>::char_traits&lt;<span class="keywordtype">wchar_t</span>&gt;, <a class="code" href="namespacestd.html">std</a>::allocator&lt;<span class="keywordtype">wchar_t</span>&gt; &gt; &gt;</div><div class="line">  IApply_TApplicable&lt;<span class="keywordtype">bool</span>&gt;</div><div class="line">  IApply_TApplicable&lt;char16_t&gt;</div><div class="line">  IApply_TApplicable&lt;char32_t&gt;</div><div class="line">  IApply_TApplicable&lt;<span class="keywordtype">char</span>&gt;</div><div class="line">  IApply_TApplicable&lt;core::<a class="code" href="namespaceaworx.html#a8ec4a1b5f5786befe04b9f08d5417cdc">Logger</a>*&gt;</div><div class="line">  IApply_TApplicable&lt;<span class="keywordtype">double</span>&gt;</div><div class="line">  IApply_TApplicable&lt;<span class="keywordtype">long</span>&gt;</div><div class="line">  IApply_TApplicable&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>&gt;</div><div class="line">  IApply_TApplicable&lt;<span class="keywordtype">wchar_t</span>&gt;</div><div class="line">  IApply_Tchar16_tArr</div><div class="line">  IApply_Tchar32_tArr</div><div class="line">  IApply_TcharArr</div><div class="line">  IApply_Twchar_tArr</div><div class="line">  IEquals_Tchar16_tArr</div><div class="line">  IEquals_Tchar32_tArr</div><div class="line">  IEquals_TcharArr</div><div class="line">  IEquals_Tdouble</div><div class="line">  IEquals_Twchar_tArr</div><div class="line">  IFormat_TTicks</div><div class="line">  IIsNull_false</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p> Note that the output includes types that we have used during this tutorial.</p>
<p><a class="anchor" id="alib_namespace_boxing_summary"></a></p><h1>9. Summary</h1>
<p>This is a fast recap of what was explained in this documentation/tutorial and maybe all that experienced C++ programmes need to read:</p>
<p><b>What ALib Boxing is:</b><br />
</p><ul>
<li><b>ALib Boxing</b> is a free C++ software library that provides runtime type information and virtual method invocation on any C++ type. To make this possible, values of arbitrary types are "boxed", which means wrapped into another, generic type, namely class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> Then, the wrapper objects provide an interface identify the original types at runtime, to "unbox" the values and to invoke virtual methods on the boxes.</li>
<li>The disadvantage of this approach is that code that wants to make use of runtime type information need to work on the "boxes" instead on working on the original types.</li>
<li>The advantage of this approach are:<ul>
<li>Works with any type, including non-virtual types and even non class types, like fundamental types <code>int</code> or <code>double</code>.</li>
<li>Works on externally created objects (e.g. objects created in a system library)</li>
<li>Run-time Interfaces can be implemented independent from the original type implementation (e.g. for types of 3rd party libraries).</li>
<li>Used only when needed: No performance or memory penalty for supported types.</li>
<li>A built-in, minimum support is available for just any C++ type (including custom types), which includes a default version of boxing and unboxing the data and to perform the runtime type checks.</li>
<li>Functions and methods can be declared to accepts any type of object, without the need of conversion: Any value may be passed to such functions "as is".</li>
</ul>
</li>
<li>The central class of <b>ALib Boxing</b> is class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a>, which uses <a href="https://en.wikipedia.org/wiki/Template_metaprogramming">TMP</a> to accept and store a single value of <b>arbitrary</b> C++ type in its constructor. Passing and encapsulating a value in an object of class <b>Box</b> is called "boxing".</li>
<li>One-dimensional array types are boxed in a special way. Their value can be accessed by returning the original array type or by accessing individual array elements.</li>
<li>Once a value is boxed, it can be passed to other methods and be processed. Processing a boxed value involves three possible actions:<ol type="1">
<li>Determine the type of the boxed value (at runtime) using methods <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a6cfff1d08a62820fcf3a5f82922a3bba">Box::IsType</a>, <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#aebef9889d05411b93c68c9a7d9d773cf">Box::IsArray</a> and <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ad34718fb8f3109b7ee870650ae8dedbf">Box::IsArrayOf</a>.</li>
<li>Retrieving the value back. This is called "unboxing" and done with methods <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a7e697abb81d1cc6d8669a75e48ec0d88">Box::Unbox</a> and <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#a974225964bd92b7338e69557376719e1">Box::UnboxElement</a></li>
<li>Invoking definable "virtual methods" on the box, which process the boxed value in a type-specific way. Methods that support this are <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#af00a56f400aaf960349d00e50d8effd5">Box::HasInterface</a>, <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#aff845e5a76eb0fab90db26cda997c70b">Box::GetInterface</a> and <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#ae828c5649908bb8346f1187bb4187936">Box::Invoke</a>,</li>
</ol>
</li>
<li>The advantage of the invocation of virtual methods are twofold:<ul>
<li>The processing code does not need to detect (and "know") the type of the boxed value</li>
<li>The logic performed in the virtual method can be used anywhere</li>
</ul>
</li>
<li>Different C++ types may be boxed to the same boxed type ("destination type"). This means, that the mapping of C++ types to boxed types is not bijective.</li>
</ul>
<p><b>How ALib Boxing is used:</b><br />
</p><ul>
<li>Depending on the configuration and distribution module of <b>ALib</b>, built-in support for boxing and unboxing of the following C++ types is provided:<ul>
<li>Fundamental C++ types like <code>char</code>, <code>int</code>, <code>double</code>, etc. and pointers and arrays of those.</li>
<li><b>ALib</b> string types</li>
<li>Third party string types, like <code>std::string</code> or those of <a href="https://www.qt.io">QT Class Library</a>.</li>
</ul>
</li>
<li>The provided implementation of <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_types_ftypes">boxing fundamental types</a> makes a lot of use of the non-bijective boxing and hence reduces the complexity of code when processing boxed values. The huge list of C++ fundamental types is covered with only a few type checks.</li>
<li><p class="startli">The following built-in invokable interface methods (in fact they are classes providing a virtual method named <b>Invoke</b>) are available:</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1IEquals.html">IEquals</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsNull.html">IIsNull</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsEmpty.html">IIsEmpty</a></li>
</ul>
<p class="startli">With module <b>ALib Strings</b> this list is extended to</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IFormat.html">IFormat</a></li>
</ul>
</li>
<li><p class="startli">A default interface method implementation, available to all boxed types that are not equipped with a type-specific implementation, can be registered. The following built-in interface types define such default:</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1IEquals.html">IEquals</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsNull.html">IIsNull</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsEmpty.html">IIsEmpty</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a></li>
</ul>
<p class="startli">When a default implementation is available, method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html#af00a56f400aaf960349d00e50d8effd5">Box::HasInterface</a> does not need to be used prior to invoking the interface on a <b>Box</b>. In fact, method <b>Box::HasInterface</b> returns <code>true</code> if and only if a type specific interface is in place.</p>
</li>
</ul>
<p><b>How ALib Boxing is extended:</b><br />
</p><ul>
<li>User defined types (e.g. structs and classes) are supported without the need of adding type specific code to <b>ALib Boxing</b>. The boxed type by default is a pointer type of the original type.</li>
<li><p class="startli">To change the default behaviour of boxing a custom type, template struct</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">T_Boxing&lt;TBoxable&gt;</a></li>
</ul>
<p class="startli">needs to be specialized. It is recommended to use macro <a class="el" href="group__GrpALibMacros.html#ga8c3e36e52f60303e7639ae48b146f0d6">ALIB_BOXING_SPECIALIZE</a> for this purpose.</p>
</li>
<li><p class="startli">To implement custom logic for boxing and unboxing a value, methods</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#aefb0e0f2f3b71d443b0f590698407367">T_Boxing&lt;TBoxable&gt;::HasCustomBoxing</a> and</li>
<li><a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a7c300d564618b287a95515308e0dc5fd">T_Boxing&lt;TBoxable&gt;::HasCustomUnboxing</a></li>
</ul>
<p class="startli">need to return <code>true</code> in the specialization. Furthermore, methods</p><ul>
<li><a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#adfa6c5fa593667614c5c9346247b4c1d">T_Boxing&lt;TBoxable&gt;::Boxing</a></li>
<li><a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a5dfd7dc3e9e72651fd2441d71bc56163">T_Boxing&lt;TBoxable&gt;::Unboxing</a></li>
</ul>
<p class="startli">need to be defined.</p>
</li>
<li>To add new interface methods to custom types or any other boxable type, an interface type has to be derived from class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a>. An optional default implementation and type-specific versions of that interface have to be implemented by deriving in turn from the custom interface class and by overwriting method <b>Invoke</b>.<br />
 The interfaces have to be registered for boxed type once in the bootstrap section of a software process, using namespace functions <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a37543d2ad623b3940e735b122fe5d586">DefineDefaultInterface</a> and <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#aa1f769d5f1032bc1cc569f4353f9ccd8">DefineInterface</a>.</li>
<li>Reasons for extending <b>ALib Boxing</b> to add support for custom types are:<ul>
<li>If a different boxed type should be the result of boxing a custom type. e.g. to do non-bijective boxing, which means several custom types should result in the same boxed type.</li>
<li>If boxing or unboxing need to be customized.</li>
<li>If built-in interface methods should be specialized for a custom type</li>
<li>If new, custom interface methods should be made available.</li>
</ul>
</li>
</ul>
<p><b>Functions With Arbitrary Arguments:</b><br />
</p><ul>
<li><b>ALib Boxing</b> is very valuable when functions or methods that should accept arbitrary types are needed. When a function parameter is of type <code>const <a class="el" href="namespaceaworx.html#af923f654916f15a4287246e5bb3beabb">aworx::Box</a>&amp;</code>, this parameter accepts any C++ type "as is".</li>
<li>In addition, the implementation and use of <a href="http://en.cppreference.com/w/cpp/language/parameter_pack">variadic template arguments</a> becomes extremely easy.</li>
<li>For even more more sophisticated function parameter processing, class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxes.html">Boxes</a> is provided.</li>
</ul>
<p><b>Other Notes:</b><br />
</p><ul>
<li><b>ALib Boxing</b> needs to be <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_usage_bootstrap">bootstrapped</a> once at the start of a process</li>
<li><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#alib_namespace_boxing_usage_dump">Debug facilities</a> are provided that allow retrospection of the setup of <b>ALib Boxing</b> in respect to types that were boxed and interfaces that were set at a distinct point in time. </li>
</ul>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Nested namespaces</h2></td></tr>
<tr class="memitem:namespaceaworx_1_1lib_1_1boxing_1_1ftypes"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1ftypes.html">ftypes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceaworx_1_1lib_1_1boxing_1_1thirdparty"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1thirdparty.html">thirdparty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1ArrayBoxerT.html">ArrayBoxerT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html">BoxData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1BoxedAs.html">BoxedAs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html">Boxer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1BoxerT.html">BoxerT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxes.html">Boxes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1IEquals.html">IEquals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsEmpty.html">IIsEmpty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsNull.html">IIsNull</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1IIsNull__false.html">IIsNull_false</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Interface.html">Interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">T_Boxing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing_3_01BoxedAs_3_01TBoxed_01_4_01_4.html">T_Boxing&lt; BoxedAs&lt; TBoxed &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing_3_01std_1_1vector_3_01TElem_01_4_01_4.html">T_Boxing&lt; std::vector&lt; TElem &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">[DOX_ALIB_BOXING_STD_VECTOR]  <a href="structaworx_1_1lib_1_1boxing_1_1T__Boxing_3_01std_1_1vector_3_01TElem_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa3e009a14ed9d13b3f9cfac1ac29bee5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#aa3e009a14ed9d13b3f9cfac1ac29bee5">boxvalue</a> = uint64_t</td></tr>
<tr class="separator:aa3e009a14ed9d13b3f9cfac1ac29bee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa505e0719cf0f7cdca5da2e34aa0081d"><td class="memTemplParams" colspan="2">template&lt;typename TBoxable &gt; </td></tr>
<tr class="memitem:aa505e0719cf0f7cdca5da2e34aa0081d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#aa505e0719cf0f7cdca5da2e34aa0081d">DefaultBoxing</a> (<a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;, const TBoxable &amp;)</td></tr>
<tr class="separator:aa505e0719cf0f7cdca5da2e34aa0081d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b628b92185f310ea42b146c15b9ce1"><td class="memTemplParams" colspan="2">template&lt;typename TBoxable &gt; </td></tr>
<tr class="memitem:a28b628b92185f310ea42b146c15b9ce1"><td class="memTemplItemLeft" align="right" valign="top">TBoxable&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a28b628b92185f310ea42b146c15b9ce1">DefaultUnboxing</a> (const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;box)</td></tr>
<tr class="separator:a28b628b92185f310ea42b146c15b9ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37543d2ad623b3940e735b122fe5d586"><td class="memTemplParams" colspan="2">template&lt;typename TInterface &gt; </td></tr>
<tr class="memitem:a37543d2ad623b3940e735b122fe5d586"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a37543d2ad623b3940e735b122fe5d586">DefineDefaultInterface</a> ()</td></tr>
<tr class="separator:a37543d2ad623b3940e735b122fe5d586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f769d5f1032bc1cc569f4353f9ccd8"><td class="memTemplParams" colspan="2">template&lt;typename TBoxed , bool IsArray, typename TInterface &gt; </td></tr>
<tr class="memitem:aa1f769d5f1032bc1cc569f4353f9ccd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#aa1f769d5f1032bc1cc569f4353f9ccd8">DefineInterface</a> ()</td></tr>
<tr class="separator:aa1f769d5f1032bc1cc569f4353f9ccd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3b6d38df0786ccf7f938d60e386aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#gaa23c944e6d67aa52d2e05a1399151423">ALIB_NAMESPACE_INIT_FLAG</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a1e3b6d38df0786ccf7f938d60e386aae">Init</a> ()</td></tr>
<tr class="separator:a1e3b6d38df0786ccf7f938d60e386aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1411d8d90e41eb7a84088c30da5011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#abb1411d8d90e41eb7a84088c30da5011">InitQTString</a> ()</td></tr>
<tr class="separator:abb1411d8d90e41eb7a84088c30da5011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a046ed78c26c56f05dfe236e40c136b"><td class="memTemplParams" colspan="2">template&lt;typename TPlain &gt; </td></tr>
<tr class="memitem:a8a046ed78c26c56f05dfe236e40c136b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a8a046ed78c26c56f05dfe236e40c136b">T_SetArraySize</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> arrayExtent)</td></tr>
<tr class="separator:a8a046ed78c26c56f05dfe236e40c136b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0bcae1f7341255492ebc90deab5f01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a2a0bcae1f7341255492ebc90deab5f01">TerminationCleanUp</a> ()</td></tr>
<tr class="separator:a2a0bcae1f7341255492ebc90deab5f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa3e009a14ed9d13b3f9cfac1ac29bee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e009a14ed9d13b3f9cfac1ac29bee5">&#9670;&nbsp;</a></span>boxvalue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#aa3e009a14ed9d13b3f9cfac1ac29bee5">boxvalue</a> =  uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the type used for box data values. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa505e0719cf0f7cdca5da2e34aa0081d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa505e0719cf0f7cdca5da2e34aa0081d">&#9670;&nbsp;</a></span>DefaultBoxing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DefaultBoxing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TBoxable &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This template function provides the default implementation used to store values in struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html">BoxData</a> when they are placed in a <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a>.</p>
<p>To customize boxing for a type, specialize struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">aworx::lib::boxing::T_Boxing</a> (with the help of macro <a class="el" href="group__GrpALibMacros.html#ga8c3e36e52f60303e7639ae48b146f0d6">ALIB_BOXING_SPECIALIZE</a>) with implementing methods <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#aefb0e0f2f3b71d443b0f590698407367">T_Boxing::HasCustomBoxing</a> to return <code>true</code> and having <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#adfa6c5fa593667614c5c9346247b4c1d">T_Boxing::Boxing</a> to do the boxing.</p>
<p>Fields <a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html#ae5cc2f97c501622beca5fdeffb7e755c">BoxData::Value</a> and <a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html#a5f38f944ed993ecb18fb7bbcee7c8f9e">BoxData::Length</a> have to be set, because for efficiency reasons, both are not initialized otherwise.</p>
<p>However, specializing this method for custom boxable types is seldom necessary, because complex custom types (structs and classes) usually get announced to the <b>ALib</b> boxing system as pointer types. The default implementation of this function, as well as corresponding function <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html#a28b628b92185f310ea42b146c15b9ce1">DefaultUnboxing</a>, are using <code>memcpy</code> for reading and writing the value. This is necessary to avoid de-referencing type-punned pointers which breaks the strict-aliasing rule when compiling the code with higher optimization levels.</p>
<p>Typically, a custom version of boxing is needed for fundamental types (value types), when a type is stored as a different type in a box. For example, custom string types might be stored as pointer to the array of characters and the string length. The advantage is, that this way all custom string classes are stored in the same way, and code that is processing a <b>Box</b> does not need to check for more than one type.</p>
<p>See <a class="el" href="namespaceaworx_1_1lib_1_1boxing.html">documentation of <b>%ALib</b> %Boxing</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td>The <b>Box</b> to set the data vor </td></tr>
    <tr><td class="paramname">value</td><td>The 'native' data value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28b628b92185f310ea42b146c15b9ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b628b92185f310ea42b146c15b9ce1">&#9670;&nbsp;</a></span>DefaultUnboxing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TBoxable DefaultUnboxing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This template function provides the default implementation used to retrieve values from struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1BoxData.html">BoxData</a> from a <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a>.</p>
<p>To customize unboxing for a type, specialize struct <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">aworx::lib::boxing::T_Boxing</a> (with the help of macro <a class="el" href="group__GrpALibMacros.html#ga8c3e36e52f60303e7639ae48b146f0d6">ALIB_BOXING_SPECIALIZE</a>) with implementing methods <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a7c300d564618b287a95515308e0dc5fd">T_Boxing::HasCustomUnboxing</a> to return <code>true</code> and having <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html#a5dfd7dc3e9e72651fd2441d71bc56163">T_Boxing::Unboxing</a> to do the boxing.</p>
<p>See <a class="el" href="structaworx_1_1lib_1_1boxing_1_1T__Boxing.html">T_Boxing</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td>The <b>Box</b> to get the data of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the boxed data converted to template type <code>TBoxable</code>. </dd></dl>

</div>
</div>
<a id="a37543d2ad623b3940e735b122fe5d586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37543d2ad623b3940e735b122fe5d586">&#9670;&nbsp;</a></span>DefineDefaultInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void aworx::lib::boxing::DefineDefaultInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This namespace function defines default interfaces for boxed types that are not equipped with a specialized interface.</p>
<p>A static invocation of a method named <b>GetDefaultSingleton()</b> is invoked on type <code>TInterface</code> to receive the singleton instance of the interface used as a default implementation when invoked.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInterface</td><td>Type derived from class <b>Interface</b> which provides the default implementation for boxed types with no specific imlementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1f769d5f1032bc1cc569f4353f9ccd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f769d5f1032bc1cc569f4353f9ccd8">&#9670;&nbsp;</a></span>DefineInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void aworx::lib::boxing::DefineInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This namespace function allows the definition of invokable interfaces for boxed types. Three template parameters have to be given. The first, <code>TBoxed</code>, defines the boxed type that an interface method should be 'registered' with. <code>IsArray</code> denotes if <code>TBoxed</code> is an array type or not. Together both parameters are used to identify the right singleton of a derived <b>Boxer</b> class, on which method <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Boxer.html#ad4a321b8053fc083a3a91064e422795c">Boxer::DefineInterface</a> is invoked. The object that is passed as parameter is the result of static invocation of a method named <b>"GetSingleton()"</b> on the third template type <code>TInterface</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TBoxed</td><td>The boxed type which is to be equipped with an interface. </td></tr>
    <tr><td class="paramname">IsArray</td><td>Denotes if <code>TBoxed</code> is an array type. </td></tr>
    <tr><td class="paramname">TInterface</td><td>Type derived from class <b>Interface</b> which provides the implementation of the interface for type <code>TBoxed</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e3b6d38df0786ccf7f938d60e386aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3b6d38df0786ccf7f938d60e386aae">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the <b>ALib Boxing</b> system.</p>
<p>The method performs the following initialization steps:</p><ul>
<li>Adds default interface class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IEquals.html">IEquals</a></li>
<li>Adds default interface class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IEquals.html">IIsNull</a></li>
<li>Adds default interface class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1IEquals.html">IIsEmpty</a></li>
</ul>
<p>If code selection symbol <a class="el" href="group__GrpALibCodeSelectorSymbols.html#ga129dbb7714d49378dc9990ea96f01173">ALIB_FEAT_BOXING_FTYPES</a> is <code>1</code>, then in addition method <a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1ftypes.html#a78e0a4c7f228e5a0c57dff644b017570">aworx::lib::boxing::ftypes::Init</a> is invoked. </p>

</div>
</div>
<a id="abb1411d8d90e41eb7a84088c30da5011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1411d8d90e41eb7a84088c30da5011">&#9670;&nbsp;</a></span>InitQTString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void InitQTString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes <b>ALib Boxing</b> system in respect to boxing QT string types.</p>
<p>This method is <b>not</b> automatically invoked with <a class="el" href="classaworx_1_1lib_1_1ALIB.html#a53d8c6754ea7c4d7a0432cdb5f5b6371">ALIB::Init</a>, because the support for boxing QT string types is optional and due to the inclusion of header <b>"alib/compatiblity/qt.hpp"</b>.</p>
<p>In general, boxing ofQT string types works well without the one-time invocation of this function at the bootstrap of a process. What this method currently adds is interface <a class="el" href="classaworx_1_1lib_1_1strings_1_1boxing_1_1IApply.html">IApply</a> for boxed types</p><ul>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1BoxedAs.html">BoxedAs&lt;QByteArray&gt;</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1BoxedAs.html">BoxedAs&lt;QLatin1String&gt;</a></li>
<li><a class="el" href="classaworx_1_1lib_1_1boxing_1_1BoxedAs.html">BoxedAs&lt;QString&gt;</a> This is only needed in some particular use cases. </li>
</ul>

</div>
</div>
<a id="a8a046ed78c26c56f05dfe236e40c136b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a046ed78c26c56f05dfe236e40c136b">&#9670;&nbsp;</a></span>T_SetArraySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> aworx::lib::boxing::T_SetArraySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>arrayExtent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is invoked by the constructor of class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a> to determine the length of an array.</p>
<p>Prior to the invocation, the length of the array provided, is deducted from the type using TMP and passed as a parameter to this method.</p>
<p>Normally, this method should not be specialized. The whole rational to do this exercise is to prepare the right handling of literal string arrays. Those are including a terminating <code>0</code> character (added by the compiler) and hence their boxing implementation might be deducted by <code>1</code>. As a sample, the standard implementation of boxing fundamental types, provided with namespace <a class="el" href="namespaceaworx_1_1lib_1_1boxing_1_1ftypes.html">aworx::lib::boxing::ftypes</a> (optionally replaced by a custom implementation of fundamental types boxing) uses this feature. This way, other string types (e.g. of various widely used libraries) can be boxed as a character array using their right string length.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TPlain</td><td>The value type of the array (e.g. <code>int</code>, <code>char</code> or <code>MyType</code>) excluding const/volatile and array extends. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayExtent</td><td>The array extent as deducted using TMP in constructor of class <a class="el" href="classaworx_1_1lib_1_1boxing_1_1Box.html">Box</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length as given by <code>arrayExtent</code>. Specializations of this method may return something different. </dd></dl>

</div>
</div>
<a id="a2a0bcae1f7341255492ebc90deab5f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0bcae1f7341255492ebc90deab5f01">&#9670;&nbsp;</a></span>TerminationCleanUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TerminationCleanUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>De-initializes <b>ALib Boxing</b> system. This is (as of today) not necessary, but might be in the future. Also, some valgrind warnings might disappear when this is invoked properly. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 13 2017 18:47:57 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<!-- Start of StatCounter Code e -->
<script type="text/javascript">
var sc_project=11242602;
var sc_invisible=1;
var sc_security="5ac13373";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web statistics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11242602/0/5ac13373/1/" alt="web
statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
