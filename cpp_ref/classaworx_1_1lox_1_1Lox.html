<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>ALox: Lox Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!-- so strange, that doxgen does not highlight each menu item. Just some... -->
<script>
  $(document).ready(function() {     
    fnameStart= window.location.href.lastIndexOf('/')
    fnameEnd=   window.location.href.indexOf('_', fnameStart )
    if( fnameEnd < 0 ) {
        fnameEnd=   window.location.href.indexOf('.', fnameStart )
    }
    if( fnameEnd > -1 ) {
        subString= window.location.href.substring( fnameStart, fnameEnd )
        $('li').toArray().forEach(function(li){
            if(     typeof li.firstChild.href != 'undefined'
                &&  li.firstChild.href.indexOf(subString) > 0 
                ){
               li.classList.add('current');
            }
        });
    }
  });
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">ALox 
   &#160;<span id="projectnumber">Logging for C++, C# and Java (V 1.2.0)</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../index.html"><span>ALox&#160;Home</span></a></li>
      <li><a href="../faq.html"><span>FAQ</span></a></li>
      <li><a href="../manual.html"><span>Manual</span></a></li>
      <li class="current"><a href="cppmainpage.html"><span>ALox&#160;for&#160;C++</span></a></li>
      <li><a href="../cs_ref/csmainpage.html"><span>ALox&#160;for&#160;C#</span></a></li>
      <li><a href="../java_ref/javamainpage.html"><span>ALox&#160;for&#160;Java</span></a></li>
      <li><a href="https://github.com/AlexWorx/ALox-Logging-Library"><span>Download</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="cppmainpage.html"><span>Overview</span></a></li>
      <li><a href="cpptutorial.html"><span>Tutorial</span></a></li>
      <li><a href="cppsetup.html"><span>IDE/Build&#160;system&#160;setup</span></a></li>
      <li><a href="cppprepro.html"><span>ALox&#160;Preprocessor&#160;Symbols</span></a></li>
      <li class="current"><a href="annotated.html"><span>Class&#160;Reference</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="classes.html"><span>Alphabetical&#160;Index</span></a></li>
      <li><a href="annotated.html"><span>Namespace&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lox.html">lox</a></li><li class="navelem"><a class="el" href="classaworx_1_1lox_1_1Lox.html">Lox</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classaworx_1_1lox_1_1Lox-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Lox Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="lox_8hpp_source.html">lox.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Lox:</div>
<div class="dyncontent">
<div class="center"><img src="classaworx_1_1lox_1_1Lox__inherit__graph.png" border="0" usemap="#Lox_inherit__map" alt="Inheritance graph"/></div>
<map name="Lox_inherit__map" id="Lox_inherit__map">
<area shape="rect" id="node2" href="classaworx_1_1util_1_1ThreadLock.html" title="ThreadLock" alt="" coords="5,80,95,107"/><area shape="rect" id="node3" href="classaworx_1_1util_1_1Ownable.html" title="Ownable" alt="" coords="14,5,86,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adeecd070b47db04dfac1b186f99a95d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#adeecd070b47db04dfac1b186f99a95d2">Lox</a> ()</td></tr>
<tr class="separator:adeecd070b47db04dfac1b186f99a95d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df22829cdb5cad1db7f72bb0b068d5b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a8df22829cdb5cad1db7f72bb0b068d5b">~Lox</a> ()</td></tr>
<tr class="separator:a8df22829cdb5cad1db7f72bb0b068d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0644685b4c4edc6adfd932448d0549d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a0644685b4c4edc6adfd932448d0549d4">AcquireAndSetCI</a> (const char *file, int line, const char *func)</td></tr>
<tr class="separator:a0644685b4c4edc6adfd932448d0549d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fe77bd2e5080af5dcd7239c921d4f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a40fe77bd2e5080af5dcd7239c921d4f2">AddLogger</a> (<a class="el" href="classaworx_1_1lox_1_1core_1_1Logger.html">core::Logger</a> *logger, <a class="el" href="classaworx_1_1lox_1_1Log.html#a10ac165398697ce1d642d739cc3b170f">Log::DomainLevel</a> internalDomainLevel=<a class="el" href="classaworx_1_1lox_1_1Log.html#a10ac165398697ce1d642d739cc3b170face948b1e2bf728769120ded409b6d3f4">Log::DomainLevel::WARNINGS_AND_ERRORS</a>)</td></tr>
<tr class="separator:a40fe77bd2e5080af5dcd7239c921d4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4957054803ee1c7d3e66a98bd144eda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> <a class="el" href="classaworx_1_1lox_1_1core_1_1Logger.html">core::Logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#ae4957054803ee1c7d3e66a98bd144eda">GetLogger</a> (const char *loggerName)</td></tr>
<tr class="separator:ae4957054803ee1c7d3e66a98bd144eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6901dfd4853b8287bede398b6d4c86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a9d6901dfd4853b8287bede398b6d4c86">RemoveLogger</a> (const <a class="el" href="classaworx_1_1lox_1_1core_1_1Logger.html">core::Logger</a> *logger)</td></tr>
<tr class="separator:a9d6901dfd4853b8287bede398b6d4c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8014b18a4105e4c3f90b617c4f5f552c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a8014b18a4105e4c3f90b617c4f5f552c">RemoveLoggers</a> (const char *loggerFilter=nullptr)</td></tr>
<tr class="separator:a8014b18a4105e4c3f90b617c4f5f552c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95e6fc3b2415de811381dc89fdfa0ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#ac95e6fc3b2415de811381dc89fdfa0ba">RegDomain</a> (const char *domain, <a class="el" href="classaworx_1_1lox_1_1Log.html#aaecc53892786f2fa11e682f633af84c6">Log::Scope</a> scope=<a class="el" href="classaworx_1_1lox_1_1Log.html#aaecc53892786f2fa11e682f633af84c6ab50339a10e1de285ac99d4c3990b8693">Log::Scope::NONE</a>)</td></tr>
<tr class="separator:ac95e6fc3b2415de811381dc89fdfa0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6bea88c046549c0ace6df70fe95784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#adb6bea88c046549c0ace6df70fe95784">SetDomain</a> (const char *domain, <a class="el" href="classaworx_1_1lox_1_1Log.html#a10ac165398697ce1d642d739cc3b170f">Log::DomainLevel</a> domainLevel, bool recursive=true, const char *loggerFilter=nullptr)</td></tr>
<tr class="separator:adb6bea88c046549c0ace6df70fe95784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379766928f419ca48ec0ee29042d4eca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a379766928f419ca48ec0ee29042d4eca">SetDisabled</a> (bool disabled, const char *loggerFilter=nullptr)</td></tr>
<tr class="separator:a379766928f419ca48ec0ee29042d4eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4169cc06bd70015963ed67bc32ac5e7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a4169cc06bd70015963ed67bc32ac5e7e">SetStartTime</a> (<a class="el" href="classaworx_1_1util_1_1Ticks.html">aworx::util::Ticks</a> startTime=<a class="el" href="classaworx_1_1util_1_1Ticks.html">aworx::util::Ticks</a>(0), const char *loggerFilter=nullptr)</td></tr>
<tr class="separator:a4169cc06bd70015963ed67bc32ac5e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8263f9417850ec3971ef21b7012279b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#aa8263f9417850ec3971ef21b7012279b">SetStartTime</a> (time_t startTime, const char *loggerFilter=nullptr)</td></tr>
<tr class="separator:aa8263f9417850ec3971ef21b7012279b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6991342ae8c86c8799d893348578f8b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a6991342ae8c86c8799d893348578f8b4">SetStartTime</a> (LPFILETIME startTime, const char *loggerFilter=nullptr)</td></tr>
<tr class="separator:a6991342ae8c86c8799d893348578f8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789f740b0be08dfb2aef2bd04ad5985e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a789f740b0be08dfb2aef2bd04ad5985e">MapThreadName</a> (const char *threadName, int id=0)</td></tr>
<tr class="separator:a789f740b0be08dfb2aef2bd04ad5985e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848fdd8b93afc2b2c89d526d4d128e3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a848fdd8b93afc2b2c89d526d4d128e3e">SetMarker</a> (void *marker, <a class="el" href="classaworx_1_1lox_1_1Log.html#aaecc53892786f2fa11e682f633af84c6">Log::Scope</a> scope)</td></tr>
<tr class="separator:a848fdd8b93afc2b2c89d526d4d128e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0a8913fff2143fb1eb6d2b86098933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a5c0a8913fff2143fb1eb6d2b86098933">GetMarker</a> (<a class="el" href="classaworx_1_1lox_1_1Log.html#aaecc53892786f2fa11e682f633af84c6">Log::Scope</a> scope)</td></tr>
<tr class="separator:a5c0a8913fff2143fb1eb6d2b86098933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c296178682f2e76b12f2b59e1effbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a06c296178682f2e76b12f2b59e1effbb">LogConfig</a> (const char *domain, <a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a> level, const char *headLine, const char *loggerFilter=nullptr)</td></tr>
<tr class="separator:a06c296178682f2e76b12f2b59e1effbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1bbdb35d69e51f668aed0acbc5b60d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a6a1bbdb35d69e51f668aed0acbc5b60d">Verbose</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;msg, int indent=0)</td></tr>
<tr class="separator:a6a1bbdb35d69e51f668aed0acbc5b60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab894104f3d8b9146fb806719bfcb57e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#ab894104f3d8b9146fb806719bfcb57e9">Verbose</a> (const char *domain, const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;msg, int indent=0)</td></tr>
<tr class="separator:ab894104f3d8b9146fb806719bfcb57e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bcc2a6c72d77f597fc731392fcb4c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#ad7bcc2a6c72d77f597fc731392fcb4c4">Verbose</a> (std::string &amp;msg, int indent=0)</td></tr>
<tr class="separator:ad7bcc2a6c72d77f597fc731392fcb4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b65ef21618836b3567f6ffed7dec49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a07b65ef21618836b3567f6ffed7dec49">Verbose</a> (const char *domain, std::string &amp;msg, int indent=0)</td></tr>
<tr class="separator:a07b65ef21618836b3567f6ffed7dec49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5615566c8c95c8ef55526af4d69cbec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#ab5615566c8c95c8ef55526af4d69cbec">Verbose</a> (const char *msg, int indent=0)</td></tr>
<tr class="separator:ab5615566c8c95c8ef55526af4d69cbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508f30a1ed4883bf8c0c3f46b7052d6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a508f30a1ed4883bf8c0c3f46b7052d6d">Verbose</a> (const char *domain, const char *msg, int indent=0)</td></tr>
<tr class="separator:a508f30a1ed4883bf8c0c3f46b7052d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9078b290ca9b7deb95df3e50a2b6824d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a9078b290ca9b7deb95df3e50a2b6824d">Info</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;msg, int indent=0)</td></tr>
<tr class="separator:a9078b290ca9b7deb95df3e50a2b6824d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab3da05f3ded4916807f173de3274c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#acab3da05f3ded4916807f173de3274c4">Info</a> (const char *domain, const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;msg, int indent=0)</td></tr>
<tr class="separator:acab3da05f3ded4916807f173de3274c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7aab72b2f79cb499bf988bce33e483f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#aa7aab72b2f79cb499bf988bce33e483f">Info</a> (std::string &amp;msg, int indent=0)</td></tr>
<tr class="separator:aa7aab72b2f79cb499bf988bce33e483f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aec7231604d55e242feaeb9e94e2909"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a2aec7231604d55e242feaeb9e94e2909">Info</a> (const char *domain, std::string &amp;msg, int indent=0)</td></tr>
<tr class="separator:a2aec7231604d55e242feaeb9e94e2909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117214c834eafe83d3922952ce58461c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a117214c834eafe83d3922952ce58461c">Info</a> (const char *msg, int indent=0)</td></tr>
<tr class="separator:a117214c834eafe83d3922952ce58461c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796f3faf05d773690daa7dde68c7096e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a796f3faf05d773690daa7dde68c7096e">Info</a> (const char *domain, const char *msg, int indent=0)</td></tr>
<tr class="separator:a796f3faf05d773690daa7dde68c7096e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f6a22706d472dab0dac046f2d2e00f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a85f6a22706d472dab0dac046f2d2e00f">Warning</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;msg, int indent=0)</td></tr>
<tr class="separator:a85f6a22706d472dab0dac046f2d2e00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347632c8379b63f60c70db167264ad8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a347632c8379b63f60c70db167264ad8e">Warning</a> (const char *domain, const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;msg, int indent=0)</td></tr>
<tr class="separator:a347632c8379b63f60c70db167264ad8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9574aef2b6eab33d545cdd285102edb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a9574aef2b6eab33d545cdd285102edb2">Warning</a> (std::string &amp;msg, int indent=0)</td></tr>
<tr class="separator:a9574aef2b6eab33d545cdd285102edb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db266ea26910ea5a060c848d7cba1d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a0db266ea26910ea5a060c848d7cba1d8">Warning</a> (const char *domain, std::string &amp;msg, int indent=0)</td></tr>
<tr class="separator:a0db266ea26910ea5a060c848d7cba1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebe1f98232518c4cc5e2dad2485520d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a9ebe1f98232518c4cc5e2dad2485520d">Warning</a> (const char *msg, int indent=0)</td></tr>
<tr class="separator:a9ebe1f98232518c4cc5e2dad2485520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa590c1fba6a794b8116fdb046662a423"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#aa590c1fba6a794b8116fdb046662a423">Warning</a> (const char *domain, const char *msg, int indent=0)</td></tr>
<tr class="separator:aa590c1fba6a794b8116fdb046662a423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36b889837a5d808bd57697327495cc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#aa36b889837a5d808bd57697327495cc5">Error</a> (const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;msg, int indent=0)</td></tr>
<tr class="separator:aa36b889837a5d808bd57697327495cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d342fcd55892dd17da33a8a83b159b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a20d342fcd55892dd17da33a8a83b159b">Error</a> (const char *domain, const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;msg, int indent=0)</td></tr>
<tr class="separator:a20d342fcd55892dd17da33a8a83b159b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaef4698219a1450751acaf17ee8284"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#aacaef4698219a1450751acaf17ee8284">Error</a> (std::string &amp;msg, int indent=0)</td></tr>
<tr class="separator:aacaef4698219a1450751acaf17ee8284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18901a822dc69642e3a84e53f7e1f9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#af18901a822dc69642e3a84e53f7e1f9b">Error</a> (const char *domain, std::string &amp;msg, int indent=0)</td></tr>
<tr class="separator:af18901a822dc69642e3a84e53f7e1f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbe21facbd4bd527ad3c9f1d1d93f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a9bbe21facbd4bd527ad3c9f1d1d93f52">Error</a> (const char *msg, int indent=0)</td></tr>
<tr class="separator:a9bbe21facbd4bd527ad3c9f1d1d93f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be5f0c4e160a5d40712fe8a29257f8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a6be5f0c4e160a5d40712fe8a29257f8c">Error</a> (const char *domain, const char *msg, int indent=0)</td></tr>
<tr class="separator:a6be5f0c4e160a5d40712fe8a29257f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11b5ceb2e2c82253f7341d111ea40b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#aa11b5ceb2e2c82253f7341d111ea40b8">Assert</a> (bool trueOrLog, const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;msg, int indent=0)</td></tr>
<tr class="separator:aa11b5ceb2e2c82253f7341d111ea40b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25401b43a007a667fab48e7109ac48a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#af25401b43a007a667fab48e7109ac48a">Assert</a> (bool trueOrLog, const char *domain, const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;msg, int indent=0)</td></tr>
<tr class="separator:af25401b43a007a667fab48e7109ac48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3ba8e08d5969caa0fa596300baa50c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#aca3ba8e08d5969caa0fa596300baa50c">Assert</a> (bool trueOrLog, std::string &amp;msg, int indent=0)</td></tr>
<tr class="separator:aca3ba8e08d5969caa0fa596300baa50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74274f77a029f5f5e7f4eb797284921b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a74274f77a029f5f5e7f4eb797284921b">Assert</a> (bool trueOrLog, const char *domain, std::string &amp;msg, int indent=0)</td></tr>
<tr class="separator:a74274f77a029f5f5e7f4eb797284921b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57111575ff929d5f44c3da61b3deebc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#ac57111575ff929d5f44c3da61b3deebc">Assert</a> (bool trueOrLog, const char *msg, int indent=0)</td></tr>
<tr class="separator:ac57111575ff929d5f44c3da61b3deebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575522ea15c99bb5cc2260c8053de2bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a575522ea15c99bb5cc2260c8053de2bb">Assert</a> (bool trueOrLog, const char *domain, const char *msg, int indent=0)</td></tr>
<tr class="separator:a575522ea15c99bb5cc2260c8053de2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf85add41ef247d4d8f7f82c06d8e58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a9bf85add41ef247d4d8f7f82c06d8e58">Line</a> (bool doLog, const char *domain, <a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a> level, const void *msgObject, int typeInfo, int indent=0, const char *loggerFilter=nullptr)</td></tr>
<tr class="separator:a9bf85add41ef247d4d8f7f82c06d8e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9ea4f7ed68f0f19a31cd41425fc7ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#aeb9ea4f7ed68f0f19a31cd41425fc7ad">Line</a> (const char *domain, <a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a> level, const void *msgObject, int typeInfo, int indent=0, const char *loggerFilter=nullptr)</td></tr>
<tr class="separator:aeb9ea4f7ed68f0f19a31cd41425fc7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc1d6f0e2df99183ed47e6faa01584c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a7bc1d6f0e2df99183ed47e6faa01584c">Line</a> (<a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a> level, const void *msgObject, int typeInfo, int indent=0, const char *loggerFilter=nullptr)</td></tr>
<tr class="separator:a7bc1d6f0e2df99183ed47e6faa01584c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classaworx_1_1util_1_1ThreadLock"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classaworx_1_1util_1_1ThreadLock')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classaworx_1_1util_1_1ThreadLock.html">ThreadLock</a></td></tr>
<tr class="memitem:ac633439ece63e381762e30fc8599c1a9 inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#ac633439ece63e381762e30fc8599c1a9">ThreadLock</a> (bool <a class="el" href="classaworx_1_1util_1_1ThreadLock.html#a1ea15561e57893d4e2a4a16a366cdb68">recursiveMode</a>=true, bool setUnsafeMode=false)</td></tr>
<tr class="separator:ac633439ece63e381762e30fc8599c1a9 inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d4d1d8df991fec098bbd8d5f19e34b inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#a62d4d1d8df991fec098bbd8d5f19e34b">~ThreadLock</a> ()</td></tr>
<tr class="separator:a62d4d1d8df991fec098bbd8d5f19e34b inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91dc804181f48b0b445ac1299c36c05 inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#ab91dc804181f48b0b445ac1299c36c05">Acquire</a> ()</td></tr>
<tr class="separator:ab91dc804181f48b0b445ac1299c36c05 inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c93747c8daa99d65c2a04c6be0748c inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#a94c93747c8daa99d65c2a04c6be0748c">Release</a> ()</td></tr>
<tr class="separator:a94c93747c8daa99d65c2a04c6be0748c inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec22b72d4f4c52f3dc81d9c8653e91dd inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#aec22b72d4f4c52f3dc81d9c8653e91dd">IsAcquired</a> (<a class="el" href="classaworx_1_1util_1_1Thread.html">Thread</a> *thread=nullptr)</td></tr>
<tr class="separator:aec22b72d4f4c52f3dc81d9c8653e91dd inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c3cd592757e0998048abf426d2412c inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpAWXUMacros.html#ga4a9af87b85599523bde61f69408cf5b5">AWXU_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#ae8c3cd592757e0998048abf426d2412c">SetUnsafe</a> (bool setUnsafe)</td></tr>
<tr class="separator:ae8c3cd592757e0998048abf426d2412c inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2bccd9812728e715f73c27dac06614 inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#abf2bccd9812728e715f73c27dac06614">IsUnsafe</a> ()</td></tr>
<tr class="separator:abf2bccd9812728e715f73c27dac06614 inherit pub_methods_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2c80e5630abe5d5042ddb4b85c0c3562"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a2c80e5630abe5d5042ddb4b85c0c3562">CntLogCalls</a> =0</td></tr>
<tr class="separator:a2c80e5630abe5d5042ddb4b85c0c3562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501063584539f51e463034b3d496a41e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a501063584539f51e463034b3d496a41e">InternalDomain</a> =&quot;ALOX&quot;</td></tr>
<tr class="separator:a501063584539f51e463034b3d496a41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classaworx_1_1util_1_1ThreadLock"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classaworx_1_1util_1_1ThreadLock')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classaworx_1_1util_1_1ThreadLock.html">ThreadLock</a></td></tr>
<tr class="memitem:a1a326aeefec583cbccf74ea567257e11 inherit pub_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#a1a326aeefec583cbccf74ea567257e11">WaitWarningTimeLimitInMillis</a> =1000L</td></tr>
<tr class="separator:a1a326aeefec583cbccf74ea567257e11 inherit pub_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b35011c911bf00d065eba8af27620a7 inherit pub_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#a2b35011c911bf00d065eba8af27620a7">RecursionWarningThreshold</a> =10</td></tr>
<tr class="separator:a2b35011c911bf00d065eba8af27620a7 inherit pub_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a4d2901c4588d0015fd52285741fbc312"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a4d2901c4588d0015fd52285741fbc312">Version</a> [] = &quot;1.2.0&quot;</td></tr>
<tr class="separator:a4d2901c4588d0015fd52285741fbc312"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a96a95335eaa6e3048aaaf3d4df4fc1fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a96a95335eaa6e3048aaaf3d4df4fc1fd">evaluateResultDomain</a> (const char *domain)</td></tr>
<tr class="separator:a96a95335eaa6e3048aaaf3d4df4fc1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ac8435abca79b681a002702880b495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a38ac8435abca79b681a002702880b495">internalLog</a> (<a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a> level, <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;msg)</td></tr>
<tr class="separator:a38ac8435abca79b681a002702880b495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c37aa9b52ff4115cbae1219c1a2a64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#ae8c37aa9b52ff4115cbae1219c1a2a64">logConfigDomainRecursive</a> (<a class="el" href="classaworx_1_1lox_1_1core_1_1LogDomain.html">core::LogDomain</a> &amp;domain, int indent, <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;domPath, <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;buffer)</td></tr>
<tr class="separator:ae8c37aa9b52ff4115cbae1219c1a2a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a54b4845d925cf72ef3015d8b900fe9e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a54b4845d925cf72ef3015d8b900fe9e0">simpleWildcardFilter</a> (<a class="el" href="classaworx_1_1lox_1_1core_1_1Logger.html">core::Logger</a> *logger, const char *loggerFilter)</td></tr>
<tr class="separator:a54b4845d925cf72ef3015d8b900fe9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8af08b7d47cdaedadac30275031331eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8af08b7d47cdaedadac30275031331eb"></a>
std::vector&lt; <a class="el" href="classaworx_1_1lox_1_1core_1_1Logger.html">core::Logger</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a8af08b7d47cdaedadac30275031331eb">loggers</a></td></tr>
<tr class="memdesc:a8af08b7d47cdaedadac30275031331eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The loggers. At least one logger (e.g. ConsoleLogger) needs to be created. <br /></td></tr>
<tr class="separator:a8af08b7d47cdaedadac30275031331eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1337323545f16d91f420d85482d1307"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1337323545f16d91f420d85482d1307"></a>
std::map&lt; <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a>, <a class="el" href="namespaceaworx_1_1util.html#a09ba3e296bcc9177176ba0546ebaeaab">util::AString16</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#af1337323545f16d91f420d85482d1307">defaultDomains</a></td></tr>
<tr class="memdesc:af1337323545f16d91f420d85482d1307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional default domains for a source file. <br /></td></tr>
<tr class="separator:af1337323545f16d91f420d85482d1307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8bd6717d518ea95ec95ace5f698159"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb8bd6717d518ea95ec95ace5f698159"></a>
std::map&lt; <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a>, void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#acb8bd6717d518ea95ec95ace5f698159">markers</a></td></tr>
<tr class="memdesc:acb8bd6717d518ea95ec95ace5f698159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code markers. <br /></td></tr>
<tr class="separator:acb8bd6717d518ea95ec95ace5f698159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646032d030f17f9bd676d427fbf788b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a646032d030f17f9bd676d427fbf788b8"></a>
<a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a646032d030f17f9bd676d427fbf788b8">resDomain</a></td></tr>
<tr class="memdesc:a646032d030f17f9bd676d427fbf788b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resulting domain name. <br /></td></tr>
<tr class="separator:a646032d030f17f9bd676d427fbf788b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f03380b7450165d47b292ccd8ad86ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1lox_1_1core_1_1CallerInfo.html">core::CallerInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#a3f03380b7450165d47b292ccd8ad86ff">callerInfo</a></td></tr>
<tr class="separator:a3f03380b7450165d47b292ccd8ad86ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classaworx_1_1util_1_1ThreadLock"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classaworx_1_1util_1_1ThreadLock')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classaworx_1_1util_1_1ThreadLock.html">ThreadLock</a></td></tr>
<tr class="memitem:a1ea15561e57893d4e2a4a16a366cdb68 inherit pro_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#a1ea15561e57893d4e2a4a16a366cdb68">recursiveMode</a></td></tr>
<tr class="separator:a1ea15561e57893d4e2a4a16a366cdb68 inherit pro_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f41e1e3070abd18f7cdfdb9a95b3d9c inherit pro_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#a7f41e1e3070abd18f7cdfdb9a95b3d9c">lockCount</a> =0</td></tr>
<tr class="separator:a7f41e1e3070abd18f7cdfdb9a95b3d9c inherit pro_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d42f8ca4a142dc8f1e48b8329b17be7 inherit pro_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaworx_1_1util_1_1Thread.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#a6d42f8ca4a142dc8f1e48b8329b17be7">owner</a> =nullptr</td></tr>
<tr class="separator:a6d42f8ca4a142dc8f1e48b8329b17be7 inherit pro_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925e97cfc2fb5e3b27bd06f805668a9d inherit pro_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top">std::mutex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#a925e97cfc2fb5e3b27bd06f805668a9d">mutex</a> =nullptr</td></tr>
<tr class="separator:a925e97cfc2fb5e3b27bd06f805668a9d inherit pro_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546b08274dd279ace7093f6b6d562beb inherit pro_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memItemLeft" align="right" valign="top">std::condition_variable *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1util_1_1ThreadLock.html#a546b08274dd279ace7093f6b6d562beb">mutexNotifier</a> =nullptr</td></tr>
<tr class="separator:a546b08274dd279ace7093f6b6d562beb inherit pro_attribs_classaworx_1_1util_1_1ThreadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aaa96ca32f5b8d83954f9d77629c1b036"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lox_1_1Lox.html#aaa96ca32f5b8d83954f9d77629c1b036">_apiInitializer</a></td></tr>
<tr class="separator:aaa96ca32f5b8d83954f9d77629c1b036"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><hr/>
<p> This class acts as a container for Loggers and provides a convenient interface into them. Features are:</p>
<p>a) Store and log into one or several Logger instances at once b) Manage default domain names for different scopes d) Store and manage caller information e) Store "code markers" and retrieve for simple tracing in log statements d) Provide shortcut methods to log strings. f) Count log operations</p>
<p><a class="el" href="classaworx_1_1lox_1_1Lox.html">Lox</a> inherits ThreadLock. Each <a class="el" href="classaworx_1_1lox_1_1Lox.html">Lox</a> method uses this mutex. If thread safeness is not needed for the logging system (see user manual) the mutex can be switched of using <a class="el" href="classaworx_1_1util_1_1ThreadLock.html#ae8c3cd592757e0998048abf426d2412c">SetUnsafe()</a> inherited by ThreadLock. The goal here would be to increase logging performance. This is really a very seldom case when performance is absolutely key, and it is better to be kept in safe mode. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adeecd070b47db04dfac1b186f99a95d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lox_1_1Lox.html">Lox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Constructs a new, empty <a class="el" href="classaworx_1_1lox_1_1Lox.html">Lox</a>. Note: This constructor has to stay in the header. This way, the <a class="el" href="classaworx_1_1lox_1_1Log.html#adf5526722711e47984a1b7fb93b219ce">Log::InitALox</a> call receives the size of classes from the compilation unit that invokes the constructor. If different compile options are set, we have a chance to detect them here. </p>

</div>
</div>
<a class="anchor" id="a8df22829cdb5cad1db7f72bb0b068d5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classaworx_1_1lox_1_1Lox.html">Lox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Destructs a lox </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0644685b4c4edc6adfd932448d0549d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AcquireAndSetCI </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Sets the caller information data for the next log. In addition, the method <a class="el" href="classaworx_1_1util_1_1ThreadLock.html#ab91dc804181f48b0b445ac1299c36c05">Acquire</a> of this class' # Ownable interface is invoked. Therefore, each invocation of this methods has to be followed by an invocation of # <a class="el" href="classaworx_1_1util_1_1ThreadLock.html#a94c93747c8daa99d65c2a04c6be0748c">Release()</a>.<br />
 When using <a class="el" href="group__GrpMacrosDebugLog.html">ALox Macros For Debug Logging</a>, this method is by the macros internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The name of the source code file that the call is placed in. Normally the predefined preprocessor macro <b>FILE</b> is passed here. </td></tr>
    <tr><td class="paramname">line</td><td>The line number within the source code file that the call is placed in. Normally the predefined preprocessor macro <b>LINE</b> is passed here. </td></tr>
    <tr><td class="paramname">func</td><td>The name of the function that the call is placed in. Normally the predefined preprocessor macro <b>func</b> (or <b>FUNCTION</b>) is passed here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40fe77bd2e5080af5dcd7239c921d4f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddLogger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1core_1_1Logger.html">core::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1Log.html#a10ac165398697ce1d642d739cc3b170f">Log::DomainLevel</a>&#160;</td>
          <td class="paramname"><em>internalDomainLevel</em> = <code><a class="el" href="classaworx_1_1lox_1_1Log.html#a10ac165398697ce1d642d739cc3b170face948b1e2bf728769120ded409b6d3f4">Log::DomainLevel::WARNINGS_AND_ERRORS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Adds a logger to the <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> interface. Each log call that is performed through this interface will be forwarded to this logger, unless filtered out with optional filter parameter. The logger will then check it's domain level against the given log level to decide whether a log should performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger</td><td>The logger to be added. </td></tr>
    <tr><td class="paramname">internalDomainLevel</td><td>(Optional) The desired domain level for the <a class="el" href="classaworx_1_1lox_1_1Lox.html#a501063584539f51e463034b3d496a41e">InternalDomain</a> which is used for logging code of class <a class="el" href="classaworx_1_1lox_1_1Lox.html">Lox</a> itself. For console loggers this can be set to <b>All</b>, for log streams dedicated to a certain domain, this should be set to ' <em>OFF</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa11b5ceb2e2c82253f7341d111ea40b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assert </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trueOrLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string only if the given condition is not true. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> level will be highest, namely Log::Level::Error if condition is false. This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trueOrLog</td><td>The log is only performed if condition is not true. </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) the indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af25401b43a007a667fab48e7109ac48a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assert </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trueOrLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string only if the given condition is not true. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> level will be highest, namely Log::Level::Error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trueOrLog</td><td>The log is only performed if condition is not true. </td></tr>
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) the indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca3ba8e08d5969caa0fa596300baa50c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assert </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trueOrLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string only if the given condition is not true. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> level will be highest, namely Error if condition is false. This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trueOrLog</td><td>The log is only performed if condition is not true. </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) the indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74274f77a029f5f5e7f4eb797284921b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assert </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trueOrLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string only if the given condition is not true. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> level will be highest, namely Log::Level::Error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trueOrLog</td><td>The log is only performed if condition is not true. </td></tr>
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) the indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac57111575ff929d5f44c3da61b3deebc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assert </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trueOrLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string only if the given condition is not true. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> level will be highest, namely Log::Level::Error if condition is false. This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trueOrLog</td><td>The log is only performed if condition is not true. </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) the indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a575522ea15c99bb5cc2260c8053de2bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Assert </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trueOrLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string only if the given condition is not true. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> level will be highest, namely Log::Level::Error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trueOrLog</td><td>The log is only performed if condition is not true. </td></tr>
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) the indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa36b889837a5d808bd57697327495cc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Error. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> messages of this log level are are always logged unless domains log level is set to <em>OFF</em>. This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20d342fcd55892dd17da33a8a83b159b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to <a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a> Error. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> messages of this log level are are always logged unless domains log level is set to <em>OFF</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacaef4698219a1450751acaf17ee8284"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Error </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Error. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> messages of this log level are are always logged unless domains log level is set to <em>OFF</em>. This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af18901a822dc69642e3a84e53f7e1f9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to <a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a> Error. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> messages of this log level are are always logged unless domains log level is set to <em>OFF</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bbe21facbd4bd527ad3c9f1d1d93f52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Error. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> messages of this log level are are always logged unless domains log level is set to <em>OFF</em>. This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6be5f0c4e160a5d40712fe8a29257f8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to <a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a> Error. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> messages of this log level are are always logged unless domains log level is set to <em>OFF</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96a95335eaa6e3048aaaf3d4df4fc1fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evaluateResultDomain </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Using the optionally provided domain and a default domain previously set according to the caller's scope. The resulting full domain string is evaluated as follows: If no domain given, the default domain is retrieved (depending on the caller's scope). If a domain is given it is used. If it is starting with a swung dash("~"), it is interpreted to be a sub domain of the default domain and both domains are concatenated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>A domain or path. If starting with a swung dash ('~') it is interpreted as being a sub domain of the default domain defined for the current caller's scope. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4957054803ee1c7d3e66a98bd144eda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lox_1_1core_1_1Logger.html">Logger</a> * GetLogger </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loggerName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Retrieve an instance of a Logger by its name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loggerName</td><td>The name of the logger to search for (case insensitive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The logger, nullptr if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c0a8913fff2143fb1eb6d2b86098933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * GetMarker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1Log.html#aaecc53892786f2fa11e682f633af84c6">Log::Scope</a>&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Retrieves the most recently marker object stored using <a class="el" href="classaworx_1_1lox_1_1Lox.html#a848fdd8b93afc2b2c89d526d4d128e3e">Lox.SetMarker</a>. Markers are stored and retrieved relative to a given <a class="el" href="classaworx_1_1lox_1_1Log.html#aaecc53892786f2fa11e682f633af84c6">Log::Scope</a>. In combination with <a class="el" href="classaworx_1_1lox_1_1Lox.html#a848fdd8b93afc2b2c89d526d4d128e3e">Lox.SetMarker</a>, this method provides an easy way to trace the last marked position, e.g. in the case of an exception. Within the exception handler, use this method to retrieve the last marker object stored before the exception was thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The code marker facility of ALox was designed primarily to support debugging of an application by the analysis of log files.<br />
 The C++ version of ALox implements scope mechanisms using caller information generated by the preprocessor. By default, debug logging supports such caller information, release logging does not. This can be changed. For more information on how to change such defaults, see <a class="el" href="group__GrpALoxCodeSelectorSymbols.html#ga392381bb9caea53c133ce68c32cee4e1">ALOX_DBG_LOG_CI</a> and <a class="el" href="group__GrpALoxCodeSelectorSymbols.html#ga4b0e38e300ec824146da5e868f2c6290">ALOX_REL_LOG_CI</a> in section <a class="el" href="group__GrpALoxCodeSelectorSymbols.html">ALox Symbols To Select Code Fragments</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>The scope in which the marker should be stored. Markers and scopes work independently from each other. Different markers can be stored within different scopes and no fallback to "outer scopes" is made. A scope of 'None' retrieves the global marker singleton. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The marker object, null if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a9078b290ca9b7deb95df3e50a2b6824d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p>Logs a string with log level equal to Log::Level::Info. This is the second highest (after Verbose) log level, which is only actually logged if the log domains log level is set to "Info" or "Verbose". This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acab3da05f3ded4916807f173de3274c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Info </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Info. This is the second highest (after Verbose) log level, which is only actually logged if the log domains log level is set to "Info" or "Verbose".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7aab72b2f79cb499bf988bce33e483f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Info </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Info. This is the second highest (after Verbose) log level, which is only actually logged if the log domains log level is set to "Info" or "Verbose". This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2aec7231604d55e242feaeb9e94e2909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Info </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Info. This is the second highest (after Verbose) log level, which is only actually logged if the log domains log level is set to "Info" or "Verbose".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a117214c834eafe83d3922952ce58461c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Info </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Info. This is the second highest (after Verbose) log level, which is only actually logged if the log domains log level is set to "Info" or "Verbose". This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a796f3faf05d773690daa7dde68c7096e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Info </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Info. This is the second highest (after Verbose) log level, which is only actually logged if the log domains log level is set to "Info" or "Verbose".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38ac8435abca79b681a002702880b495"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void internalLog </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Logs an internal error message to the domain given by field InternalDomain. Attn: must only be called after saveAndSet() was performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The log level. </td></tr>
    <tr><td class="paramname">msg</td><td>The message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bf85add41ef247d4d8f7f82c06d8e58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Line </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msgObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loggerFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Provides a more flexible but complex way to log a message. Especially it provides the possibility to log other objects than string types. The methods <a class="el" href="classaworx_1_1lox_1_1Lox.html#a6a1bbdb35d69e51f668aed0acbc5b60d">Verbose</a>, <a class="el" href="classaworx_1_1lox_1_1Lox.html#a9078b290ca9b7deb95df3e50a2b6824d">Info</a>, <a class="el" href="classaworx_1_1lox_1_1Lox.html#a85f6a22706d472dab0dac046f2d2e00f">Warning</a>, <a class="el" href="classaworx_1_1lox_1_1Lox.html#aa36b889837a5d808bd57697327495cc5">Error</a> and <a class="el" href="classaworx_1_1lox_1_1Lox.html#aa11b5ceb2e2c82253f7341d111ea40b8">Assert()</a> are 'shortcuts' to this function and are more convenient to use. For logging strings, use this function only in the rare cases, e.g. when a log level is decided only at runtime or when you want to use a logger filter, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doLog</td><td>Conditional logging. If false, the log is not performed. CntLogCalls is still increased by one. </td></tr>
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">level</td><td>The log level. </td></tr>
    <tr><td class="paramname">msgObject</td><td>The object to log. </td></tr>
    <tr><td class="paramname">typeInfo</td><td>Type information on the object to log. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
    <tr><td class="paramname">loggerFilter</td><td>(Optional) A filter for the loggers to be affected. This parameter enables different loggers to have different domains. A simple string compare without case sensitivity is performed. An asterisk ('*') at the beginning or end of the string is used as a wildcard. Leave nullptr if all loggers should be affected. Use this parameter only in more complex logging scenarios. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb9ea4f7ed68f0f19a31cd41425fc7ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Line </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msgObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loggerFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs an object using the given log level, log domain and indentation and logger filter. See <a class="el" href="classaworx_1_1lox_1_1Lox.html#a9bf85add41ef247d4d8f7f82c06d8e58">Line</a> for a version of this method that supports the maximum number of parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">level</td><td>The log level. </td></tr>
    <tr><td class="paramname">msgObject</td><td>The object to log. </td></tr>
    <tr><td class="paramname">typeInfo</td><td>Type information on the object to log. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
    <tr><td class="paramname">loggerFilter</td><td>(Optional) A filter for the loggers to be affected. This parameter enables different loggers to have different domains. A simple string compare without case sensitivity is performed. An asterisk ('*') at the beginning or end of the string is used as a wildcard. Leave nullptr if all loggers should be affected. Use this parameter only in more complex logging scenarios. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bc1d6f0e2df99183ed47e6faa01584c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>msgObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loggerFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs an object using the given log level, indentation and logger filter and the default domain set for the scope. See <a class="el" href="classaworx_1_1lox_1_1Lox.html#a9bf85add41ef247d4d8f7f82c06d8e58">Line</a> for a version of this method that supports the maximum number of parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The log level. </td></tr>
    <tr><td class="paramname">msgObject</td><td>The object to log. </td></tr>
    <tr><td class="paramname">typeInfo</td><td>Type information on the object to log. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
    <tr><td class="paramname">loggerFilter</td><td>(Optional) A filter for the loggers to be affected. This parameter enables different loggers to have different domains. A simple string compare without case sensitivity is performed. An asterisk ('*') at the beginning or end of the string is used as a wildcard. Leave nullptr if all loggers should be affected. Use this parameter only in more complex logging scenarios. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06c296178682f2e76b12f2b59e1effbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LogConfig </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1Log.html#a221b779e6bb7b8d40677d7642bfefac5">Log::Level</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>headLine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loggerFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> This method logs the configuration this <a class="el" href="classaworx_1_1lox_1_1Lox.html">Lox</a> and it's encapsulated objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">level</td><td>The log level. </td></tr>
    <tr><td class="paramname">headLine</td><td>If given, a separated headline will be logged at first place. </td></tr>
    <tr><td class="paramname">loggerFilter</td><td>(Optional) A filter for the loggers to be affected. This parameter enables different loggers to have different domains. A simple string compare without case sensitivity is performed. An asterisk ('*') at the beginning or end of the string is used as a wildcard. Leave nullptr if all loggers should be affected. Use this parameter only in more complex logging scenarios. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8c37aa9b52ff4115cbae1219c1a2a64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void logConfigDomainRecursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1core_1_1LogDomain.html">core::LogDomain</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>domPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Internal method used by <a class="el" href="classaworx_1_1lox_1_1Lox.html#a06c296178682f2e76b12f2b59e1effbb">LogConfig()</a> to recursively log LogDomain instances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>The LogDomain instance to log out. </td></tr>
    <tr><td class="paramname">indent</td><td>The indentation in the output, recursively increased.. </td></tr>
    <tr><td class="paramname">domPath</td><td>Actual path relative to recursion, solely for log output. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to log to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a789f740b0be08dfb2aef2bd04ad5985e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MapThreadName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>threadName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> This method sets a human readable name to the given thread ID (or current thread) which is optionally included in each log line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadName</td><td>The name of the thread as it should be displayed in the logs </td></tr>
    <tr><td class="paramname">id</td><td>(Optional) Parameter providing the thread ID. If omitted, the current thread's ID is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac95e6fc3b2415de811381dc89fdfa0ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RegDomain </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1Log.html#aaecc53892786f2fa11e682f633af84c6">Log::Scope</a>&#160;</td>
          <td class="paramname"><em>scope</em> = <code><a class="el" href="classaworx_1_1lox_1_1Log.html#aaecc53892786f2fa11e682f633af84c6ab50339a10e1de285ac99d4c3990b8693">Log::Scope::NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> This method is used to define a log domain. The method is usually invoked within the same source "context" (aka, class, namespace, package, etc.) that later on uses the domain to perform log statements. Often, calls to this functions are placed in static constructors or similar code that is executed only once and very early in the life-cycle of a process.</p>
<p>Each log statement refers to such a domain which can be used specifically for different parts of your application like assemblies, libraries, namespaces, specific code files or even for a single method. The domain name should be short, pregnant and self explaining.</p>
<p>Domains can be created with path separators '/', for example 'COMM/SOCK' could be the domain in a socket class, residing within a communication library. The advantage of creating paths and this way "sub domains", is that a whole bunch of logging domains can be altered (on/off) by just altering the root domain.</p>
<p>If a domain and path is given that is not known already, then the whole path of domains is created.</p>
<p>If the parameter <b>scope</b> is provided with a value not equal to Log::Scope.None, the given domain becomes the default domain for respective scope. For any subsequent log calls from within this scope, where no domain is explicitly given, this default domain is used. If subsequent log calls specify a domain name with a leading '~' character, then such domain is concatenated to the default domain to build a complete domain path.</p>
<dl class="section note"><dt>Note</dt><dd>The C++ version of ALox implements scope mechanisms using caller information generated by the preprocessor. By default, debug logging supports such caller information, release logging does not. This can be changed. For more information on how to change such defaults, see <a class="el" href="group__GrpALoxCodeSelectorSymbols.html#ga392381bb9caea53c133ce68c32cee4e1">ALOX_DBG_LOG_CI</a> and <a class="el" href="group__GrpALoxCodeSelectorSymbols.html#ga4b0e38e300ec824146da5e868f2c6290">ALOX_REL_LOG_CI</a> in section <a class="el" href="group__GrpALoxCodeSelectorSymbols.html">ALox Symbols To Select Code Fragments</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>The domain name (and path) to register. If this is starting with a swung dash ('~') this is interpreted a sub domain to a (potentially already set!) default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">scope</td><td>If a value other than Log::Scope.None is provided, the given domain name is registered as the default domain for the given scope. Default domains set for 'inner scopes' have higher priority than those set for outer scopes.<br />
 Available Scope definitions are platform/language dependent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d6901dfd4853b8287bede398b6d4c86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RemoveLogger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lox_1_1core_1_1Logger.html">core::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Removes a logger from this container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger</td><td>The logger to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if the logger was found and removed, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8014b18a4105e4c3f90b617c4f5f552c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RemoveLoggers </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loggerFilter</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Removes all loggers that match the filter name from this interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loggerFilter</td><td>(Optional) A filter for the loggers to be affected. A simple string compare without case sensitivity is performed. An asterisk ('*') at the beginning or end of the string is used as a wildcard. Defaults to nullptr which causes all loggers to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of loggers that were removed. </dd></dl>

</div>
</div>
<a class="anchor" id="a379766928f419ca48ec0ee29042d4eca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetDisabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loggerFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> This method is used disable one or more loggers completely without touching the log levels of the domains and hence without the need to restore such log levels later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disabled</td><td>If true, the logger(src) will be completely disabled, if false the normal domain specific log levels will be applied for log decisions. </td></tr>
    <tr><td class="paramname">loggerFilter</td><td>(Optional) A filter for the loggers to be affected. A simple string compare without case sensitivity is performed. An asterisk ('*') at the beginning or end of the string is used as a wildcard. Leave nullptr if all loggers should be affected. This parameter is optional and used in more complex logging scenarios. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb6bea88c046549c0ace6df70fe95784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetDomain </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1Log.html#a10ac165398697ce1d642d739cc3b170f">Log::DomainLevel</a>&#160;</td>
          <td class="paramname"><em>domainLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loggerFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Sets the domain log level and (by default) all it's sub domains recursively. In the case that sub domains should be set to a different log level, then this function has to be called for such sub domains after the call to the parent domain (or recursion has to be switched off, using the parameter 'recursive'). It is not necessary to register a domain before setting its log level and log levels can be set and modified any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">domainLevel</td><td>The domains log level to be set. </td></tr>
    <tr><td class="paramname">recursive</td><td>(Optional) Set sub domains recursively. Defaults to true. </td></tr>
    <tr><td class="paramname">loggerFilter</td><td>(Optional) A filter for the loggers to be affected. This parameter enables different loggers to have different domains and log levels. A simple string compare without case sensitivity is performed. An asterisk ('*') at the beginning or end of the string is used as a wildcard. Leave nullptr if all loggers should be affected. Use this parameter only in more complex logging scenarios. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a848fdd8b93afc2b2c89d526d4d128e3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetMarker </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>marker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1Log.html#aaecc53892786f2fa11e682f633af84c6">Log::Scope</a>&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> This method is used store a marker object in the logging system. Markers are stored and retrieved relative to a given <a class="el" href="classaworx_1_1lox_1_1Log.html#aaecc53892786f2fa11e682f633af84c6">Log::Scope</a>. In combination with <a class="el" href="classaworx_1_1lox_1_1Lox.html#a5c0a8913fff2143fb1eb6d2b86098933">Lox.GetMarker</a>, this method provides an easy way to trace the last marked position, e.g. in the case of an exception. Within the exception handler, use <a class="el" href="classaworx_1_1lox_1_1Lox.html#a5c0a8913fff2143fb1eb6d2b86098933">Lox.GetMarker</a> to retrieve the last marker object stored before the exception was thrown.</p>
<dl class="section note"><dt>Note</dt><dd>The code marker facility of ALox was designed primarily to support debugging of an application by the analysis of log files.<br />
 The C++ version of ALox implements scope mechanisms using caller information generated by the preprocessor. By default, debug logging supports such caller information, release logging does not. This can be changed. For more information on how to change such defaults, see <a class="el" href="group__GrpALoxCodeSelectorSymbols.html#ga392381bb9caea53c133ce68c32cee4e1">ALOX_DBG_LOG_CI</a> and <a class="el" href="group__GrpALoxCodeSelectorSymbols.html#ga4b0e38e300ec824146da5e868f2c6290">ALOX_REL_LOG_CI</a> in section <a class="el" href="group__GrpALoxCodeSelectorSymbols.html">ALox Symbols To Select Code Fragments</a>.<br />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">marker</td><td>The object to store, for example a std::string* that can be used for a log output later. </td></tr>
    <tr><td class="paramname">scope</td><td>The scope in which the marker should be stored. Markers and scopes work independently from each other. Different markers can be stored within different scopes and no fallback to "outer scopes" is made. A scope of 'None' stores the marker globally, hence as a system wide singleton. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4169cc06bd70015963ed67bc32ac5e7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetStartTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1util_1_1Ticks.html">aworx::util::Ticks</a>&#160;</td>
          <td class="paramname"><em>startTime</em> = <code><a class="el" href="classaworx_1_1util_1_1Ticks.html">aworx::util::Ticks</a>(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loggerFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> This method is used reset (or to explicitly set) the start time of the logger(s). The only impact is the output of time differences in the log lines. Hence, this method is useful to reset them and see some absolute time values when doing basic performance tests using the logger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startTime</td><td>(Optional) Optional parameter with the new start time. Defaults to DateTime.Now if omitted. </td></tr>
    <tr><td class="paramname">loggerFilter</td><td>(Optional) A filter for the loggers to be affected. A simple string compare without case sensitivity is performed. An asterisk ('*') at the beginning or end of the string is used as a wildcard. Leave nullptr if all loggers should be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8263f9417850ec3971ef21b7012279b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetStartTime </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>startTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loggerFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> This method is used reset (or to explicitly set) the start time of the logger(s). The only impact is the output of time differences in the log lines. Hence, it is useful to see some absolute time values when doing basic performance tests using the logger. </p><dl class="section note"><dt>Note</dt><dd>GLib specific.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startTime</td><td>The new start time in system specific time unit. </td></tr>
    <tr><td class="paramname">loggerFilter</td><td>(Optional) A filter for the loggers to be affected. A simple string compare without case sensitivity is performed. An asterisk ('*') at the beginning or end of the string is used as a wildcard. Leave nullptr if all loggers should be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6991342ae8c86c8799d893348578f8b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GrpALoxMacrosLowLevel.html#ga2cde43a12bd2be40baa4896e409d642c">ALOX_API</a> void SetStartTime </td>
          <td>(</td>
          <td class="paramtype">LPFILETIME&#160;</td>
          <td class="paramname"><em>startTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loggerFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> This method is used reset (or to explicitly set) the start time of the logger(s). The only impact is the output of time differences in the log lines. Hence, it is useful to see some absolute time values when doing basic performance tests using the logger. </p><dl class="section note"><dt>Note</dt><dd>Microsoft Windows specific. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startTime</td><td>The new start time in system specific time unit. </td></tr>
    <tr><td class="paramname">loggerFilter</td><td>(Optional) A filter for the loggers to be affected. A simple string compare without case sensitivity is performed. An asterisk ('*') at the beginning or end of the string is used as a wildcard. Leave nullptr if all loggers should be affected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54b4845d925cf72ef3015d8b900fe9e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool simpleWildcardFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lox_1_1core_1_1Logger.html">core::Logger</a> *&#160;</td>
          <td class="paramname"><em>logger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loggerFilter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Compares a loggers name with a filter string with simplest wildcard support ('*') at the beginning or end of the string. If loggerFilter is nullptr, a match is indicated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger</td><td>The logger to be filtered. </td></tr>
    <tr><td class="paramname">loggerFilter</td><td>The filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if logger is not filtered out. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a1bbdb35d69e51f668aed0acbc5b60d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Verbose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Verbose. This is the highest (most verbose) log level, which is only actually logged if the log domains log level is set to "All". This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab894104f3d8b9146fb806719bfcb57e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Verbose </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Verbose. This is the highest (most verbose) log level, which is only actually logged if the log domains log level is set to "All".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7bcc2a6c72d77f597fc731392fcb4c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Verbose </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Verbose. This is the highest (most verbose) log level, which is only actually logged if the log domains log level is set to "All". This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07b65ef21618836b3567f6ffed7dec49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Verbose </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Verbose. This is the highest (most verbose) log level, which is only actually logged if the log domains log level is set to "All".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5615566c8c95c8ef55526af4d69cbec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Verbose </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Verbose. This is the highest (most verbose) log level, which is only actually logged if the log domains log level is set to "All". This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a508f30a1ed4883bf8c0c3f46b7052d6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Verbose </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Verbose. This is the highest (most verbose) log level, which is only actually logged if the log domains log level is set to "All".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85f6a22706d472dab0dac046f2d2e00f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Warning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Warning. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> messages of this log level are are logged if the log domains log level is set to "Warning", "Info" or "All". This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a347632c8379b63f60c70db167264ad8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Warning </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1util_1_1AString.html">util::AString</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Warning. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> messages of this log level are are logged if the log domains log level is set to "Warning", "Info" or "All".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9574aef2b6eab33d545cdd285102edb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Warning </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Warning. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> messages of this log level are are logged if the log domains log level is set to "Warning", "Info" or "All". This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0db266ea26910ea5a060c848d7cba1d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Warning </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Warning. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> messages of this log level are are logged if the log domains log level is set to "Warning", "Info" or "All".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ebe1f98232518c4cc5e2dad2485520d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Warning </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Warning. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> messages of this log level are are logged if the log domains log level is set to "Warning", "Info" or "All". This overloaded version does not offer a domain parameter but relies on a default domain set for the source file this function is used in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa590c1fba6a794b8116fdb046662a423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Warning </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Logs a string with log level equal to Log::Level::Warning. <a class="el" href="classaworx_1_1lox_1_1Log.html">Log</a> messages of this log level are are logged if the log domains log level is set to "Warning", "Info" or "All".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>If this is nullptr, the default domain is used. If this is starting with a swung dash ('~') this is interpreted a sub domain to the default domain of the source file. For other values, the default domain is ignored (regardless if this is starting with a slash or not). </td></tr>
    <tr><td class="paramname">msg</td><td>The string to be logged. </td></tr>
    <tr><td class="paramname">indent</td><td>(Optional) The indentation in the output. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aaa96ca32f5b8d83954f9d77629c1b036"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool _apiInitializer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A utility value. Has to be first in the class. Will be initialized prior to any other field. Initializer uses insensitive. For more info see # <a class="el" href="classaworx_1_1lox_1_1Log.html#adf5526722711e47984a1b7fb93b219ce">Log::InitALox()</a> </p>

</div>
</div>
<a class="anchor" id="a3f03380b7450165d47b292ccd8ad86ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lox_1_1core_1_1CallerInfo.html">core::CallerInfo</a> callerInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Information about the source code, method, thread, etc. invoking a log call </p>

</div>
</div>
<a class="anchor" id="a2c80e5630abe5d5042ddb4b85c0c3562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CntLogCalls =0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A counter for the quantity of calls. The count includes logs that were suppressed by disabled log rootDomain and those suppressed by the optional log condition parameter. Hence, it can also be used as a condition to log only every n-th time by calling using the conditional parameter of <a class="el" href="classaworx_1_1lox_1_1Lox.html#a9bf85add41ef247d4d8f7f82c06d8e58">Line()</a>, e.g.: <em><a class="el" href="classaworx_1_1lox_1_1Lox.html#a9bf85add41ef247d4d8f7f82c06d8e58">Lox.Line</a>( (Log.qtyLogCalls % n) == 0, ...</em>. </p>

</div>
</div>
<a class="anchor" id="a501063584539f51e463034b3d496a41e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* InternalDomain =&quot;ALOX&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the log domain name used by this class. By manipulating this Domains log level, the verbosity of this interface class can be controlled. For example, in 'Info' level, calls to <a class="el" href="classaworx_1_1lox_1_1Lox.html#ac95e6fc3b2415de811381dc89fdfa0ba">RegDomain</a> and <a class="el" href="classaworx_1_1lox_1_1Lox.html#adb6bea88c046549c0ace6df70fe95784">SetDomain</a> are logged which can be helpful to determine the log domains that are created by libraries and larger projects. </p>

</div>
</div>
<a class="anchor" id="a4d2901c4588d0015fd52285741fbc312"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char Version = &quot;1.2.0&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The version of ALox. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="lox_8hpp_source.html">lox.hpp</a></li>
<li>lox.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
