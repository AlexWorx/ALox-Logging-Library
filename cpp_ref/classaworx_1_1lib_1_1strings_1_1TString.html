<!-- HTML header for doxygen 1.8.12-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ALox: TString Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1702 R. 0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--ALox Main Menu-->
<div style="background: #2f3a48; " >
<table  class="aworx-menutable"  >
 <tbody>
 <tr style="height: 36px;">
  <td> <a class="aworx-menu"    href="../index.html"                  >Home</a>                     </td>
  <td> <a class="aworx-menu_hl" href="../cpp_ref/cppmainpage.html"    >ALox for C++</a>             </td>
  <td> <a class="aworx-menu"    href="../cs_ref/csmainpage.html"      >ALox for C#</a>              </td>
  <td> <a class="aworx-menu"    href="../java_ref/javamainpage.html"  >ALox for Java</a>            </td>
  <td> <a class="aworx-menu"    href="https://github.com/AlexWorx/ALox-Logging-Library">Download</a></td>
 </tr>
 </tbody>
</table>
</div>
<!--end ALox Main Menu-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html">strings</a></li><li class="navelem"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classaworx_1_1lib_1_1strings_1_1TString-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TString Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tstring_8hpp_source.html">tstring.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TString:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1strings_1_1TString__inherit__graph.svg" width="632" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for TString:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1strings_1_1TString__coll__graph.svg" width="75" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><hr/>
<p> This class specializes class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> to represent zero terminated or more precisely zero <em>terminatable</em> strings. Zero terminated strings are especially needed when string data has to be passed to system functions. Also, some efficient algorithms (platform dependent and mostly written in assembly language) exist. Hence, various functions and methods of ALib require a const reference to an object of this type <b>TString</b> instead to an object of class <b>String</b>.</p>
<p><b>Implicit construction</b></p>
<p>This class hides its parents' constructors and re-implements the template meta programming based "all-for-one" constructor <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a77570e9a3594a1e01a53da92a5f64c40">String(const TStringLike&amp;)</a> by introducing <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aeae91b7a3d77ac5d3d4f5d29f8b49024">TString(const TTerminatable&amp;)</a>.</p>
<p>As it is not possible to implement compile time assertions for the save provision of terminatable types (without taking serious restrictions into account), this constructor performs a run time check (in debug compilations of ALib).<br />
 It is checked whether</p><ul>
<li>the string type passed is already terminated or</li>
<li>can be terminated because a) the buffer reserved capacity for the termination value and b) the buffer is writable.</li>
</ul>
<p>The second check is done only if the first did not apply and is performed using partially implemented template struct <a class="el" href="structaworx_1_1lib_1_1strings_1_1T__IsTerminatable.html">T_IsTerminatable</a>. Consult this struct for information about how to enable external (user defined) string types to be used as parameters to implicitly construct objects of this class.</p>
<dl class="section note"><dt>Note</dt><dd>While the good news is that C++ string literals, any zero terminated <em>char*</em> and objects of type <em>std::strings</em> or ALib's <b>AString</b>, are well suited to implicitly construct respectively directly serve as objects of this class, objects of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> itself and especially of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a> are not. Therefore the latter are accepted only if they are terminated already. But obviously, this is especially unlikely for objects of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a>.</dd>
<dd>
Therefore, for example to pass a <em><a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a></em> as a parameter to functions accepting only terminatable strings, it is possible to wrap them into temporary objects of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> or, if maximum size is known at compile time, of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">PreallocatedString</a>. Of-course, a performance drawback (for creating the temporary copy of the contents) has to be taken into account.</dd>
<dd>
Alternatively, class <b>Substring</b> and class <b>String</b> provide some useful implementations of slightly slower versions of some of the methods introduced this class. It has to be considered case by case which option is the best in respect to performance and memory use.</dd></dl>
<p><b>Constant Nature</b></p>
<p>Same as parent class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a>, this class is not copying the data of the provided source. It is designed preliminary to offer a fast but convenient (by implicit conversion) type for function parameters that require terminated cstring buffers. As with parent class <b>String</b>, the life-time of objects of this class is considerably short.<br />
 Only derived class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> and its different further specializations will copy the buffer and always include space for the termination character in their buffers' capacity.</p>
<p><b>Parsing Numbers</b></p>
<p>This class provides methods for parsing integer and floating point data. For implementation performance reasons, those are <em>not</em> provided by parent class <b>String</b> which does not guarantee zero terminated strings. If parsing has to be done on non-zero terminated string data, consider using a slightly slower variant of the parsing methods which are found in class <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a>.<br />
 It is rather more efficient, to instantiate a local <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a> object that just wraps an unterminated string of type <b>String</b> and use its parsing interface, than copying the unterminated data into a terminatable string variant (e.g. <b>AString</b>) and to use the interface provided herein. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">General Interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:ad01560cade1022b35a54f07183bfc50e"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ad01560cade1022b35a54f07183bfc50e">operator[]</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> op) const</td></tr>
<tr class="separator:ad01560cade1022b35a54f07183bfc50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a964fcf98f80b0368f4ebe33613b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a65a964fcf98f80b0368f4ebe33613b8b">Terminate</a> () const</td></tr>
<tr class="separator:a65a964fcf98f80b0368f4ebe33613b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Character and String Search</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a333c481b377c4f860814bebd33e8354b"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a333c481b377c4f860814bebd33e8354b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a333c481b377c4f860814bebd33e8354b">IndexOf</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a>) const</td></tr>
<tr class="separator:a333c481b377c4f860814bebd33e8354b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071d569b770ed5cc50b7e3ef0c5eb3cb"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a071d569b770ed5cc50b7e3ef0c5eb3cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a071d569b770ed5cc50b7e3ef0c5eb3cb">IndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;needles, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a217539925b78b2eed40ae7817d5bee52">lang::Inclusion</a> inclusion, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0) const</td></tr>
<tr class="separator:a071d569b770ed5cc50b7e3ef0c5eb3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:ab75164b28454722bdf29710c208f0736"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ab75164b28454722bdf29710c208f0736">operator const char *</a> ()</td></tr>
<tr class="separator:ab75164b28454722bdf29710c208f0736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9c1406b7469534fd3958468b4bf203"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a3f9c1406b7469534fd3958468b4bf203">ToCString</a> () const</td></tr>
<tr class="separator:a3f9c1406b7469534fd3958468b4bf203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb58b88013de46cb67a0a671b3f5f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a99fb58b88013de46cb67a0a671b3f5f8">ParseDecDigits</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:a99fb58b88013de46cb67a0a671b3f5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae664e83c86eed550dbbbcc2963fb5a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ae664e83c86eed550dbbbcc2963fb5a4b">ParseInt</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat=nullptr, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:ae664e83c86eed550dbbbcc2963fb5a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41b1a462da081ae4fee839cda04a7a3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ab41b1a462da081ae4fee839cda04a7a3">ParseInt</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:ab41b1a462da081ae4fee839cda04a7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a06eeb9f1360a0b05a6535befce22a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a28a06eeb9f1360a0b05a6535befce22a">ParseInt</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a28a06eeb9f1360a0b05a6535befce22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40f70946dd0e0dd6cfe16eab99641ad"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aa40f70946dd0e0dd6cfe16eab99641ad">ParseInt</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:aa40f70946dd0e0dd6cfe16eab99641ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed425b325f016e985f8af6b1e75f3372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aed425b325f016e985f8af6b1e75f3372">ParseDec</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat=nullptr, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:aed425b325f016e985f8af6b1e75f3372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9079a62a6c4cd39918639060d65a265"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ae9079a62a6c4cd39918639060d65a265">ParseDec</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:ae9079a62a6c4cd39918639060d65a265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b1e60ca537a6dac5999b997f5218d2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a93b1e60ca537a6dac5999b997f5218d2">ParseDec</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a93b1e60ca537a6dac5999b997f5218d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a273a98a915a9a61fc7995c40085de2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a5a273a98a915a9a61fc7995c40085de2">ParseDec</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a5a273a98a915a9a61fc7995c40085de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26002ab38b609f0f6bb72a5e9c47e4bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a26002ab38b609f0f6bb72a5e9c47e4bb">ParseBin</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat=nullptr, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:a26002ab38b609f0f6bb72a5e9c47e4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401f93a0285af85f441632ab13dca2a6"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a401f93a0285af85f441632ab13dca2a6">ParseBin</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:a401f93a0285af85f441632ab13dca2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69fd90f441ff55fa73e34c78b128e73"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ae69fd90f441ff55fa73e34c78b128e73">ParseBin</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:ae69fd90f441ff55fa73e34c78b128e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83dd5d8854654a2781e1595823df6f24"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a83dd5d8854654a2781e1595823df6f24">ParseBin</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a83dd5d8854654a2781e1595823df6f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed604dc124da88cbb6e0362768490eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a7ed604dc124da88cbb6e0362768490eb">ParseHex</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat=nullptr, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:a7ed604dc124da88cbb6e0362768490eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a1ffcb52070ab0702350aeffa8eb0d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ae6a1ffcb52070ab0702350aeffa8eb0d">ParseHex</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:ae6a1ffcb52070ab0702350aeffa8eb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9272a2301c548f706d207165d153bc0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ac9272a2301c548f706d207165d153bc0">ParseHex</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:ac9272a2301c548f706d207165d153bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7cbc449ac1997e1b069cf3cef5140f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#afa7cbc449ac1997e1b069cf3cef5140f">ParseHex</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:afa7cbc449ac1997e1b069cf3cef5140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea239e78c0482c3f57e432f46c799afa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aea239e78c0482c3f57e432f46c799afa">ParseOct</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat=nullptr, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:aea239e78c0482c3f57e432f46c799afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f4c8085599078cf5ef3f739e19334f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aa8f4c8085599078cf5ef3f739e19334f">ParseOct</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:aa8f4c8085599078cf5ef3f739e19334f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434944b66df7cebd59d8ae16b41dca05"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a434944b66df7cebd59d8ae16b41dca05">ParseOct</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a434944b66df7cebd59d8ae16b41dca05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8253dc78198cc4207e93b612222f0bfb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a8253dc78198cc4207e93b612222f0bfb">ParseOct</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a8253dc78198cc4207e93b612222f0bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6815a72ad886b0029a123f317cf205f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a6815a72ad886b0029a123f317cf205f8">ParseFloat</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat=nullptr, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:a6815a72ad886b0029a123f317cf205f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6ab4765504bb864f134b6457526a7a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a0c6ab4765504bb864f134b6457526a7a">ParseFloat</a> (<a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx=nullptr) const</td></tr>
<tr class="separator:a0c6ab4765504bb864f134b6457526a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c8bcafc22b07e8b40d33606970b409"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ae2c8bcafc22b07e8b40d33606970b409">ParseFloat</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:ae2c8bcafc22b07e8b40d33606970b409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3764e8f6da9a144f7e721258ea5a8152"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a3764e8f6da9a144f7e721258ea5a8152">ParseFloat</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *newIdx) const</td></tr>
<tr class="separator:a3764e8f6da9a144f7e721258ea5a8152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classaworx_1_1lib_1_1strings_1_1String')"><img src="closed.png" alt="-"/>&#160;Public Methods inherited from <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a></td></tr>
<tr class="memitem:adcffeb665e497d8c0909063e4b5df871 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adcffeb665e497d8c0909063e4b5df871">String</a> ()</td></tr>
<tr class="separator:adcffeb665e497d8c0909063e4b5df871 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1301d3ebeba443fd830a9617a15aac0b inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a1301d3ebeba443fd830a9617a15aac0b">String</a> (const char *<a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a>, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> contentLength)</td></tr>
<tr class="separator:a1301d3ebeba443fd830a9617a15aac0b inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ab988e17c0a5a6255827eee4a8028a inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#af0ab988e17c0a5a6255827eee4a8028a">String</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;src, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>)</td></tr>
<tr class="separator:af0ab988e17c0a5a6255827eee4a8028a inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77570e9a3594a1e01a53da92a5f64c40 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;typename TStringLike &gt; </td></tr>
<tr class="memitem:a77570e9a3594a1e01a53da92a5f64c40 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a77570e9a3594a1e01a53da92a5f64c40">String</a> (const TStringLike &amp;src)</td></tr>
<tr class="separator:a77570e9a3594a1e01a53da92a5f64c40 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9993430d0c6b4f328b2884216ef87a inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8e9993430d0c6b4f328b2884216ef87a">Buffer</a> () const</td></tr>
<tr class="separator:a8e9993430d0c6b4f328b2884216ef87a inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a515bdd031a8d3b713bb05edcf126c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a78a515bdd031a8d3b713bb05edcf126c">Length</a> () const</td></tr>
<tr class="separator:a78a515bdd031a8d3b713bb05edcf126c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d637a0dec45d546495c1660c9f6047 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ac4d637a0dec45d546495c1660c9f6047">IsNull</a> () const</td></tr>
<tr class="separator:ac4d637a0dec45d546495c1660c9f6047 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1975261f9100a453259d7df75ad4080d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a1975261f9100a453259d7df75ad4080d">IsNotNull</a> () const</td></tr>
<tr class="separator:a1975261f9100a453259d7df75ad4080d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e12342fc420701fbffd97025421575a inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8e12342fc420701fbffd97025421575a">IsEmpty</a> () const</td></tr>
<tr class="separator:a8e12342fc420701fbffd97025421575a inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c546c3e5ed2e243ae839807fe633140 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a6c546c3e5ed2e243ae839807fe633140">IsNotEmpty</a> () const</td></tr>
<tr class="separator:a6c546c3e5ed2e243ae839807fe633140 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7024029ef608b45471c5f31cb381f596 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a7024029ef608b45471c5f31cb381f596 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a7024029ef608b45471c5f31cb381f596">CharAt</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> idx) const</td></tr>
<tr class="separator:a7024029ef608b45471c5f31cb381f596 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b840e37d6ab8f0b56075c8de82b4152 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a4b840e37d6ab8f0b56075c8de82b4152 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a4b840e37d6ab8f0b56075c8de82b4152">CharAtStart</a> () const</td></tr>
<tr class="separator:a4b840e37d6ab8f0b56075c8de82b4152 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5adea1923df366e896af251757b3528 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:ad5adea1923df366e896af251757b3528 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ad5adea1923df366e896af251757b3528">CharAtEnd</a> () const</td></tr>
<tr class="separator:ad5adea1923df366e896af251757b3528 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227e5bdf7a6d162da1ba47c39063b417 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a227e5bdf7a6d162da1ba47c39063b417">operator[]</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> idx) const</td></tr>
<tr class="separator:a227e5bdf7a6d162da1ba47c39063b417 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8afc22664fd3e83354780b3d3dd78cd inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#af8afc22664fd3e83354780b3d3dd78cd">Equals</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a>) const</td></tr>
<tr class="separator:af8afc22664fd3e83354780b3d3dd78cd inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683512f36882cc61934216adb9a6cb4c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a683512f36882cc61934216adb9a6cb4c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a683512f36882cc61934216adb9a6cb4c">ContainsAt</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> pos, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a>) const</td></tr>
<tr class="separator:a683512f36882cc61934216adb9a6cb4c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ad515b560f370c38bcfdd4a5f47ac7 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ac4ad515b560f370c38bcfdd4a5f47ac7">StartsWith</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a>) const</td></tr>
<tr class="separator:ac4ad515b560f370c38bcfdd4a5f47ac7 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94f0e5b6be0fe047edc412b802bddc7 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ad94f0e5b6be0fe047edc412b802bddc7">EndsWith</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a>) const</td></tr>
<tr class="separator:ad94f0e5b6be0fe047edc412b802bddc7 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5e3e986cb1ce9f008fec021efab7e3 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a4c5e3e986cb1ce9f008fec021efab7e3 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a4c5e3e986cb1ce9f008fec021efab7e3">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a>) const</td></tr>
<tr class="separator:a4c5e3e986cb1ce9f008fec021efab7e3 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9db22cea88d6eb49ca79aa8a7844cc inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a6f9db22cea88d6eb49ca79aa8a7844cc inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a6f9db22cea88d6eb49ca79aa8a7844cc">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a> sensitivity, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> needleRegionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> needleRegionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>) const</td></tr>
<tr class="separator:a6f9db22cea88d6eb49ca79aa8a7844cc inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad749ee26153b5d5a977f59993fb98042 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:ad749ee26153b5d5a977f59993fb98042 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ad749ee26153b5d5a977f59993fb98042">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a> sensitivity, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> cmpRegionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> cmpRegionLength, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>) const</td></tr>
<tr class="separator:ad749ee26153b5d5a977f59993fb98042 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64e70a5dacaf96051001c5ac1ba42d4 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ab64e70a5dacaf96051001c5ac1ba42d4">operator&lt;</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const</td></tr>
<tr class="separator:ab64e70a5dacaf96051001c5ac1ba42d4 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02f8b4c5f15456011760d3690065335 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ac02f8b4c5f15456011760d3690065335">operator&gt;</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const</td></tr>
<tr class="separator:ac02f8b4c5f15456011760d3690065335 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace88722db3a272610fbc7f8fccd9e258 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ace88722db3a272610fbc7f8fccd9e258">operator==</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const</td></tr>
<tr class="separator:ace88722db3a272610fbc7f8fccd9e258 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b94d6b436e0098cf9d92ba846c02e9 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a22b94d6b436e0098cf9d92ba846c02e9">operator!=</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const</td></tr>
<tr class="separator:a22b94d6b436e0098cf9d92ba846c02e9 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7365672c3c963ba88de5612e38e704bd inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a7365672c3c963ba88de5612e38e704bd">IndexOf</a> (char needle) const</td></tr>
<tr class="separator:a7365672c3c963ba88de5612e38e704bd inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcbc607a7c87baa70f6c2c739f3c218 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a6bcbc607a7c87baa70f6c2c739f3c218 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a6bcbc607a7c87baa70f6c2c739f3c218">IndexOf</a> (char needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionStart) const</td></tr>
<tr class="separator:a6bcbc607a7c87baa70f6c2c739f3c218 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacc41ba7e94890340a82233f2538ecc inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:abacc41ba7e94890340a82233f2538ecc inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#abacc41ba7e94890340a82233f2538ecc">IndexOf</a> (char needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionLength) const</td></tr>
<tr class="separator:abacc41ba7e94890340a82233f2538ecc inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb8c82267bbb72239c9d6559cdfbf24 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a8bb8c82267bbb72239c9d6559cdfbf24 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8bb8c82267bbb72239c9d6559cdfbf24">LastIndexOf</a> (char needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIndex=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>) const</td></tr>
<tr class="separator:a8bb8c82267bbb72239c9d6559cdfbf24 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312ecf30301f4228a167052b58895ef5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a312ecf30301f4228a167052b58895ef5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a312ecf30301f4228a167052b58895ef5">IndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needles, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a217539925b78b2eed40ae7817d5bee52">lang::Inclusion</a> inclusion, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0) const</td></tr>
<tr class="separator:a312ecf30301f4228a167052b58895ef5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73db69a072ace024e768ac4f3bbd0630 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a73db69a072ace024e768ac4f3bbd0630 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a73db69a072ace024e768ac4f3bbd0630">LastIndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needles, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a217539925b78b2eed40ae7817d5bee52">lang::Inclusion</a> inclusion, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>) const</td></tr>
<tr class="separator:a73db69a072ace024e768ac4f3bbd0630 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2db8c097f2e27a96c64807c8d0edc4 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a0b2db8c097f2e27a96c64807c8d0edc4 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a0b2db8c097f2e27a96c64807c8d0edc4">IndexOfSubstring</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> startIdx=0, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a>) const</td></tr>
<tr class="separator:a0b2db8c097f2e27a96c64807c8d0edc4 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38812ea513734bb82f5eba9a87eedc3 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:aa38812ea513734bb82f5eba9a87eedc3 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa38812ea513734bb82f5eba9a87eedc3">IndexOfFirstDifference</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a>, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> idx=0) const</td></tr>
<tr class="separator:aa38812ea513734bb82f5eba9a87eedc3 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e160a8b59fc366a756f4b9e5aba7b2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ac3e160a8b59fc366a756f4b9e5aba7b2">CopyTo</a> (char *dest) const</td></tr>
<tr class="separator:ac3e160a8b59fc366a756f4b9e5aba7b2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73778966100cb79516a66cc79c3b711 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ae73778966100cb79516a66cc79c3b711">ToWString</a> (wchar_t *dest, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> destCapacity, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionStart=0, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a854222d062dd7b383aff419dac1b8481">CString::MaxLen</a>) const</td></tr>
<tr class="separator:ae73778966100cb79516a66cc79c3b711 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbca75c8d760ba66c441e9f67273a7f inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#abbbca75c8d760ba66c441e9f67273a7f">AdjustRegion</a> (<a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> &amp;regionStart, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> &amp;regionLength) const</td></tr>
<tr class="separator:abbbca75c8d760ba66c441e9f67273a7f inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Debug methods</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp55cbe8a442f26d567741a00b4fa5a1b0"></a></p><h6></h6>
<h2></h2>
</td></tr>
<tr class="memitem:ac3615a067cb671e6b0cac6dbb26c9f3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ac3615a067cb671e6b0cac6dbb26c9f3e">debugIsTerminated</a> =-1</td></tr>
<tr class="separator:ac3615a067cb671e6b0cac6dbb26c9f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7019ebc20c4e90566cc1f4235f0beec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a7019ebc20c4e90566cc1f4235f0beec5">_dbgCheck</a> () const</td></tr>
<tr class="separator:a7019ebc20c4e90566cc1f4235f0beec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constructor and Assignment</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd5ad566e0137ca24d0b82ada328a64b3"></a></p><h6></h6>
<h2></h2>
</td></tr>
<tr class="memitem:ad751e8adb9aa217a042c45e1c0585285"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ad751e8adb9aa217a042c45e1c0585285">TString</a> ()</td></tr>
<tr class="separator:ad751e8adb9aa217a042c45e1c0585285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae91b7a3d77ac5d3d4f5d29f8b49024"><td class="memTemplParams" colspan="2">template&lt;typename TTerminatable &gt; </td></tr>
<tr class="memitem:aeae91b7a3d77ac5d3d4f5d29f8b49024"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aeae91b7a3d77ac5d3d4f5d29f8b49024">TString</a> (const TTerminatable &amp;src)</td></tr>
<tr class="separator:aeae91b7a3d77ac5d3d4f5d29f8b49024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96a578d58f81bda010ae0c0a06e696c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ad96a578d58f81bda010ae0c0a06e696c">TString</a> (const char *<a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a>, <a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> contentLength)</td></tr>
<tr class="separator:ad96a578d58f81bda010ae0c0a06e696c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classaworx_1_1lib_1_1strings_1_1String')"><img src="closed.png" alt="-"/>&#160;Protected Fields inherited from <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a></td></tr>
<tr class="memitem:adae84acc92cd77a04f6aaf533643a33a inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a></td></tr>
<tr class="separator:adae84acc92cd77a04f6aaf533643a33a inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af940c51e198511031f839dec6e7f1b71 inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#af940c51e198511031f839dec6e7f1b71">length</a></td></tr>
<tr class="separator:af940c51e198511031f839dec6e7f1b71 inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab060ffba71bd8a3d7067a38950b39a82 inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ab060ffba71bd8a3d7067a38950b39a82">vbuffer</a></td></tr>
<tr class="separator:ab060ffba71bd8a3d7067a38950b39a82 inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad96a578d58f81bda010ae0c0a06e696c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96a578d58f81bda010ae0c0a06e696c">&sect;&nbsp;</a></span>TString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>contentLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructs this object using the given external buffer and length of content.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is protected to avoid the creation of objects with non-terminatable types.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to use. </td></tr>
    <tr><td class="paramname">contentLength</td><td>The length of the content in the given buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad751e8adb9aa217a042c45e1c0585285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad751e8adb9aa217a042c45e1c0585285">&sect;&nbsp;</a></span>TString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Default constructor creating a <em>nulled</em> <b>TString</b>. </p>

</div>
</div>
<a id="aeae91b7a3d77ac5d3d4f5d29f8b49024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae91b7a3d77ac5d3d4f5d29f8b49024">&sect;&nbsp;</a></span>TString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> </td>
          <td>(</td>
          <td class="paramtype">const TTerminatable &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This constructor overloads the powerful templated constructor <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a77570e9a3594a1e01a53da92a5f64c40">String::String(const TStringLike&amp;)</a>. In addition to invoking that, it is asserted that the given value is terminated or type <code>TTerminatable</code> is terminatable. For more information see this classes' general description.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The string to represent by this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7019ebc20c4e90566cc1f4235f0beec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7019ebc20c4e90566cc1f4235f0beec5">&sect;&nbsp;</a></span>_dbgCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _dbgCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Validates this instance. This method is available only if <a class="el" href="group__GrpALibCodeSelectorSymbols.html#gae0e4a87e11482df5ecd72f6a2a648f05">ALIB_DEBUG_STRINGS</a> is <code>true</code>. Invocations to this method should be performed using macro <a class="el" href="group__GrpALibStringsMacros.html#gae7492253da37c76b118d446494f1f632">ALIB_STRING_DBG_CHK</a>. </p>

</div>
</div>
<a id="a333c481b377c4f860814bebd33e8354b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333c481b377c4f860814bebd33e8354b">&sect;&nbsp;</a></span>IndexOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17">lang::Case</a>&#160;</td>
          <td class="paramname"><em>sensitivity</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">lang::Case::Sensitive</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Search the given terminatable string in this object.</p>
<dl class="section note"><dt>Note</dt><dd>Parameter <code>needle</code> is required to be terminated or terminatable, the same as this object is. For non-terminatable string types (e.g. those of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a>), a less performant implementation of this method is available through class <b>String</b> with: <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a7365672c3c963ba88de5612e38e704bd">IndexOf</a>.<br />
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is added to the method name, no parameter checks are performed and the needle must not be empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> to search for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramname">sensitivity</td><td>Case sensitivity of the comparison. Optional and defaults to Case::Sensitive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the string is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a id="a071d569b770ed5cc50b7e3ef0c5eb3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071d569b770ed5cc50b7e3ef0c5eb3cb">&sect;&nbsp;</a></span>IndexOfAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> IndexOfAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;&#160;</td>
          <td class="paramname"><em>needles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1lang.html#a217539925b78b2eed40ae7817d5bee52">lang::Inclusion</a>&#160;</td>
          <td class="paramname"><em>inclusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the index of the first character which is included, respectively <em>not</em> included in a given set of characters.</p>
<p>This method searches forwards. For backwards search, see <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a73db69a072ace024e768ac4f3bbd0630">String::LastIndexOfAny</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method reimplements method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a7365672c3c963ba88de5612e38e704bd">String::IndexOf</a> of parent class. This implementation however needs (beside the fact that this is a zero terminatable) a zero-terminatable string for the needles. If no zero-terminatable needles are available, parent method accepting non-zero terminated needles needs to be invoked. This is possible, for example by writing e.g. <em>mystring.String::IndexOf()</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is added to the method name, no parameter checks are performed and the needles must not be empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needles</td><td>Pointer to a zero terminated set of characters to be taken into account. </td></tr>
    <tr><td class="paramname">inclusion</td><td>Denotes whether the search returns the first index that holds a value that is included or that is not excluded in the set of needle characters. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. If the given value is less than 0, it is set to 0. If it exceeds the length of the string, the length of the string is returned. Defaults to 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character found which is included, respectively not included, in the given set of characters. If nothing is found, -1 is returned. </dd></dl>

</div>
</div>
<a id="ab75164b28454722bdf29710c208f0736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75164b28454722bdf29710c208f0736">&sect;&nbsp;</a></span>operator const char *()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operator const char * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Cast operator to <em>const char*</em>. Invokes and returns result of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a3f9c1406b7469534fd3958468b4bf203">ToCString</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Casting an instance with <em>(const char*)</em> is the same as invoking method <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a3f9c1406b7469534fd3958468b4bf203">ToCString</a> on that instance. The operator is provided as an alias and it is a matter of taste which of them to use. </dd>
<dd>
This operator is marked explicit. Although implicit conversion would be quite convenient, the need for adding the cast explicitly should be helpful in understanding the structure of the code and leads to more predictable compiler warnings and invocations of overloaded methods. </dd></dl>

</div>
</div>
<a id="ad01560cade1022b35a54f07183bfc50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01560cade1022b35a54f07183bfc50e">&sect;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Reads a character at a given index.<br />
 Overrides <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a227e5bdf7a6d162da1ba47c39063b417">String::operator[]</a> to change the debug assertion to allow inclusion of the termination character.</p>
<dl class="section attention"><dt>Attention</dt><dd>No parameter check is performed (other than an assertions in debug-compilation of ALib). See <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a227e5bdf7a6d162da1ba47c39063b417">String::operator[]</a> for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The index of the character within this objects' buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the character contained at index <code>op</code>. </dd></dl>

</div>
</div>
<a id="a26002ab38b609f0f6bb72a5e9c47e4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26002ab38b609f0f6bb72a5e9c47e4bb">&sect;&nbsp;</a></span>ParseBin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseBin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads an unsigned 64-bit integer in binary format at the given position from this <b>AString</b>. This is done, by invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#a8e59c1e4538a1b671bbb00a67ee6c69c">NumberFormat::ParseBin</a> on the given <code>numberFormat</code> instance.<br />
 Parameter <code>numberFormat</code> defaults to <code>nullptr</code>. This denotes static singleton <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#acf46ddfeb324ad3027ecf50f6f48e149">NumberFormat::Computational</a> which is configured to not using - and therefore also not parsing - grouping characters.</p>
<p>Optional output parameter <code>newIdx</code> may be used to detect if parsing was successful. If not, it receives the value of <code>startIdx</code>, even if leading whitespaces had been read.</p>
<p>For more information on number conversion, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a>. All of its interface methods have a corresponding implementation within class <b>AString</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>startIdx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a401f93a0285af85f441632ab13dca2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401f93a0285af85f441632ab13dca2a6">&sect;&nbsp;</a></span>ParseBin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseBin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a26002ab38b609f0f6bb72a5e9c47e4bb">ParseBin</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ae69fd90f441ff55fa73e34c78b128e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69fd90f441ff55fa73e34c78b128e73">&sect;&nbsp;</a></span>ParseBin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseBin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a26002ab38b609f0f6bb72a5e9c47e4bb">ParseBin</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a83dd5d8854654a2781e1595823df6f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83dd5d8854654a2781e1595823df6f24">&sect;&nbsp;</a></span>ParseBin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseBin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a26002ab38b609f0f6bb72a5e9c47e4bb">ParseBin</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>startIdx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="aed425b325f016e985f8af6b1e75f3372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed425b325f016e985f8af6b1e75f3372">&sect;&nbsp;</a></span>ParseDec() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseDec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads an unsigned 64-bit integer in standard decimal format at the given position from this AString. This is done, by invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#afc38a5eee53f6649d43fa1e0d53108ca">NumberFormat::ParseDec</a> on the given <code>numberFormat</code> instance.<br />
 Parameter <code>numberFormat</code> defaults to <code>nullptr</code>. This denotes static singleton <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#acf46ddfeb324ad3027ecf50f6f48e149">NumberFormat::Computational</a> which is configured to not using - and therefore also not parsing - grouping characters.</p>
<p>Optional output parameter <code>newIdx</code> may be used to detect if parsing was successful. If not, it receives the value of <code>startIdx</code>, even if leading whitespaces had been read.</p>
<p>Sign literals <code>'-'</code> or <code>'+'</code> are <b>not</b> accepted and parsing will fail. For reading signed integer values, see methods <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ae664e83c86eed550dbbbcc2963fb5a4b">ParseInt</a>, for floating point numbers <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a6815a72ad886b0029a123f317cf205f8">ParseFloat</a>.</p>
<p>For more information on number conversion, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a>. All of its interface methods have a corresponding implementation within class <b>AString</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>startIdx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ae9079a62a6c4cd39918639060d65a265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9079a62a6c4cd39918639060d65a265">&sect;&nbsp;</a></span>ParseDec() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseDec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aed425b325f016e985f8af6b1e75f3372">ParseDec</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a93b1e60ca537a6dac5999b997f5218d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b1e60ca537a6dac5999b997f5218d2">&sect;&nbsp;</a></span>ParseDec() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseDec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aed425b325f016e985f8af6b1e75f3372">ParseDec</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a5a273a98a915a9a61fc7995c40085de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a273a98a915a9a61fc7995c40085de2">&sect;&nbsp;</a></span>ParseDec() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseDec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aed425b325f016e985f8af6b1e75f3372">ParseDec</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>startIdx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a99fb58b88013de46cb67a0a671b3f5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fb58b88013de46cb67a0a671b3f5f8">&sect;&nbsp;</a></span>ParseDecDigits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NO_DOX uint64_t ParseDecDigits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Parses an integer value consisting of characters <code>'0'</code> to <code>'9'</code> from this string. <br />
Unlike with <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ae664e83c86eed550dbbbcc2963fb5a4b">ParseInt</a> or <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aed425b325f016e985f8af6b1e75f3372">ParseDec</a>, no sign, whitespaces or group characters are accepted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index from where the integer value is tried to be parsed. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the float number that was parsed. If parsing fails, it will be set to the value of parameter startIdx. Therefore, this parameter can be used to check if a value was found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the parameter <code>newIdx</code> is set to point to the first character behind any found integer number. </dd></dl>

</div>
</div>
<a id="a6815a72ad886b0029a123f317cf205f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6815a72ad886b0029a123f317cf205f8">&sect;&nbsp;</a></span>ParseFloat() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ParseFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads a floating point number at the given position from this <b>AString</b>. This is done, by invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#a6be15202eae48c8e0b2e4bbef2ea6783">NumberFormat::ParseFloat</a> on the given <code>numberFormat</code> instance.<br />
 Parameter <code>numberFormat</code> defaults to <code>nullptr</code>. This denotes static singleton <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#acf46ddfeb324ad3027ecf50f6f48e149">NumberFormat::Computational</a> which is configured to 'international' settings (not using the locale) and therefore also not parsing grouping characters.</p>
<p>Optional output parameter <code>newIdx</code> may be used to detect if parsing was successful. If not, it receives the value of <code>startIdx</code>, even if leading whitespaces had been read.</p>
<p>For more information on parsing options for floating point numbers and number conversion in general, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a>. All of its interface methods have a corresponding implementation within class <b>AString</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>startIdx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a0c6ab4765504bb864f134b6457526a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6ab4765504bb864f134b6457526a7a">&sect;&nbsp;</a></span>ParseFloat() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ParseFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a6815a72ad886b0029a123f317cf205f8">ParseFloat</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ae2c8bcafc22b07e8b40d33606970b409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c8bcafc22b07e8b40d33606970b409">&sect;&nbsp;</a></span>ParseFloat() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ParseFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a6815a72ad886b0029a123f317cf205f8">ParseFloat</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a3764e8f6da9a144f7e721258ea5a8152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3764e8f6da9a144f7e721258ea5a8152">&sect;&nbsp;</a></span>ParseFloat() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ParseFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a6815a72ad886b0029a123f317cf205f8">ParseFloat</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>startIdx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a7ed604dc124da88cbb6e0362768490eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed604dc124da88cbb6e0362768490eb">&sect;&nbsp;</a></span>ParseHex() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseHex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads an unsigned 64-bit integer in hexadecimal format at the given position from this <b>AString</b>. This is done, by invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#a1ac7780cc55cd76894e0abc8e111e996">NumberFormat::ParseHex</a> on the given <code>numberFormat</code> instance.<br />
 Parameter <code>numberFormat</code> defaults to <code>nullptr</code>. This denotes static singleton <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#acf46ddfeb324ad3027ecf50f6f48e149">NumberFormat::Computational</a> which is configured to not using - and therefore also not parsing - grouping characters.</p>
<p>Optional output parameter <code>newIdx</code> may be used to detect if parsing was successful. If not, it receives the value of <code>startIdx</code>, even if leading whitespaces had been read.</p>
<p>For more information on number conversion, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a>. All of its interface methods have a corresponding implementation within class <b>AString</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>startIdx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ae6a1ffcb52070ab0702350aeffa8eb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a1ffcb52070ab0702350aeffa8eb0d">&sect;&nbsp;</a></span>ParseHex() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseHex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a7ed604dc124da88cbb6e0362768490eb">ParseHex</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ac9272a2301c548f706d207165d153bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9272a2301c548f706d207165d153bc0">&sect;&nbsp;</a></span>ParseHex() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseHex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a7ed604dc124da88cbb6e0362768490eb">ParseHex</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="afa7cbc449ac1997e1b069cf3cef5140f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7cbc449ac1997e1b069cf3cef5140f">&sect;&nbsp;</a></span>ParseHex() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseHex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a7ed604dc124da88cbb6e0362768490eb">ParseHex</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>startIdx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ae664e83c86eed550dbbbcc2963fb5a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae664e83c86eed550dbbbcc2963fb5a4b">&sect;&nbsp;</a></span>ParseInt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ParseInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Parses an integer value in decimal, binary, hexadecimal or octal format from the string by invoking method <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#acbc2577785db35d2351c36a4f3c2ff2a">NumberFormat::ParseInt</a> on the given <code>numberFormat</code> instance.<br />
 Parameter <code>numberFormat</code> defaults to <code>nullptr</code>. This denotes static singleton <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#acf46ddfeb324ad3027ecf50f6f48e149">NumberFormat::Computational</a> which is configured to not using - and therefore also not parsing - grouping characters.</p>
<p>Optional output parameter <code>newIdx</code> may be used to detect if parsing was successful. If not, it receives the value of <code>startIdx</code>, even if leading whitespaces had been read.</p>
<p>For more information on number conversion, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a>. All of its interface methods have a corresponding implementation within class <b>AString</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>startIdx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="ab41b1a462da081ae4fee839cda04a7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41b1a462da081ae4fee839cda04a7a3">&sect;&nbsp;</a></span>ParseInt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ParseInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ae664e83c86eed550dbbbcc2963fb5a4b">ParseInt</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a28a06eeb9f1360a0b05a6535befce22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a06eeb9f1360a0b05a6535befce22a">&sect;&nbsp;</a></span>ParseInt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ParseInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ae664e83c86eed550dbbbcc2963fb5a4b">ParseInt</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="aa40f70946dd0e0dd6cfe16eab99641ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40f70946dd0e0dd6cfe16eab99641ad">&sect;&nbsp;</a></span>ParseInt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ParseInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ae664e83c86eed550dbbbcc2963fb5a4b">ParseInt</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>startIdx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="aea239e78c0482c3f57e432f46c799afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea239e78c0482c3f57e432f46c799afa">&sect;&nbsp;</a></span>ParseOct() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseOct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads an unsigned 64-bit integer in octal format at the given position from this <b>AString</b>. This is done, by invoking <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#a6a3d711103554f1eca89df777400b71b">NumberFormat::ParseOct</a> on the given <code>numberFormat</code> instance.<br />
 Parameter <code>numberFormat</code> defaults to <code>nullptr</code>. This denotes static singleton <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#acf46ddfeb324ad3027ecf50f6f48e149">NumberFormat::Computational</a> which is configured to not using - and therefore also not parsing - grouping characters.</p>
<p>Optional output parameter <code>newIdx</code> may be used to detect if parsing was successful. If not, it receives the value of <code>startIdx</code>, even if leading whitespaces had been read.</p>
<p>For more information on number conversion, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a>. All of its interface methods have a corresponding implementation within class <b>AString</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>startIdx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="aa8f4c8085599078cf5ef3f739e19334f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f4c8085599078cf5ef3f739e19334f">&sect;&nbsp;</a></span>ParseOct() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseOct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aea239e78c0482c3f57e432f46c799afa">ParseOct</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The format definition. Defaults to <code>nullptr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a434944b66df7cebd59d8ae16b41dca05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434944b66df7cebd59d8ae16b41dca05">&sect;&nbsp;</a></span>ParseOct() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseOct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aea239e78c0482c3f57e432f46c799afa">ParseOct</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a8253dc78198cc4207e93b612222f0bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8253dc78198cc4207e93b612222f0bfb">&sect;&nbsp;</a></span>ParseOct() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ParseOct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a>&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx.html#a2597f1982b18ebe4ea9e55b914bc49b4">integer</a> *&#160;</td>
          <td class="paramname"><em>newIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Overloaded version of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aea239e78c0482c3f57e432f46c799afa">ParseOct</a>(int =,NumberFormat* =,int* =) providing default values for omitted parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index for parsing. Optional and defaults to <code>0</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the number parsed. On failure, it will be set to the initial value <code>startIdx</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <b>newIdx</b> is set to point to the first character behind the parsed number. </dd></dl>

</div>
</div>
<a id="a65a964fcf98f80b0368f4ebe33613b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a964fcf98f80b0368f4ebe33613b8b">&sect;&nbsp;</a></span>Terminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Terminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Checks if this objects' buffer is terminated and - if not - terminates it by writing '\0' into the first character of the buffer after the represented string (precisely into <em>buffer[ length ]</em>).</p>
<dl class="section note"><dt>Note</dt><dd>When compiler symbol <a class="el" href="group__GrpALibCodeSelectorSymbols.html#gae0e4a87e11482df5ecd72f6a2a648f05">ALIB_DEBUG_STRINGS</a> is <code>true</code>, the state of debug field <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ac3615a067cb671e6b0cac6dbb26c9f3e">debugIsTerminated</a> gets set to '1'.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a3f9c1406b7469534fd3958468b4bf203">ToCString</a>, <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ab75164b28454722bdf29710c208f0736">operator const char*()</a>. </dd></dl>

</div>
</div>
<a id="a3f9c1406b7469534fd3958468b4bf203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9c1406b7469534fd3958468b4bf203">&sect;&nbsp;</a></span>ToCString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* ToCString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This instances' buffer will be terminated (if not already) and returned. If this object is <em>nulled</em>, a pointer to an empty cstring is returned. This allows to omit explicit checks for <em>nulled</em> objects, in the frequent case that no difference should be made in the processing of a <em>nulled</em> or a not <em>nulled</em>, but empty object.</p>
<dl class="section note"><dt>Note</dt><dd>If used within loops, it is advisable to use a combination of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a65a964fcf98f80b0368f4ebe33613b8b">Terminate</a> (before the loop) and <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8e9993430d0c6b4f328b2884216ef87a">Buffer</a> (inside the loop) to avoid the overhead for a repeated termination check.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The internal, now zero terminated buffer. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac3615a067cb671e6b0cac6dbb26c9f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3615a067cb671e6b0cac6dbb26c9f3e">&sect;&nbsp;</a></span>debugIsTerminated</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int debugIsTerminated =-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This field serves for debugging the development (and potentially the use) of derived classes, eg. class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>. It is available only when compiler symbol <a class="el" href="group__GrpALibCodeSelectorSymbols.html#gae0e4a87e11482df5ecd72f6a2a648f05">ALIB_DEBUG_STRINGS</a> is <code>true</code>. When active, whenever the contents of an <b>AString</b> instance is modified, the buffer is explicitly "unterminated" by writing a value of '\1' at the termination position and the state is stored in this field .<br />
 To keep the constructor <em>constexpr</em>, it is -1 (undetermined) after construction. </p><dl class="section see"><dt>See also</dt><dd>Macro <a class="el" href="group__GrpALibStringsMacros.html#gacf96023d903e78f3b5d784a799041667">ALIB_STRING_DBG_UNTERMINATE</a> and method <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a65a964fcf98f80b0368f4ebe33613b8b">Terminate</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="tstring_8hpp_source.html">tstring.hpp</a></li>
<li>tstring.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.12-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 6 2017 09:12:50 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
<!-- Start of StatCounter Code e -->
<script type="text/javascript">
var sc_project=11242602;
var sc_invisible=1;
var sc_security="5ac13373";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="web statistics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11242602/0/5ac13373/1/" alt="web
statistics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</body>
</html>
