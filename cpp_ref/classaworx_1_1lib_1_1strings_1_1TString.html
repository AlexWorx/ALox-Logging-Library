<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ALox: TString Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!-- so strange, that doxgen does not highlight each menu item. Just some... -->
<script>
  $(document).ready(function() {     
    fnameStart= window.location.href.lastIndexOf('/')
    fnameEnd=   window.location.href.indexOf('_', fnameStart )
    if( fnameEnd < 0 ) {
        fnameEnd=   window.location.href.indexOf('.', fnameStart )
    }
    if( fnameEnd > -1 ) {
        subString= window.location.href.substring( fnameStart, fnameEnd )
        $('li').toArray().forEach(function(li){
            if(     typeof li.firstChild.href != 'undefined'
                &&  li.firstChild.href.indexOf(subString) > 0 
                ){
               li.classList.add('current');
            }
        });
    }
  });
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="aworx_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="A-Worx-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALox
   &#160;<span id="projectnumber">V. 1602 R. 1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../index.html"><span>ALox&#160;Home</span></a></li>
      <li><a href="../faq.html"><span>FAQ</span></a></li>
      <li><a href="../manual.html"><span>Manual</span></a></li>
      <li class="current"><a href="cppmainpage.html"><span>ALox&#160;for&#160;C++</span></a></li>
      <li><a href="../cs_ref/csmainpage.html"><span>ALox&#160;for&#160;C#</span></a></li>
      <li><a href="../java_ref/javamainpage.html"><span>ALox&#160;for&#160;Java</span></a></li>
      <li><a href="../tools.html"><span>Tools</span></a></li>
      <li><a href="https://github.com/AlexWorx/ALox-Logging-Library"><span>Download</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="cppmainpage.html"><span>Overview</span></a></li>
      <li><a href="cpptutorial.html"><span>Tutorial</span></a></li>
      <li><a href="cppsetup.html"><span>IDE/Build&#160;system&#160;setup</span></a></li>
      <li><a href="cppprepro.html"><span>ALox&#160;Preprocessor&#160;Symbols</span></a></li>
      <li class="current"><a href="annotated.html"><span>Class&#160;Reference</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="classes.html"><span>Alphabetical&#160;Index</span></a></li>
      <li><a href="annotated.html"><span>Namespace&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceaworx.html">aworx</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespaceaworx_1_1lib_1_1strings.html">strings</a></li><li class="navelem"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classaworx_1_1lib_1_1strings_1_1TString-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TString Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tstring_8hpp_source.html">tstring.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TString:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1strings_1_1TString__inherit__graph.svg" width="566" height="96"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for TString:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classaworx_1_1lib_1_1strings_1_1TString__coll__graph.svg" width="75" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Class Description</h2>
<div class="textblock"><hr/>
<p> This class specializes class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> to represent zero terminated or more precisely zero <em>terminatable</em> strings. Zero terminated strings are especially needed when string data has to be passed to system functions. Also, some efficient algorithms (platform dependent and mostly written in assembly language) exist. Hence, various functions and methods of ALib require a const reference to an object of this type <b>TString</b> instead to an object of class <b>String</b>.</p>
<p><b>Implicit construction</b></p>
<p>This class hides its parents' constructors and re-implements the template meta programming based "all-for-one" constructor <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a2b1f593a0b9b71d210993cea0727b419">String(const T&amp;)</a> by introducing <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#abe0c3a5e03ba9a10bd9b19a22a261499">TString(const T&amp;)</a>.</p>
<p>As it is not possible to implement compile time assertions for the save provision of terminatable types (without taking serious restrictions into account), this constructor performs a run time check (in debug compilations of ALib).<br />
 It is checked whether</p><ul>
<li>the string type passed is already terminated or</li>
<li>can be terminated because a) the buffer reserved capacity for the termination value and b) the buffer is writable.</li>
</ul>
<p>The second check is done only if the first did not apply and is performed using partially implemented template struct <a class="el" href="structaworx_1_1lib_1_1strings_1_1IsTerminatable.html">ISTerminatable</a>. Consult this struct for information about how to enable external (user defined) string types to be used as parameters to implicitly construct objects of this class.</p>
<dl class="section note"><dt>Note</dt><dd>While the good news is that C++ string literals, any zero terminated <em>char*</em> and objects of type <em>std::strings</em> or ALib's <b>AString</b>, are well suited to implicitly construct respectively directly serve as objects of this class, objects of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> itself and espcially of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a> are not. Therefore the latter are accepted only if they are terminated already. But obviously, this is especially unlikely for objects of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a>.</dd>
<dd>
Therefore, for example to pass a <em><a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a></em> as a parameter to functions accepting only terminatable strings, it is possible to wrap them into temporary objects of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> or, if maximum size is known at compile time, of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1PreallocatedString.html">PreallocatedString</a>. Of-course, a performance drawback (for creating the temporary copy of the contents) has to be taken into account.</dd>
<dd>
Alternatively, class <b>Substring</b> and class <b>String</b> provide some useful implementations of slightly slower versions of some of the methods introduced this class. It has to be considered case by case which option is the best in respect to performance and memory use.</dd></dl>
<p><b>Constant Nature</b></p>
<p>Same as parent class <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a>, this class is not copying the data of the provided source. It is designed preliminary to offer a fast but convenient (by implicit conversion) type for function parameters that require terminated cstring buffers. As with parent class <b>String</b>, the life-time of objects of this class is considerably short.<br />
 Only derived class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a> and its different further specializations will copy the buffer and always include space for the termination character in their buffers' capacity.</p>
<p><b>Parsing Numbers</b></p>
<p>This class provides methods for parsing integer and floating point data. For implementation performance reasons, those are <em>not</em> provided by parent class <b>String</b> which does not guarantee zero terminated strings. If parsing has to be done on non-zero terminated string data, consider using a slightly slower variant of the parsing methods which are found in class <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a>.<br />
 It is rather more efficient, to instantiate a local <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a> object that just wraps an unterminated string of type <b>String</b> and use its parsing interface, than copying the unterminated data into a terminatable string variant (e.g. <b>AString</b>) and to use the interface provided herein. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">General Interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a0b3b9871d2fc6522c1f2aedf67b8b1c2"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a0b3b9871d2fc6522c1f2aedf67b8b1c2">operator[]</a> (int op) const </td></tr>
<tr class="separator:a0b3b9871d2fc6522c1f2aedf67b8b1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1430f618f869550a47b5f078ce6860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a7a1430f618f869550a47b5f078ce6860">Terminate</a> () const </td></tr>
<tr class="separator:a7a1430f618f869550a47b5f078ce6860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Character and String Search</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:a57423bbca362af5c912ea619d9a14746"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a57423bbca362af5c912ea619d9a14746"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a57423bbca362af5c912ea619d9a14746">IndexOf</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;needle, int startIdx=0, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:a57423bbca362af5c912ea619d9a14746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77001b79e815a22ce126e3df14f591b2"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a77001b79e815a22ce126e3df14f591b2"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a77001b79e815a22ce126e3df14f591b2">IndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;needles, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a217539925b78b2eed40ae7817d5bee52">enums::Inclusion</a> inclusion, int startIdx=0) const </td></tr>
<tr class="separator:a77001b79e815a22ce126e3df14f591b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion</div></td></tr>
<tr><td colspan="2"><div class="groupText"><h6></h6>
<h2></h2>
</div></td></tr>
<tr class="memitem:ab75164b28454722bdf29710c208f0736"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ab75164b28454722bdf29710c208f0736">operator const char *</a> ()</td></tr>
<tr class="separator:ab75164b28454722bdf29710c208f0736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af283db5a533654cb8a0fa2e110d4b20f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#af283db5a533654cb8a0fa2e110d4b20f">ToCString</a> () const </td></tr>
<tr class="separator:af283db5a533654cb8a0fa2e110d4b20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2efe140bd7fe9300fa64c27c7adab08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#af2efe140bd7fe9300fa64c27c7adab08">ToLong</a> (int startIdx=0, int *newIdx=nullptr, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> *whitespaces=nullptr) const </td></tr>
<tr class="separator:af2efe140bd7fe9300fa64c27c7adab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0318c4e2b29a58be56c9f8645184448d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a0318c4e2b29a58be56c9f8645184448d">ToInt</a> (int startIdx=0, int *newIdx=nullptr, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> *whitespaces=nullptr) const </td></tr>
<tr class="separator:a0318c4e2b29a58be56c9f8645184448d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefab2dff23cb4a711c8efdd73e85c15e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#aefab2dff23cb4a711c8efdd73e85c15e">ToFloat</a> (int startIdx=0, int *newIdx=nullptr, <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *numberFormat=nullptr, const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> *whitespaces=nullptr) const </td></tr>
<tr class="separator:aefab2dff23cb4a711c8efdd73e85c15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classaworx_1_1lib_1_1strings_1_1String')"><img src="closed.png" alt="-"/>&#160;Public Methods inherited from <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a></td></tr>
<tr class="memitem:adcffeb665e497d8c0909063e4b5df871 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adcffeb665e497d8c0909063e4b5df871">String</a> ()</td></tr>
<tr class="separator:adcffeb665e497d8c0909063e4b5df871 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863a723eb56ea0b5fab9a838c5f27658 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a863a723eb56ea0b5fab9a838c5f27658">String</a> (const char *<a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a>, int contentLength)</td></tr>
<tr class="separator:a863a723eb56ea0b5fab9a838c5f27658 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bdef100f3c7887fd120a7a98d8062c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a79bdef100f3c7887fd120a7a98d8062c">String</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;src, int regionStart, int regionLength)</td></tr>
<tr class="separator:a79bdef100f3c7887fd120a7a98d8062c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1f593a0b9b71d210993cea0727b419 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b1f593a0b9b71d210993cea0727b419 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a2b1f593a0b9b71d210993cea0727b419">String</a> (const T &amp;src)</td></tr>
<tr class="separator:a2b1f593a0b9b71d210993cea0727b419 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5ce30daece7ec96d0b70ccc5d46002 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a5d5ce30daece7ec96d0b70ccc5d46002">Buffer</a> () const </td></tr>
<tr class="separator:a5d5ce30daece7ec96d0b70ccc5d46002 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e891964a37680c01e21dedac6ffe670 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a6e891964a37680c01e21dedac6ffe670">Length</a> () const </td></tr>
<tr class="separator:a6e891964a37680c01e21dedac6ffe670 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055d87b78f69c9d039b7e12ead7aa6b6 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a055d87b78f69c9d039b7e12ead7aa6b6">IsNull</a> () const </td></tr>
<tr class="separator:a055d87b78f69c9d039b7e12ead7aa6b6 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf24e0ec4b4b51df542cd654230c3da inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aaaf24e0ec4b4b51df542cd654230c3da">IsNotNull</a> () const </td></tr>
<tr class="separator:aaaf24e0ec4b4b51df542cd654230c3da inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef62c8761ddd1b95824fc57b1b277b5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aaef62c8761ddd1b95824fc57b1b277b5">IsEmpty</a> () const </td></tr>
<tr class="separator:aaef62c8761ddd1b95824fc57b1b277b5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484ba322b1d13f2e2c90066db81179ed inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a484ba322b1d13f2e2c90066db81179ed">IsNotEmpty</a> () const </td></tr>
<tr class="separator:a484ba322b1d13f2e2c90066db81179ed inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9706f704337ae92062d7b68c8f33ea inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:aaf9706f704337ae92062d7b68c8f33ea inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aaf9706f704337ae92062d7b68c8f33ea">CharAt</a> (int idx) const </td></tr>
<tr class="separator:aaf9706f704337ae92062d7b68c8f33ea inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43766377944d0423a71478f1bbd61e1 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:aa43766377944d0423a71478f1bbd61e1 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa43766377944d0423a71478f1bbd61e1">CharAtStart</a> () const </td></tr>
<tr class="separator:aa43766377944d0423a71478f1bbd61e1 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fb764265a5d096e56717a52754396d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a78fb764265a5d096e56717a52754396d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a78fb764265a5d096e56717a52754396d">CharAtEnd</a> () const </td></tr>
<tr class="separator:a78fb764265a5d096e56717a52754396d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3b9871d2fc6522c1f2aedf67b8b1c2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a0b3b9871d2fc6522c1f2aedf67b8b1c2">operator[]</a> (int op) const </td></tr>
<tr class="separator:a0b3b9871d2fc6522c1f2aedf67b8b1c2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30b895dcfaf0574aca843b212ee2602 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa30b895dcfaf0574aca843b212ee2602">Equals</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:aa30b895dcfaf0574aca843b212ee2602 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6c00e3b4e659d0088973d4219d86b3 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a0c6c00e3b4e659d0088973d4219d86b3 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a0c6c00e3b4e659d0088973d4219d86b3">ContainsAt</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, int pos, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:a0c6c00e3b4e659d0088973d4219d86b3 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874e198025e872dc30012ccdaef4ea71 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a874e198025e872dc30012ccdaef4ea71">StartsWith</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:a874e198025e872dc30012ccdaef4ea71 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f943472db189e27586b5ad6df554f4 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a34f943472db189e27586b5ad6df554f4">EndsWith</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:a34f943472db189e27586b5ad6df554f4 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9596ce7ca16857d887ae619a42d231c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:aa9596ce7ca16857d887ae619a42d231c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa9596ce7ca16857d887ae619a42d231c">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:aa9596ce7ca16857d887ae619a42d231c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830c0be0e018f2e52eb311d566e61338 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a830c0be0e018f2e52eb311d566e61338 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a830c0be0e018f2e52eb311d566e61338">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity, int cmpRegionStart, int cmpRegionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>) const </td></tr>
<tr class="separator:a830c0be0e018f2e52eb311d566e61338 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6c71cbde80abfd17075314878964a9 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a6e6c71cbde80abfd17075314878964a9 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a6e6c71cbde80abfd17075314878964a9">CompareTo</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity, int cmpRegionStart, int cmpRegionLength, int regionStart, int regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>) const </td></tr>
<tr class="separator:a6e6c71cbde80abfd17075314878964a9 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87398e168744e30fdae0c9641273ab2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa87398e168744e30fdae0c9641273ab2">operator&lt;</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const </td></tr>
<tr class="separator:aa87398e168744e30fdae0c9641273ab2 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e233e56892e8dde5bbc59d232561895 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8e233e56892e8dde5bbc59d232561895">operator&gt;</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const </td></tr>
<tr class="separator:a8e233e56892e8dde5bbc59d232561895 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5458d43552b4f83c721cc967f091cc4c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a5458d43552b4f83c721cc967f091cc4c">operator==</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const </td></tr>
<tr class="separator:a5458d43552b4f83c721cc967f091cc4c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9582e8e8e4b37606065566ec88f9626d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a9582e8e8e4b37606065566ec88f9626d">operator!=</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;op) const </td></tr>
<tr class="separator:a9582e8e8e4b37606065566ec88f9626d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4903bdaa9803322caddc87c623646a90 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a4903bdaa9803322caddc87c623646a90">IndexOf</a> (char needle) const </td></tr>
<tr class="separator:a4903bdaa9803322caddc87c623646a90 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62c5abf6381ef65c72b97183fd64c8d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:ab62c5abf6381ef65c72b97183fd64c8d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ab62c5abf6381ef65c72b97183fd64c8d">IndexOf</a> (char needle, int regionStart) const </td></tr>
<tr class="separator:ab62c5abf6381ef65c72b97183fd64c8d inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea4959c28189d614a7c883dae3787f5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a8ea4959c28189d614a7c883dae3787f5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a8ea4959c28189d614a7c883dae3787f5">IndexOf</a> (char needle, int regionStart, int regionLength) const </td></tr>
<tr class="separator:a8ea4959c28189d614a7c883dae3787f5 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff7c059a19d1003e1d150ab86d784f8 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:a6ff7c059a19d1003e1d150ab86d784f8 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a6ff7c059a19d1003e1d150ab86d784f8">LastIndexOf</a> (char needle, int startIndex=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>) const </td></tr>
<tr class="separator:a6ff7c059a19d1003e1d150ab86d784f8 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56c0c63f30160a0e3e44957e3409732 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:af56c0c63f30160a0e3e44957e3409732 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#af56c0c63f30160a0e3e44957e3409732">IndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needles, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a217539925b78b2eed40ae7817d5bee52">enums::Inclusion</a> inclusion, int startIdx=0) const </td></tr>
<tr class="separator:af56c0c63f30160a0e3e44957e3409732 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7292ca793aceb1572d65a8ee444e97c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:aa7292ca793aceb1572d65a8ee444e97c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa7292ca793aceb1572d65a8ee444e97c">LastIndexOfAny</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needles, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a217539925b78b2eed40ae7817d5bee52">enums::Inclusion</a> inclusion, int startIdx=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>) const </td></tr>
<tr class="separator:aa7292ca793aceb1572d65a8ee444e97c inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc427de75c146cf8618a397833edaa9a inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplParams" colspan="2">template&lt;bool TCheck = true&gt; </td></tr>
<tr class="memitem:adc427de75c146cf8618a397833edaa9a inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adc427de75c146cf8618a397833edaa9a">IndexOfSubstring</a> (const <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> &amp;needle, int startIdx=0, <a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a> sensitivity=<a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a>) const </td></tr>
<tr class="separator:adc427de75c146cf8618a397833edaa9a inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cfa0a1eb5f3c47cb633967c8b22333 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GrpALibMacros.html#ga74fe706f3101d8e1e21555f772da2849">ALIB_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a73cfa0a1eb5f3c47cb633967c8b22333">ToWString</a> (wchar_t *dest, int destCapacity, int regionStart=0, int regionLength=<a class="el" href="classaworx_1_1lib_1_1strings_1_1CString.html#a702a7d928cd1d34c5aa2f26dd97e199e">CString::MaxLen</a>) const </td></tr>
<tr class="separator:a73cfa0a1eb5f3c47cb633967c8b22333 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe13e5000dc11709e5da14d928f838b7 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#afe13e5000dc11709e5da14d928f838b7">AdjustRegion</a> (int &amp;regionStart, int &amp;regionLength) const </td></tr>
<tr class="separator:afe13e5000dc11709e5da14d928f838b7 inherit pub_methods_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Debug methods</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp55cbe8a442f26d567741a00b4fa5a1b0"></a></p><h6></h6>
<h2></h2>
</td></tr>
<tr class="memitem:ac3615a067cb671e6b0cac6dbb26c9f3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ac3615a067cb671e6b0cac6dbb26c9f3e">debugIsTerminated</a> =-1</td></tr>
<tr class="separator:ac3615a067cb671e6b0cac6dbb26c9f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8747c38ac0ef9f863ede544d51ff6721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a8747c38ac0ef9f863ede544d51ff6721">_dbgCheck</a> () const </td></tr>
<tr class="separator:a8747c38ac0ef9f863ede544d51ff6721"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constructor and Assignment</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd5ad566e0137ca24d0b82ada328a64b3"></a></p><h6></h6>
<h2></h2>
</td></tr>
<tr class="memitem:ad751e8adb9aa217a042c45e1c0585285"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ad751e8adb9aa217a042c45e1c0585285">TString</a> ()</td></tr>
<tr class="separator:ad751e8adb9aa217a042c45e1c0585285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0c3a5e03ba9a10bd9b19a22a261499"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe0c3a5e03ba9a10bd9b19a22a261499"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#abe0c3a5e03ba9a10bd9b19a22a261499">TString</a> (const T &amp;src)</td></tr>
<tr class="separator:abe0c3a5e03ba9a10bd9b19a22a261499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d715743a3937ea101a8deda34d993dc"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a6d715743a3937ea101a8deda34d993dc">TString</a> (const char *<a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a>, int contentLength)</td></tr>
<tr class="separator:a6d715743a3937ea101a8deda34d993dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classaworx_1_1lib_1_1strings_1_1String')"><img src="closed.png" alt="-"/>&#160;Protected Fields inherited from <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a></td></tr>
<tr class="memitem:adae84acc92cd77a04f6aaf533643a33a inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#adae84acc92cd77a04f6aaf533643a33a">buffer</a></td></tr>
<tr class="separator:adae84acc92cd77a04f6aaf533643a33a inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f59b34b1f25fe00023291b678246bcc inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a9f59b34b1f25fe00023291b678246bcc">length</a></td></tr>
<tr class="separator:a9f59b34b1f25fe00023291b678246bcc inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab060ffba71bd8a3d7067a38950b39a82 inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#ab060ffba71bd8a3d7067a38950b39a82">vbuffer</a></td></tr>
<tr class="separator:ab060ffba71bd8a3d7067a38950b39a82 inherit pro_attribs_classaworx_1_1lib_1_1strings_1_1String"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6d715743a3937ea101a8deda34d993dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contentLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Constructs this object using the given external buffer and length of content.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is protected to avoid the creation of objects with non-terminatable types.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to use. </td></tr>
    <tr><td class="paramname">contentLength</td><td>The length of the content in the given buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad751e8adb9aa217a042c45e1c0585285"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Default constructor creating a <em>nulled</em> <b>TString</b>. </p>

</div>
</div>
<a class="anchor" id="abe0c3a5e03ba9a10bd9b19a22a261499"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This constructor overloads the powerful templated constructor <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a2b1f593a0b9b71d210993cea0727b419">String::String(const T&amp;)</a>. In addition to invoking that, it is asserted that the given value is terminated or type T is terminatable. For more information see this classes' general description.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The string to represent by this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8747c38ac0ef9f863ede544d51ff6721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _dbgCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Validates this instance. This method is available only if <a class="el" href="group__GrpALibCodeSelectorSymbols.html#gae0e4a87e11482df5ecd72f6a2a648f05">ALIB_DEBUG_STRINGS</a> is defined. Invocations to this method should be performed using macro <a class="el" href="group__GrpALibStringsMacros.html#gae7492253da37c76b118d446494f1f632">ALIB_STRING_DBG_CHK</a>. </p>

</div>
</div>
<a class="anchor" id="a57423bbca362af5c912ea619d9a14746"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17">enums::Case</a>&#160;</td>
          <td class="paramname"><em>sensitivity</em> = <code><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#ab9aab17a5e54a8bae6915bc24db13a17a8f21fcdc233ba4078679ca628453d06b">enums::Case::Sensitive</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Search the given terminatable string in this object.</p>
<dl class="section note"><dt>Note</dt><dd>Parameter <code>needle</code> is required to be terminated or terminatable, the same as this object is. For non-terminatable string types (e.g. those of type <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a>), a less performant implementation of this method is available through class <b>String</b> with: <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a4903bdaa9803322caddc87c623646a90">IndexOf</a>.<br />
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is added to the method name, no parameter checks are performed and the needle must not be empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needle</td><td>The <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html">String</a> to search for. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. Optional and defaults to 0. </td></tr>
    <tr><td class="paramname">sensitivity</td><td>Case sensitivity of the comparison. Optional and defaults to Case::Sensitive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the string is not found. Otherwise the index of first occurrence. </dd></dl>

</div>
</div>
<a class="anchor" id="a77001b79e815a22ce126e3df14f591b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int IndexOfAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> &amp;&#160;</td>
          <td class="paramname"><em>needles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaworx_1_1lib_1_1enums.html#a217539925b78b2eed40ae7817d5bee52">enums::Inclusion</a>&#160;</td>
          <td class="paramname"><em>inclusion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Returns the index of the first character which is included, respectively <em>not</em> included in a given set of characters.</p>
<p>This method searches forwards. For backwards search, see <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#aa7292ca793aceb1572d65a8ee444e97c">String::LastIndexOfAny</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This method reimplements method <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a4903bdaa9803322caddc87c623646a90">String::IndexOf</a> of parent class. This implementation however needs (beside the fact that this is a zero terminatable) a zero-terminatable string for the needles. If no zero-terminatable needles are available, parent method accepting non-zero terminated needles needs to be invoked. This is possible, for example by writing e.g. <em>mystring.String::IndexOf()</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCheck</td><td>Defaults to <code>true</code> which is the normal invocation mode. If <code>&lt;false&gt;</code> is added to the method name, no parameter checks are performed and the needles must not be empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">needles</td><td>Pointer to a zero terminated set of characters to be taken into account. </td></tr>
    <tr><td class="paramname">inclusion</td><td>Denotes whether the search returns the first index that holds a value that is included or that is not excluded in the set of needle characters. </td></tr>
    <tr><td class="paramname">startIdx</td><td>The index to start the search at. If the given value is less than 0, it is set to 0. If it exceeds the length of the string, the length of the string is returned. Defaults to 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character found which is included, respectively not included, in the given set of characters. If nothing is found, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ab75164b28454722bdf29710c208f0736"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operator const char * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Cast operator to <em>const char*</em>. Invokes and returns result of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#af283db5a533654cb8a0fa2e110d4b20f">ToCString</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Casting an instance with <em>(const char*)</em> is the same as invoking method <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#af283db5a533654cb8a0fa2e110d4b20f">ToCString</a> on that instance. The operator is provided as an alias and it is a matter of taste which of them to use. </dd>
<dd>
This operator is marked explicit. Although implicit conversion would be quite convenient, the need for adding the cast explicitly should be helpful in understanding the structure of the code and leads to more predictable compiler warnings and invocations of overloaded methods. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b3b9871d2fc6522c1f2aedf67b8b1c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Reads a character at a given index.<br />
 Overwrites <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a0b3b9871d2fc6522c1f2aedf67b8b1c2">String::operator[]</a> to change the debug assertion to allow inclusion of the termination character.</p>
<dl class="section attention"><dt>Attention</dt><dd>No parameter check is performed (other than an assertions in debug-compilation of ALib). See <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a0b3b9871d2fc6522c1f2aedf67b8b1c2">String::operator[]</a> for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The index of the character within this objects' buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the character contained at index <code>op</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a1430f618f869550a47b5f078ce6860"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Terminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Checks if this objects' buffer is terminated and - if not - terminates it by writing '\0' into the first character of the buffer after the represented string (precisely into <em>buffer[ length ]</em>).</p>
<dl class="section note"><dt>Note</dt><dd>When compiler symbol <a class="el" href="group__GrpALibCodeSelectorSymbols.html#gae0e4a87e11482df5ecd72f6a2a648f05">ALIB_DEBUG_STRINGS</a> is set, the state of debug field <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ac3615a067cb671e6b0cac6dbb26c9f3e">debugIsTerminated</a> gets set to '1'.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#af283db5a533654cb8a0fa2e110d4b20f">ToCString</a>, <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#ab75164b28454722bdf29710c208f0736">operator const char*()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af283db5a533654cb8a0fa2e110d4b20f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* ToCString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> This instances' buffer will be terminated (if not already) and returned. If this object is <em>nulled</em>, a pointer to an empty cstring is returned. This allows to omit explicit checks for <em>nulled</em> objects, in the frequent case that no difference should be made in the processing of a <em>nulled</em> or a not <em>nulled</em>, but empty object.</p>
<dl class="section note"><dt>Note</dt><dd>If used within loops, it is advisable to use a combination of <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a7a1430f618f869550a47b5f078ce6860">Terminate</a> (before the loop) and <a class="el" href="classaworx_1_1lib_1_1strings_1_1String.html#a5d5ce30daece7ec96d0b70ccc5d46002">Buffer</a> (inside the loop) to avoid the overhead for a repeated termination check.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The internal, now zero terminated buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="aefab2dff23cb4a711c8efdd73e85c15e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ToFloat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a> *&#160;</td>
          <td class="paramname"><em>numberFormat</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> *&#160;</td>
          <td class="paramname"><em>whitespaces</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads a floating point value from this object at the given position using the class <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html">NumberFormat</a>. If no object of this type is provided with optional parameter <code>numberFormat</code>, the static default object found in <a class="el" href="classaworx_1_1lib_1_1strings_1_1NumberFormat.html#a9c9a27c7479023730cc33644fc6c9164">NumberFormat::Global</a> is used.</p>
<p>Leading whitespace characters as defined in optional parameter <code>whitespaces</code>, are ignored.</p>
<p>The optional output parameter <code>newIdx</code> is set to point to the first character that does not belong to the number. If no number is found at the given index (respectively at the first non-whitespace character at or after the given index), zero is returned and the output parameter is set to the original start index.</p>
<dl class="section note"><dt>Note</dt><dd>For converting non-zero terminated strings, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index from where the float value is tried to be read. Defaults to 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character after the float number that was parsed. If parsing fails, it will be set to the value of parameter startIdx. Therefore, this parameter can be used to check if a value was found. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numberFormat</td><td>The object performing the conversion and defines the output format. Optional and defaults to nullptr. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">whitespaces</td><td>White space characters used to trim the substring at the front before reading the value. Defaults to nullptr, which causes the method to use <a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">aworx::DefaultWhitespaces</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, on success, the output parameter <code>newIdx</code> is set to point to the first character behind any found float number. </dd></dl>

</div>
</div>
<a class="anchor" id="a0318c4e2b29a58be56c9f8645184448d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ToInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> *&#160;</td>
          <td class="paramname"><em>whitespaces</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr/>
<p> Reads a 32-bit integer from this object at the given position. The output parameter is set to point to the first character that is not a number. If no number is found at the given index, zero is returned and the output parameter is set to the original start index.</p>
<p>Leading whitespace characters are ignored. However, if after leading whitespaces no numbers were found, then the output parameter is set to the original start index. This way, the optionally provided index can be used to check if parsing succeeded.</p>
<dl class="section note"><dt>Note</dt><dd>For converting non-zero terminated strings, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index from where the integer value is tried to be parsed. Optional and defaults to 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the float number that was parsed. If parsing fails, it will be set to the value of parameter startIdx. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">whitespaces</td><td>White space characters used to trim the substring at the front before reading the value. Defaults to nullptr, which causes the method to use <a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">aworx::DefaultWhitespaces</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the output parameter <code>newIdx</code> is set to point to the first character behind any found integer number. </dd></dl>

</div>
</div>
<a class="anchor" id="af2efe140bd7fe9300fa64c27c7adab08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t ToLong </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startIdx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>newIdx</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html">TString</a> *&#160;</td>
          <td class="paramname"><em>whitespaces</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<hr/>
<p> Reads a 64-bit integer from this object at the given position. The output parameter is set to point to the first character that is not a number. If no number is found at the given index, zero is returned and the output parameter is set to the original start index.</p>
<p>Leading whitespace characters are ignored. However, if after leading whitespaces no numbers were found, then the output parameter is set to the original start index. This way, the optionally provided index can be used to check if parsing succeeded.</p>
<dl class="section note"><dt>Note</dt><dd>For converting non-zero terminated strings, see class <a class="el" href="classaworx_1_1lib_1_1strings_1_1Substring.html">Substring</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">startIdx</td><td>The start index from where the integer value is tried to be parsed. Optional and defaults to 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newIdx</td><td>Optional output variable that will point to the first character in this string after the float number that was parsed. If parsing fails, it will be set to the value of parameter startIdx. Therefore, this parameter can be used to check if a value was found. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">whitespaces</td><td>White space characters used to trim the substring at the front before reading the value. Defaults to nullptr, which causes the method to use <a class="el" href="namespaceaworx.html#a5feaaf6a8fb11e8ebbb0013ec9f27b01">aworx::DefaultWhitespaces</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parsed value. In addition, the parameter <code>newIdx</code> is set to point to the first character behind any found integer number. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac3615a067cb671e6b0cac6dbb26c9f3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int debugIsTerminated =-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This field serves for debugging the development (and potentially the use) of derived classes, eg. class <a class="el" href="classaworx_1_1lib_1_1strings_1_1AString.html">AString</a>. It is available only when compiler symbol <a class="el" href="group__GrpALibCodeSelectorSymbols.html#gae0e4a87e11482df5ecd72f6a2a648f05">ALIB_DEBUG_STRINGS</a> is set. When active, whenever the contents of an <b>AString</b> instance is modified, the buffer is explicitly "unterminated" by writing a value of '\1' at the termination position and the state is stored in this field .<br />
 To keep the constructor <em>constexpr</em>, it is -1 (undetermined) after construction. </p><dl class="section see"><dt>See also</dt><dd>Macro <a class="el" href="group__GrpALibStringsMacros.html#gacf96023d903e78f3b5d784a799041667">ALIB_STRING_DBG_UNTERMINATE</a> and method <a class="el" href="classaworx_1_1lib_1_1strings_1_1TString.html#a7a1430f618f869550a47b5f078ce6860">Terminate</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="tstring_8hpp_source.html">tstring.hpp</a></li>
<li>tstring.cpp</li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 19 2016 14:36:16 for ALox by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
